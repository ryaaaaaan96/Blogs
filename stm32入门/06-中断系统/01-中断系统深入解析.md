# STM32中断系统深入解析

## 📋 概述

中断是嵌入式系统中最重要的概念之一，它允许处理器暂停当前执行的任务来响应紧急事件。STM32采用ARM Cortex-M内核的嵌套向量中断控制器(NVIC)，提供了高效、灵活的中断管理机制。掌握中断系统对于开发实时响应的嵌入式应用至关重要。

## 🎯 STM32中断系统架构

### ARM Cortex-M中断控制器

```
┌─────────────────────────────────────────────────┐
│                NVIC架构图                        │
├─────────────────────────────────────────────────┤
│                                                 │
│  外部中断源 → ┌─────┐ → ┌─────┐ → ┌─────┐      │
│              │中断 │   │优先级│   │向量 │      │
│              │检测 │   │仲裁 │   │跳转 │ → CPU │
│              └─────┘   └─────┘   └─────┘      │
│                   ↑         ↑         ↑        │
│              中断使能    优先级设置  中断向量表   │
│                                                 │
│  内部中断源 → ┌─────┐                          │
│  (定时器等)   │NVIC │                          │
│              │控制器│                          │
│              └─────┘                          │
│                                                 │
│  系统异常 → SysTick、PendSV、SVC等             │
└─────────────────────────────────────────────────┘
```

### 中断优先级机制

STM32F407使用4位优先级，可配置为：

| 配置 | 抢占优先级位数 | 子优先级位数 | 抢占级别数 | 子级别数 |
|------|----------------|--------------|------------|----------|
| **NVIC_PRIORITYGROUP_0** | 0位 | 4位 | 1 | 16 |
| **NVIC_PRIORITYGROUP_1** | 1位 | 3位 | 2 | 8 |
| **NVIC_PRIORITYGROUP_2** | 2位 | 2位 | 4 | 4 |
| **NVIC_PRIORITYGROUP_3** | 3位 | 1位 | 8 | 2 |
| **NVIC_PRIORITYGROUP_4** | 4位 | 0位 | 16 | 1 |

```c
// 优先级分组配置
void NVIC_Config(void)
{
    // 设置优先级分组 (2位抢占优先级，2位子优先级)
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    
    /*
    优先级计算公式：
    抢占优先级 = (优先级值 >> 子优先级位数) & 抢占优先级掩码
    子优先级 = 优先级值 & 子优先级掩码
    
    例如：优先级分组2，优先级值为0x05 (0101)
    抢占优先级 = (5 >> 2) & 0x3 = 1
    子优先级 = 5 & 0x3 = 1
    */
}
```

## ⚡ 外部中断配置

### GPIO外部中断

```c
// GPIO外部中断配置结构体
typedef struct
{
    GPIO_TypeDef* port;
    uint16_t pin;
    IRQn_Type irq;
    uint8_t preempt_priority;
    uint8_t sub_priority;
    GPIO_PinState trigger_level;
} EXTI_Config_t;

// 外部中断配置数组
EXTI_Config_t exti_configs[] = {
    {GPIOA, GPIO_PIN_0, EXTI0_IRQn, 1, 0, GPIO_PIN_RESET},      // 按键1
    {GPIOA, GPIO_PIN_1, EXTI1_IRQn, 1, 1, GPIO_PIN_RESET},      // 按键2  
    {GPIOA, GPIO_PIN_2, EXTI2_IRQn, 2, 0, GPIO_PIN_SET},        // 传感器
    {GPIOA, GPIO_PIN_3, EXTI3_IRQn, 2, 1, GPIO_PIN_RESET},      // 限位开关
};

#define EXTI_COUNT (sizeof(exti_configs)/sizeof(exti_configs[0]))

// 外部中断初始化
void EXTI_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    // 使能GPIO时钟
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    // 设置优先级分组
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    
    for(int i = 0; i < EXTI_COUNT; i++)
    {
        // GPIO配置
        GPIO_InitStruct.Pin = exti_configs[i].pin;
        GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  // 下降沿触发
        
        if(exti_configs[i].trigger_level == GPIO_PIN_RESET)
        {
            GPIO_InitStruct.Pull = GPIO_PULLUP;       // 按键类输入，内部上拉
        }
        else
        {
            GPIO_InitStruct.Pull = GPIO_PULLDOWN;     // 传感器类输入，内部下拉
            GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; // 上升沿触发
        }
        
        HAL_GPIO_Init(exti_configs[i].port, &GPIO_InitStruct);
        
        // NVIC配置
        HAL_NVIC_SetPriority(exti_configs[i].irq, 
                           exti_configs[i].preempt_priority, 
                           exti_configs[i].sub_priority);
        HAL_NVIC_EnableIRQ(exti_configs[i].irq);
    }
}

// 外部中断回调函数
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    static uint32_t last_interrupt_time[16] = {0};
    uint32_t current_time = HAL_GetTick();
    uint8_t pin_index = 0;
    
    // 获取引脚索引
    uint16_t temp_pin = GPIO_Pin;
    while(temp_pin >>= 1) pin_index++;
    
    // 软件消抖 (50ms)
    if(current_time - last_interrupt_time[pin_index] < 50)
    {
        return;
    }
    last_interrupt_time[pin_index] = current_time;
    
    switch(GPIO_Pin)
    {
        case GPIO_PIN_0:  // 按键1
            printf("Button 1 Pressed\r\n");
            HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);  // LED切换
            break;
            
        case GPIO_PIN_1:  // 按键2
            printf("Button 2 Pressed\r\n");
            // 触发特定功能
            break;
            
        case GPIO_PIN_2:  // 传感器
            printf("Sensor Triggered\r\n");
            // 传感器处理逻辑
            break;
            
        case GPIO_PIN_3:  // 限位开关
            printf("Limit Switch Activated\r\n");
            // 紧急停止逻辑
            Motor_Emergency_Stop();
            break;
            
        default:
            break;
    }
}

// 外部中断服务函数
void EXTI0_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
}

void EXTI1_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
}

void EXTI2_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);
}

void EXTI3_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
}
```

### 多按键中断管理

```c
// 按键状态管理结构体
typedef struct
{
    GPIO_TypeDef* port;
    uint16_t pin;
    uint8_t state;               // 当前状态
    uint8_t last_state;          // 上一次状态
    uint32_t press_time;         // 按下时间
    uint32_t release_time;       // 释放时间
    uint8_t click_count;         // 点击次数
    uint32_t last_click_time;    // 上次点击时间
} Button_t;

// 按键事件类型
typedef enum
{
    BUTTON_EVENT_NONE = 0,
    BUTTON_EVENT_PRESS,          // 按下
    BUTTON_EVENT_RELEASE,        // 释放
    BUTTON_EVENT_CLICK,          // 单击
    BUTTON_EVENT_DOUBLE_CLICK,   // 双击
    BUTTON_EVENT_LONG_PRESS,     // 长按
    BUTTON_EVENT_VERY_LONG_PRESS // 超长按
} Button_Event_t;

// 按键管理数组
Button_t buttons[] = {
    {GPIOA, GPIO_PIN_0, 1, 1, 0, 0, 0, 0},  // 按键1
    {GPIOA, GPIO_PIN_1, 1, 1, 0, 0, 0, 0},  // 按键2
    {GPIOA, GPIO_PIN_2, 1, 1, 0, 0, 0, 0},  // 按键3
    {GPIOA, GPIO_PIN_3, 1, 1, 0, 0, 0, 0},  // 按键4
};

#define BUTTON_COUNT (sizeof(buttons)/sizeof(buttons[0]))

// 按键扫描任务 (在定时器中断中调用，10ms间隔)
void Button_Scan_Task(void)
{
    uint32_t current_time = HAL_GetTick();
    
    for(int i = 0; i < BUTTON_COUNT; i++)
    {
        buttons[i].last_state = buttons[i].state;
        buttons[i].state = HAL_GPIO_ReadPin(buttons[i].port, buttons[i].pin);
        
        // 检测按下事件
        if(buttons[i].last_state == 1 && buttons[i].state == 0)
        {
            buttons[i].press_time = current_time;
            Button_Event_Handler(i, BUTTON_EVENT_PRESS);
        }
        
        // 检测释放事件
        if(buttons[i].last_state == 0 && buttons[i].state == 1)
        {
            buttons[i].release_time = current_time;
            uint32_t press_duration = current_time - buttons[i].press_time;
            
            Button_Event_Handler(i, BUTTON_EVENT_RELEASE);
            
            // 判断点击类型
            if(press_duration < 100)  // 短按 (<100ms)
            {
                // 检测双击
                if(current_time - buttons[i].last_click_time < 500)
                {
                    buttons[i].click_count++;
                    if(buttons[i].click_count >= 2)
                    {
                        Button_Event_Handler(i, BUTTON_EVENT_DOUBLE_CLICK);
                        buttons[i].click_count = 0;
                    }
                }
                else
                {
                    buttons[i].click_count = 1;
                }
                buttons[i].last_click_time = current_time;
            }
            else if(press_duration < 2000)  // 长按 (100ms-2s)
            {
                Button_Event_Handler(i, BUTTON_EVENT_LONG_PRESS);
            }
            else  // 超长按 (>2s)
            {
                Button_Event_Handler(i, BUTTON_EVENT_VERY_LONG_PRESS);
            }
        }
        
        // 检测单击 (延时确认)
        if(buttons[i].click_count == 1 && 
           current_time - buttons[i].last_click_time > 500)
        {
            Button_Event_Handler(i, BUTTON_EVENT_CLICK);
            buttons[i].click_count = 0;
        }
    }
}

// 按键事件处理函数
void Button_Event_Handler(uint8_t button_id, Button_Event_t event)
{
    switch(button_id)
    {
        case 0:  // 按键1
            switch(event)
            {
                case BUTTON_EVENT_CLICK:
                    printf("Button 1 Click\r\n");
                    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
                    break;
                case BUTTON_EVENT_DOUBLE_CLICK:
                    printf("Button 1 Double Click\r\n");
                    // 模式切换
                    break;
                case BUTTON_EVENT_LONG_PRESS:
                    printf("Button 1 Long Press\r\n");
                    // 进入设置模式
                    break;
                default:
                    break;
            }
            break;
            
        case 1:  // 按键2
            // 类似处理...
            break;
            
        default:
            break;
    }
}
```

## 🕒 定时器中断应用

### 系统时基中断

```c
// 系统任务管理结构体
typedef struct
{
    void (*task_func)(void);     // 任务函数指针
    uint32_t period;             // 执行周期(ms)
    uint32_t last_run;           // 上次运行时间
    uint8_t enable;              // 任务使能
    uint32_t run_count;          // 运行次数
    uint32_t max_exec_time;      // 最大执行时间
} System_Task_t;

// 系统任务列表
System_Task_t system_tasks[] = {
    {LED_Blink_Task,        1000, 0, 1, 0, 0},    // LED闪烁 1s
    {Button_Scan_Task,      10,   0, 1, 0, 0},    // 按键扫描 10ms
    {Sensor_Read_Task,      100,  0, 1, 0, 0},    // 传感器读取 100ms
    {Data_Process_Task,     50,   0, 1, 0, 0},    // 数据处理 50ms
    {Communication_Task,    20,   0, 1, 0, 0},    // 通信处理 20ms
};

#define TASK_COUNT (sizeof(system_tasks)/sizeof(system_tasks[0]))

// 系统定时器初始化 (1ms时基)
void System_Timer_Init(void)
{
    TIM_HandleTypeDef htim7;
    
    __HAL_RCC_TIM7_CLK_ENABLE();
    
    // 1ms定时器配置
    htim7.Instance = TIM7;
    htim7.Init.Prescaler = 83;                    // 84MHz/84 = 1MHz
    htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim7.Init.Period = 999;                      // 1MHz/1000 = 1kHz (1ms)
    htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
    {
        Error_Handler();
    }
    
    // 配置中断
    HAL_NVIC_SetPriority(TIM7_IRQn, 0, 0);       // 最高优先级
    HAL_NVIC_EnableIRQ(TIM7_IRQn);
    
    // 启动定时器中断
    HAL_TIM_Base_Start_IT(&htim7);
}

// 任务调度器 (在定时器中断中调用)
void Task_Scheduler(void)
{
    uint32_t current_time = HAL_GetTick();
    
    for(int i = 0; i < TASK_COUNT; i++)
    {
        if(system_tasks[i].enable && 
           (current_time - system_tasks[i].last_run >= system_tasks[i].period))
        {
            uint32_t start_time = HAL_GetTick();
            
            // 执行任务
            system_tasks[i].task_func();
            
            uint32_t exec_time = HAL_GetTick() - start_time;
            
            // 更新统计信息
            system_tasks[i].last_run = current_time;
            system_tasks[i].run_count++;
            
            if(exec_time > system_tasks[i].max_exec_time)
            {
                system_tasks[i].max_exec_time = exec_time;
            }
            
            // 检查任务超时
            if(exec_time > system_tasks[i].period / 2)
            {
                printf("Warning: Task %d execution time too long: %dms\r\n", i, exec_time);
            }
        }
    }
}

// 定时器中断回调
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM7)
    {
        // 系统任务调度
        Task_Scheduler();
        
        // 系统心跳计数
        static uint32_t heartbeat = 0;
        heartbeat++;
        
        if(heartbeat >= 1000)  // 每秒
        {
            printf("System Heartbeat: %d\r\n", heartbeat/1000);
            heartbeat = 0;
        }
    }
}

// 定时器中断服务函数
void TIM7_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&htim7);
}
```

### 精确延时中断

```c
// 精确延时结构体
typedef struct
{
    uint32_t delay_time;         // 延时时间(us)
    void (*callback)(void);      // 回调函数
    uint8_t active;              // 激活状态
    uint8_t repeat;              // 重复标志
} Precise_Delay_t;

Precise_Delay_t precise_delays[8];  // 支持8个精确延时

// 精确延时定时器初始化 (1us分辨率)
void Precise_Delay_Init(void)
{
    TIM_HandleTypeDef htim5;
    
    __HAL_RCC_TIM5_CLK_ENABLE();
    
    // 1us定时器配置
    htim5.Instance = TIM5;
    htim5.Init.Prescaler = 83;                    // 84MHz/84 = 1MHz
    htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim5.Init.Period = 0xFFFFFFFF;               // 32位最大值
    htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
    {
        Error_Handler();
    }
    
    // 配置中断
    HAL_NVIC_SetPriority(TIM5_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
    
    // 启动定时器
    HAL_TIM_Base_Start(&htim5);
    
    // 初始化延时数组
    memset(precise_delays, 0, sizeof(precise_delays));
}

// 设置精确延时
uint8_t Set_Precise_Delay(uint32_t delay_us, void (*callback)(void), uint8_t repeat)
{
    for(int i = 0; i < 8; i++)
    {
        if(!precise_delays[i].active)
        {
            precise_delays[i].delay_time = __HAL_TIM_GET_COUNTER(&htim5) + delay_us;
            precise_delays[i].callback = callback;
            precise_delays[i].active = 1;
            precise_delays[i].repeat = repeat;
            
            // 配置比较中断
            __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_1 + i, precise_delays[i].delay_time);
            __HAL_TIM_ENABLE_IT(&htim5, TIM_IT_CC1 << i);
            
            return i;  // 返回延时ID
        }
    }
    return 0xFF;  // 无可用延时槽
}

// 取消精确延时
void Cancel_Precise_Delay(uint8_t delay_id)
{
    if(delay_id < 8)
    {
        precise_delays[delay_id].active = 0;
        __HAL_TIM_DISABLE_IT(&htim5, TIM_IT_CC1 << delay_id);
    }
}

// 精确延时中断处理
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM5)
    {
        for(int i = 0; i < 8; i++)
        {
            if(precise_delays[i].active && 
               __HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1 << i))
            {
                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1 << i);
                
                // 执行回调函数
                if(precise_delays[i].callback)
                {
                    precise_delays[i].callback();
                }
                
                // 检查是否重复
                if(precise_delays[i].repeat)
                {
                    // 重新设置下次触发时间
                    precise_delays[i].delay_time = __HAL_TIM_GET_COUNTER(htim) + 
                                                  precise_delays[i].delay_time;
                    __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_1 + i, 
                                         precise_delays[i].delay_time);
                }
                else
                {
                    precise_delays[i].active = 0;
                    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1 << i);
                }
            }
        }
    }
}
```

## 🚀 串口中断应用

### DMA+中断接收

```c
// 串口接收缓冲区管理
#define UART_RX_BUFFER_SIZE 256
#define UART_RX_DMA_SIZE    64

typedef struct
{
    uint8_t rx_buffer[UART_RX_BUFFER_SIZE];  // 接收环形缓冲区
    uint8_t dma_buffer[UART_RX_DMA_SIZE];    // DMA接收缓冲区
    uint16_t write_index;                    // 写入索引
    uint16_t read_index;                     // 读取索引
    uint16_t data_count;                     // 数据计数
    uint8_t overflow_flag;                   // 溢出标志
} UART_RxBuffer_t;

UART_RxBuffer_t uart_rx;
UART_HandleTypeDef huart1;

// 串口DMA初始化
void UART_DMA_Init(void)
{
    // GPIO配置 (PA9-TX, PA10-RX)
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_USART1_CLK_ENABLE();
    __HAL_RCC_DMA2_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // UART配置
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    
    if (HAL_UART_Init(&huart1) != HAL_OK)
    {
        Error_Handler();
    }
    
    // DMA配置
    DMA_HandleTypeDef hdma_usart1_rx;
    
    hdma_usart1_rx.Instance = DMA2_Stream5;
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_HIGH;
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
    {
        Error_Handler();
    }
    
    __HAL_LINKDMA(&huart1, hdmarx, hdma_usart1_rx);
    
    // 中断配置
    HAL_NVIC_SetPriority(USART1_IRQn, 2, 0);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
    
    HAL_NVIC_SetPriority(DMA2_Stream5_IRQn, 2, 1);
    HAL_NVIC_EnableIRQ(DMA2_Stream5_IRQn);
    
    // 启动DMA接收
    HAL_UART_Receive_DMA(&huart1, uart_rx.dma_buffer, UART_RX_DMA_SIZE);
    
    // 使能空闲中断
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
    
    // 初始化缓冲区
    memset(&uart_rx, 0, sizeof(uart_rx));
}

// 空闲中断处理 (一帧数据接收完成)
void UART_IDLE_IRQHandler(void)
{
    if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))
    {
        __HAL_UART_CLEAR_IDLEFLAG(&huart1);
        
        // 计算接收到的数据长度
        uint16_t dma_count = UART_RX_DMA_SIZE - __HAL_DMA_GET_COUNTER(huart1.hdmarx);
        
        if(dma_count > 0)
        {
            // 将DMA缓冲区数据复制到环形缓冲区
            for(uint16_t i = 0; i < dma_count; i++)
            {
                uart_rx.rx_buffer[uart_rx.write_index] = uart_rx.dma_buffer[i];
                uart_rx.write_index = (uart_rx.write_index + 1) % UART_RX_BUFFER_SIZE;
                
                if(uart_rx.data_count < UART_RX_BUFFER_SIZE)
                {
                    uart_rx.data_count++;
                }
                else
                {
                    uart_rx.overflow_flag = 1;  // 缓冲区溢出
                    uart_rx.read_index = (uart_rx.read_index + 1) % UART_RX_BUFFER_SIZE;
                }
            }
            
            // 数据处理
            UART_Data_Process();
        }
        
        // 重新启动DMA接收
        HAL_UART_DMAStop(&huart1);
        HAL_UART_Receive_DMA(&huart1, uart_rx.dma_buffer, UART_RX_DMA_SIZE);
    }
}

// 读取接收缓冲区数据
uint16_t UART_Read_Buffer(uint8_t* data, uint16_t max_len)
{
    uint16_t read_count = 0;
    
    while(uart_rx.data_count > 0 && read_count < max_len)
    {
        data[read_count] = uart_rx.rx_buffer[uart_rx.read_index];
        uart_rx.read_index = (uart_rx.read_index + 1) % UART_RX_BUFFER_SIZE;
        uart_rx.data_count--;
        read_count++;
    }
    
    return read_count;
}

// 串口中断服务函数
void USART1_IRQHandler(void)
{
    if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))
    {
        UART_IDLE_IRQHandler();
    }
    
    HAL_UART_IRQHandler(&huart1);
}

void DMA2_Stream5_IRQHandler(void)
{
    HAL_DMA_IRQHandler(&hdma_usart1_rx);
}
```

## 🔧 中断调试与优化

### 中断性能监测

```c
// 中断性能统计结构体
typedef struct
{
    IRQn_Type irq_num;
    uint32_t count;              // 中断次数
    uint32_t total_time;         // 总执行时间
    uint32_t max_time;           // 最长执行时间
    uint32_t last_enter_time;    // 上次进入时间
    uint8_t active;              // 是否正在执行
} IRQ_Stats_t;

IRQ_Stats_t irq_stats[16];  // 监测16个中断

// 中断性能监测初始化
void IRQ_Monitor_Init(void)
{
    memset(irq_stats, 0, sizeof(irq_stats));
    
    // 注册需要监测的中断
    irq_stats[0].irq_num = EXTI0_IRQn;
    irq_stats[1].irq_num = TIM7_IRQn;
    irq_stats[2].irq_num = USART1_IRQn;
    // ... 添加更多中断
}

// 中断进入记录
void IRQ_Enter_Record(IRQn_Type irq)
{
    for(int i = 0; i < 16; i++)
    {
        if(irq_stats[i].irq_num == irq)
        {
            irq_stats[i].last_enter_time = HAL_GetTick();
            irq_stats[i].active = 1;
            irq_stats[i].count++;
            break;
        }
    }
}

// 中断退出记录
void IRQ_Exit_Record(IRQn_Type irq)
{
    for(int i = 0; i < 16; i++)
    {
        if(irq_stats[i].irq_num == irq && irq_stats[i].active)
        {
            uint32_t exec_time = HAL_GetTick() - irq_stats[i].last_enter_time;
            irq_stats[i].total_time += exec_time;
            
            if(exec_time > irq_stats[i].max_time)
            {
                irq_stats[i].max_time = exec_time;
            }
            
            irq_stats[i].active = 0;
            break;
        }
    }
}

// 中断统计报告
void IRQ_Stats_Report(void)
{
    printf("Interrupt Statistics:\r\n");
    printf("IRQ\tCount\tTotal(ms)\tMax(ms)\tAvg(ms)\r\n");
    
    for(int i = 0; i < 16; i++)
    {
        if(irq_stats[i].count > 0)
        {
            uint32_t avg_time = irq_stats[i].total_time / irq_stats[i].count;
            printf("%d\t%d\t%d\t\t%d\t%d\r\n",
                   irq_stats[i].irq_num,
                   irq_stats[i].count,
                   irq_stats[i].total_time,
                   irq_stats[i].max_time,
                   avg_time);
        }
    }
}

// 在中断服务函数中使用
void EXTI0_IRQHandler(void)
{
    IRQ_Enter_Record(EXTI0_IRQn);
    
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
    
    IRQ_Exit_Record(EXTI0_IRQn);
}
```

### 中断优先级优化

```c
// 中断优先级配置建议
void Optimal_IRQ_Priority_Config(void)
{
    // 设置优先级分组
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    
    // 系统关键中断 (抢占优先级0)
    HAL_NVIC_SetPriority(HardFault_IRQn, 0, 0);
    HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
    HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
    HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
    
    // 实时性要求高的中断 (抢占优先级1)
    HAL_NVIC_SetPriority(TIM7_IRQn, 1, 0);          // 系统时基
    HAL_NVIC_SetPriority(DMA2_Stream5_IRQn, 1, 1);  // 串口DMA
    
    // 一般外设中断 (抢占优先级2)
    HAL_NVIC_SetPriority(USART1_IRQn, 2, 0);        // 串口
    HAL_NVIC_SetPriority(TIM3_IRQn, 2, 1);          // 通用定时器
    HAL_NVIC_SetPriority(ADC_IRQn, 2, 2);           // ADC
    
    // 用户输入中断 (抢占优先级3)
    HAL_NVIC_SetPriority(EXTI0_IRQn, 3, 0);         // 按键
    HAL_NVIC_SetPriority(EXTI1_IRQn, 3, 1);
    HAL_NVIC_SetPriority(EXTI2_IRQn, 3, 2);
    HAL_NVIC_SetPriority(EXTI3_IRQn, 3, 3);
}
```

## 💡 中断使用建议

### 中断设计原则

**快进快出**：
```c
// 好的中断处理方式
void TIMx_IRQHandler(void)
{
    if(__HAL_TIM_GET_FLAG(&htimx, TIM_FLAG_UPDATE))
    {
        __HAL_TIM_CLEAR_FLAG(&htimx, TIM_FLAG_UPDATE);
        
        // 设置标志位
        task_flag = 1;
        
        // 简单计数
        timer_count++;
    }
}

// 在主循环中处理复杂逻辑
void main_loop(void)
{
    if(task_flag)
    {
        task_flag = 0;
        // 复杂的数据处理
        Process_Complex_Data();
    }
}
```

**避免长时间操作**：
```c
// 避免在中断中进行的操作
void Bad_IRQ_Handler(void)
{
    // ❌ 避免长延时
    HAL_Delay(100);
    
    // ❌ 避免复杂计算
    float result = complex_calculation();
    
    // ❌ 避免串口打印
    printf("Interrupt occurred\r\n");
    
    // ❌ 避免动态内存分配
    char* buffer = malloc(256);
}
```

### 性能优化技巧

**使用临界区保护**：
```c
// 临界区保护示例
void Critical_Section_Example(void)
{
    uint32_t primask;
    
    // 进入临界区
    primask = __get_PRIMASK();
    __disable_irq();
    
    // 关键代码段
    shared_variable++;
    
    // 退出临界区
    __set_PRIMASK(primask);
}
```

**中断嵌套控制**：
```c
// 控制中断嵌套深度
void Nested_IRQ_Control(void)
{
    // 临时提高当前中断优先级
    uint32_t basepri = __get_BASEPRI();
    __set_BASEPRI(0x40);  // 屏蔽优先级低于4的中断
    
    // 关键代码
    Critical_Process();
    
    // 恢复原优先级
    __set_BASEPRI(basepri);
}
```

---

> **中断总结**：中断系统是实时嵌入式系统的核心。正确设计中断优先级、遵循快进快出原则、合理使用中断嵌套，是构建稳定高效系统的关键。通过性能监测和优化，可以确保系统的实时性要求。

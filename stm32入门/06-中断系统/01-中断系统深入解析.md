# STM32ä¸­æ–­ç³»ç»Ÿæ·±å…¥è§£æ

## ğŸ“‹ æ¦‚è¿°

ä¸­æ–­æ˜¯åµŒå…¥å¼ç³»ç»Ÿä¸­æœ€é‡è¦çš„æ¦‚å¿µä¹‹ä¸€ï¼Œå®ƒå…è®¸å¤„ç†å™¨æš‚åœå½“å‰æ‰§è¡Œçš„ä»»åŠ¡æ¥å“åº”ç´§æ€¥äº‹ä»¶ã€‚STM32é‡‡ç”¨ARM Cortex-Må†…æ ¸çš„åµŒå¥—å‘é‡ä¸­æ–­æ§åˆ¶å™¨(NVIC)ï¼Œæä¾›äº†é«˜æ•ˆã€çµæ´»çš„ä¸­æ–­ç®¡ç†æœºåˆ¶ã€‚æŒæ¡ä¸­æ–­ç³»ç»Ÿå¯¹äºå¼€å‘å®æ—¶å“åº”çš„åµŒå…¥å¼åº”ç”¨è‡³å…³é‡è¦ã€‚

## ğŸ¯ STM32ä¸­æ–­ç³»ç»Ÿæ¶æ„

### ARM Cortex-Mä¸­æ–­æ§åˆ¶å™¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                NVICæ¶æ„å›¾                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  å¤–éƒ¨ä¸­æ–­æº â†’ â”Œâ”€â”€â”€â”€â”€â” â†’ â”Œâ”€â”€â”€â”€â”€â” â†’ â”Œâ”€â”€â”€â”€â”€â”      â”‚
â”‚              â”‚ä¸­æ–­ â”‚   â”‚ä¼˜å…ˆçº§â”‚   â”‚å‘é‡ â”‚      â”‚
â”‚              â”‚æ£€æµ‹ â”‚   â”‚ä»²è£ â”‚   â”‚è·³è½¬ â”‚ â†’ CPU â”‚
â”‚              â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                   â†‘         â†‘         â†‘        â”‚
â”‚              ä¸­æ–­ä½¿èƒ½    ä¼˜å…ˆçº§è®¾ç½®  ä¸­æ–­å‘é‡è¡¨   â”‚
â”‚                                                 â”‚
â”‚  å†…éƒ¨ä¸­æ–­æº â†’ â”Œâ”€â”€â”€â”€â”€â”                          â”‚
â”‚  (å®šæ—¶å™¨ç­‰)   â”‚NVIC â”‚                          â”‚
â”‚              â”‚æ§åˆ¶å™¨â”‚                          â”‚
â”‚              â””â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                 â”‚
â”‚  ç³»ç»Ÿå¼‚å¸¸ â†’ SysTickã€PendSVã€SVCç­‰             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¸­æ–­ä¼˜å…ˆçº§æœºåˆ¶

STM32F407ä½¿ç”¨4ä½ä¼˜å…ˆçº§ï¼Œå¯é…ç½®ä¸ºï¼š

| é…ç½® | æŠ¢å ä¼˜å…ˆçº§ä½æ•° | å­ä¼˜å…ˆçº§ä½æ•° | æŠ¢å çº§åˆ«æ•° | å­çº§åˆ«æ•° |
|------|----------------|--------------|------------|----------|
| **NVIC_PRIORITYGROUP_0** | 0ä½ | 4ä½ | 1 | 16 |
| **NVIC_PRIORITYGROUP_1** | 1ä½ | 3ä½ | 2 | 8 |
| **NVIC_PRIORITYGROUP_2** | 2ä½ | 2ä½ | 4 | 4 |
| **NVIC_PRIORITYGROUP_3** | 3ä½ | 1ä½ | 8 | 2 |
| **NVIC_PRIORITYGROUP_4** | 4ä½ | 0ä½ | 16 | 1 |

```c
// ä¼˜å…ˆçº§åˆ†ç»„é…ç½®
void NVIC_Config(void)
{
    // è®¾ç½®ä¼˜å…ˆçº§åˆ†ç»„ (2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å­ä¼˜å…ˆçº§)
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    
    /*
    ä¼˜å…ˆçº§è®¡ç®—å…¬å¼ï¼š
    æŠ¢å ä¼˜å…ˆçº§ = (ä¼˜å…ˆçº§å€¼ >> å­ä¼˜å…ˆçº§ä½æ•°) & æŠ¢å ä¼˜å…ˆçº§æ©ç 
    å­ä¼˜å…ˆçº§ = ä¼˜å…ˆçº§å€¼ & å­ä¼˜å…ˆçº§æ©ç 
    
    ä¾‹å¦‚ï¼šä¼˜å…ˆçº§åˆ†ç»„2ï¼Œä¼˜å…ˆçº§å€¼ä¸º0x05 (0101)
    æŠ¢å ä¼˜å…ˆçº§ = (5 >> 2) & 0x3 = 1
    å­ä¼˜å…ˆçº§ = 5 & 0x3 = 1
    */
}
```

## âš¡ å¤–éƒ¨ä¸­æ–­é…ç½®

### GPIOå¤–éƒ¨ä¸­æ–­

```c
// GPIOå¤–éƒ¨ä¸­æ–­é…ç½®ç»“æ„ä½“
typedef struct
{
    GPIO_TypeDef* port;
    uint16_t pin;
    IRQn_Type irq;
    uint8_t preempt_priority;
    uint8_t sub_priority;
    GPIO_PinState trigger_level;
} EXTI_Config_t;

// å¤–éƒ¨ä¸­æ–­é…ç½®æ•°ç»„
EXTI_Config_t exti_configs[] = {
    {GPIOA, GPIO_PIN_0, EXTI0_IRQn, 1, 0, GPIO_PIN_RESET},      // æŒ‰é”®1
    {GPIOA, GPIO_PIN_1, EXTI1_IRQn, 1, 1, GPIO_PIN_RESET},      // æŒ‰é”®2  
    {GPIOA, GPIO_PIN_2, EXTI2_IRQn, 2, 0, GPIO_PIN_SET},        // ä¼ æ„Ÿå™¨
    {GPIOA, GPIO_PIN_3, EXTI3_IRQn, 2, 1, GPIO_PIN_RESET},      // é™ä½å¼€å…³
};

#define EXTI_COUNT (sizeof(exti_configs)/sizeof(exti_configs[0]))

// å¤–éƒ¨ä¸­æ–­åˆå§‹åŒ–
void EXTI_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    // ä½¿èƒ½GPIOæ—¶é’Ÿ
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    // è®¾ç½®ä¼˜å…ˆçº§åˆ†ç»„
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    
    for(int i = 0; i < EXTI_COUNT; i++)
    {
        // GPIOé…ç½®
        GPIO_InitStruct.Pin = exti_configs[i].pin;
        GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  // ä¸‹é™æ²¿è§¦å‘
        
        if(exti_configs[i].trigger_level == GPIO_PIN_RESET)
        {
            GPIO_InitStruct.Pull = GPIO_PULLUP;       // æŒ‰é”®ç±»è¾“å…¥ï¼Œå†…éƒ¨ä¸Šæ‹‰
        }
        else
        {
            GPIO_InitStruct.Pull = GPIO_PULLDOWN;     // ä¼ æ„Ÿå™¨ç±»è¾“å…¥ï¼Œå†…éƒ¨ä¸‹æ‹‰
            GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; // ä¸Šå‡æ²¿è§¦å‘
        }
        
        HAL_GPIO_Init(exti_configs[i].port, &GPIO_InitStruct);
        
        // NVICé…ç½®
        HAL_NVIC_SetPriority(exti_configs[i].irq, 
                           exti_configs[i].preempt_priority, 
                           exti_configs[i].sub_priority);
        HAL_NVIC_EnableIRQ(exti_configs[i].irq);
    }
}

// å¤–éƒ¨ä¸­æ–­å›è°ƒå‡½æ•°
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    static uint32_t last_interrupt_time[16] = {0};
    uint32_t current_time = HAL_GetTick();
    uint8_t pin_index = 0;
    
    // è·å–å¼•è„šç´¢å¼•
    uint16_t temp_pin = GPIO_Pin;
    while(temp_pin >>= 1) pin_index++;
    
    // è½¯ä»¶æ¶ˆæŠ– (50ms)
    if(current_time - last_interrupt_time[pin_index] < 50)
    {
        return;
    }
    last_interrupt_time[pin_index] = current_time;
    
    switch(GPIO_Pin)
    {
        case GPIO_PIN_0:  // æŒ‰é”®1
            printf("Button 1 Pressed\r\n");
            HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);  // LEDåˆ‡æ¢
            break;
            
        case GPIO_PIN_1:  // æŒ‰é”®2
            printf("Button 2 Pressed\r\n");
            // è§¦å‘ç‰¹å®šåŠŸèƒ½
            break;
            
        case GPIO_PIN_2:  // ä¼ æ„Ÿå™¨
            printf("Sensor Triggered\r\n");
            // ä¼ æ„Ÿå™¨å¤„ç†é€»è¾‘
            break;
            
        case GPIO_PIN_3:  // é™ä½å¼€å…³
            printf("Limit Switch Activated\r\n");
            // ç´§æ€¥åœæ­¢é€»è¾‘
            Motor_Emergency_Stop();
            break;
            
        default:
            break;
    }
}

// å¤–éƒ¨ä¸­æ–­æœåŠ¡å‡½æ•°
void EXTI0_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
}

void EXTI1_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
}

void EXTI2_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);
}

void EXTI3_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
}
```

### å¤šæŒ‰é”®ä¸­æ–­ç®¡ç†

```c
// æŒ‰é”®çŠ¶æ€ç®¡ç†ç»“æ„ä½“
typedef struct
{
    GPIO_TypeDef* port;
    uint16_t pin;
    uint8_t state;               // å½“å‰çŠ¶æ€
    uint8_t last_state;          // ä¸Šä¸€æ¬¡çŠ¶æ€
    uint32_t press_time;         // æŒ‰ä¸‹æ—¶é—´
    uint32_t release_time;       // é‡Šæ”¾æ—¶é—´
    uint8_t click_count;         // ç‚¹å‡»æ¬¡æ•°
    uint32_t last_click_time;    // ä¸Šæ¬¡ç‚¹å‡»æ—¶é—´
} Button_t;

// æŒ‰é”®äº‹ä»¶ç±»å‹
typedef enum
{
    BUTTON_EVENT_NONE = 0,
    BUTTON_EVENT_PRESS,          // æŒ‰ä¸‹
    BUTTON_EVENT_RELEASE,        // é‡Šæ”¾
    BUTTON_EVENT_CLICK,          // å•å‡»
    BUTTON_EVENT_DOUBLE_CLICK,   // åŒå‡»
    BUTTON_EVENT_LONG_PRESS,     // é•¿æŒ‰
    BUTTON_EVENT_VERY_LONG_PRESS // è¶…é•¿æŒ‰
} Button_Event_t;

// æŒ‰é”®ç®¡ç†æ•°ç»„
Button_t buttons[] = {
    {GPIOA, GPIO_PIN_0, 1, 1, 0, 0, 0, 0},  // æŒ‰é”®1
    {GPIOA, GPIO_PIN_1, 1, 1, 0, 0, 0, 0},  // æŒ‰é”®2
    {GPIOA, GPIO_PIN_2, 1, 1, 0, 0, 0, 0},  // æŒ‰é”®3
    {GPIOA, GPIO_PIN_3, 1, 1, 0, 0, 0, 0},  // æŒ‰é”®4
};

#define BUTTON_COUNT (sizeof(buttons)/sizeof(buttons[0]))

// æŒ‰é”®æ‰«æä»»åŠ¡ (åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­è°ƒç”¨ï¼Œ10msé—´éš”)
void Button_Scan_Task(void)
{
    uint32_t current_time = HAL_GetTick();
    
    for(int i = 0; i < BUTTON_COUNT; i++)
    {
        buttons[i].last_state = buttons[i].state;
        buttons[i].state = HAL_GPIO_ReadPin(buttons[i].port, buttons[i].pin);
        
        // æ£€æµ‹æŒ‰ä¸‹äº‹ä»¶
        if(buttons[i].last_state == 1 && buttons[i].state == 0)
        {
            buttons[i].press_time = current_time;
            Button_Event_Handler(i, BUTTON_EVENT_PRESS);
        }
        
        // æ£€æµ‹é‡Šæ”¾äº‹ä»¶
        if(buttons[i].last_state == 0 && buttons[i].state == 1)
        {
            buttons[i].release_time = current_time;
            uint32_t press_duration = current_time - buttons[i].press_time;
            
            Button_Event_Handler(i, BUTTON_EVENT_RELEASE);
            
            // åˆ¤æ–­ç‚¹å‡»ç±»å‹
            if(press_duration < 100)  // çŸ­æŒ‰ (<100ms)
            {
                // æ£€æµ‹åŒå‡»
                if(current_time - buttons[i].last_click_time < 500)
                {
                    buttons[i].click_count++;
                    if(buttons[i].click_count >= 2)
                    {
                        Button_Event_Handler(i, BUTTON_EVENT_DOUBLE_CLICK);
                        buttons[i].click_count = 0;
                    }
                }
                else
                {
                    buttons[i].click_count = 1;
                }
                buttons[i].last_click_time = current_time;
            }
            else if(press_duration < 2000)  // é•¿æŒ‰ (100ms-2s)
            {
                Button_Event_Handler(i, BUTTON_EVENT_LONG_PRESS);
            }
            else  // è¶…é•¿æŒ‰ (>2s)
            {
                Button_Event_Handler(i, BUTTON_EVENT_VERY_LONG_PRESS);
            }
        }
        
        // æ£€æµ‹å•å‡» (å»¶æ—¶ç¡®è®¤)
        if(buttons[i].click_count == 1 && 
           current_time - buttons[i].last_click_time > 500)
        {
            Button_Event_Handler(i, BUTTON_EVENT_CLICK);
            buttons[i].click_count = 0;
        }
    }
}

// æŒ‰é”®äº‹ä»¶å¤„ç†å‡½æ•°
void Button_Event_Handler(uint8_t button_id, Button_Event_t event)
{
    switch(button_id)
    {
        case 0:  // æŒ‰é”®1
            switch(event)
            {
                case BUTTON_EVENT_CLICK:
                    printf("Button 1 Click\r\n");
                    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
                    break;
                case BUTTON_EVENT_DOUBLE_CLICK:
                    printf("Button 1 Double Click\r\n");
                    // æ¨¡å¼åˆ‡æ¢
                    break;
                case BUTTON_EVENT_LONG_PRESS:
                    printf("Button 1 Long Press\r\n");
                    // è¿›å…¥è®¾ç½®æ¨¡å¼
                    break;
                default:
                    break;
            }
            break;
            
        case 1:  // æŒ‰é”®2
            // ç±»ä¼¼å¤„ç†...
            break;
            
        default:
            break;
    }
}
```

## ğŸ•’ å®šæ—¶å™¨ä¸­æ–­åº”ç”¨

### ç³»ç»Ÿæ—¶åŸºä¸­æ–­

```c
// ç³»ç»Ÿä»»åŠ¡ç®¡ç†ç»“æ„ä½“
typedef struct
{
    void (*task_func)(void);     // ä»»åŠ¡å‡½æ•°æŒ‡é’ˆ
    uint32_t period;             // æ‰§è¡Œå‘¨æœŸ(ms)
    uint32_t last_run;           // ä¸Šæ¬¡è¿è¡Œæ—¶é—´
    uint8_t enable;              // ä»»åŠ¡ä½¿èƒ½
    uint32_t run_count;          // è¿è¡Œæ¬¡æ•°
    uint32_t max_exec_time;      // æœ€å¤§æ‰§è¡Œæ—¶é—´
} System_Task_t;

// ç³»ç»Ÿä»»åŠ¡åˆ—è¡¨
System_Task_t system_tasks[] = {
    {LED_Blink_Task,        1000, 0, 1, 0, 0},    // LEDé—ªçƒ 1s
    {Button_Scan_Task,      10,   0, 1, 0, 0},    // æŒ‰é”®æ‰«æ 10ms
    {Sensor_Read_Task,      100,  0, 1, 0, 0},    // ä¼ æ„Ÿå™¨è¯»å– 100ms
    {Data_Process_Task,     50,   0, 1, 0, 0},    // æ•°æ®å¤„ç† 50ms
    {Communication_Task,    20,   0, 1, 0, 0},    // é€šä¿¡å¤„ç† 20ms
};

#define TASK_COUNT (sizeof(system_tasks)/sizeof(system_tasks[0]))

// ç³»ç»Ÿå®šæ—¶å™¨åˆå§‹åŒ– (1msæ—¶åŸº)
void System_Timer_Init(void)
{
    TIM_HandleTypeDef htim7;
    
    __HAL_RCC_TIM7_CLK_ENABLE();
    
    // 1mså®šæ—¶å™¨é…ç½®
    htim7.Instance = TIM7;
    htim7.Init.Prescaler = 83;                    // 84MHz/84 = 1MHz
    htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim7.Init.Period = 999;                      // 1MHz/1000 = 1kHz (1ms)
    htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
    {
        Error_Handler();
    }
    
    // é…ç½®ä¸­æ–­
    HAL_NVIC_SetPriority(TIM7_IRQn, 0, 0);       // æœ€é«˜ä¼˜å…ˆçº§
    HAL_NVIC_EnableIRQ(TIM7_IRQn);
    
    // å¯åŠ¨å®šæ—¶å™¨ä¸­æ–­
    HAL_TIM_Base_Start_IT(&htim7);
}

// ä»»åŠ¡è°ƒåº¦å™¨ (åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­è°ƒç”¨)
void Task_Scheduler(void)
{
    uint32_t current_time = HAL_GetTick();
    
    for(int i = 0; i < TASK_COUNT; i++)
    {
        if(system_tasks[i].enable && 
           (current_time - system_tasks[i].last_run >= system_tasks[i].period))
        {
            uint32_t start_time = HAL_GetTick();
            
            // æ‰§è¡Œä»»åŠ¡
            system_tasks[i].task_func();
            
            uint32_t exec_time = HAL_GetTick() - start_time;
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            system_tasks[i].last_run = current_time;
            system_tasks[i].run_count++;
            
            if(exec_time > system_tasks[i].max_exec_time)
            {
                system_tasks[i].max_exec_time = exec_time;
            }
            
            // æ£€æŸ¥ä»»åŠ¡è¶…æ—¶
            if(exec_time > system_tasks[i].period / 2)
            {
                printf("Warning: Task %d execution time too long: %dms\r\n", i, exec_time);
            }
        }
    }
}

// å®šæ—¶å™¨ä¸­æ–­å›è°ƒ
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM7)
    {
        // ç³»ç»Ÿä»»åŠ¡è°ƒåº¦
        Task_Scheduler();
        
        // ç³»ç»Ÿå¿ƒè·³è®¡æ•°
        static uint32_t heartbeat = 0;
        heartbeat++;
        
        if(heartbeat >= 1000)  // æ¯ç§’
        {
            printf("System Heartbeat: %d\r\n", heartbeat/1000);
            heartbeat = 0;
        }
    }
}

// å®šæ—¶å™¨ä¸­æ–­æœåŠ¡å‡½æ•°
void TIM7_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&htim7);
}
```

### ç²¾ç¡®å»¶æ—¶ä¸­æ–­

```c
// ç²¾ç¡®å»¶æ—¶ç»“æ„ä½“
typedef struct
{
    uint32_t delay_time;         // å»¶æ—¶æ—¶é—´(us)
    void (*callback)(void);      // å›è°ƒå‡½æ•°
    uint8_t active;              // æ¿€æ´»çŠ¶æ€
    uint8_t repeat;              // é‡å¤æ ‡å¿—
} Precise_Delay_t;

Precise_Delay_t precise_delays[8];  // æ”¯æŒ8ä¸ªç²¾ç¡®å»¶æ—¶

// ç²¾ç¡®å»¶æ—¶å®šæ—¶å™¨åˆå§‹åŒ– (1usåˆ†è¾¨ç‡)
void Precise_Delay_Init(void)
{
    TIM_HandleTypeDef htim5;
    
    __HAL_RCC_TIM5_CLK_ENABLE();
    
    // 1uså®šæ—¶å™¨é…ç½®
    htim5.Instance = TIM5;
    htim5.Init.Prescaler = 83;                    // 84MHz/84 = 1MHz
    htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim5.Init.Period = 0xFFFFFFFF;               // 32ä½æœ€å¤§å€¼
    htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
    {
        Error_Handler();
    }
    
    // é…ç½®ä¸­æ–­
    HAL_NVIC_SetPriority(TIM5_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
    
    // å¯åŠ¨å®šæ—¶å™¨
    HAL_TIM_Base_Start(&htim5);
    
    // åˆå§‹åŒ–å»¶æ—¶æ•°ç»„
    memset(precise_delays, 0, sizeof(precise_delays));
}

// è®¾ç½®ç²¾ç¡®å»¶æ—¶
uint8_t Set_Precise_Delay(uint32_t delay_us, void (*callback)(void), uint8_t repeat)
{
    for(int i = 0; i < 8; i++)
    {
        if(!precise_delays[i].active)
        {
            precise_delays[i].delay_time = __HAL_TIM_GET_COUNTER(&htim5) + delay_us;
            precise_delays[i].callback = callback;
            precise_delays[i].active = 1;
            precise_delays[i].repeat = repeat;
            
            // é…ç½®æ¯”è¾ƒä¸­æ–­
            __HAL_TIM_SET_COMPARE(&htim5, TIM_CHANNEL_1 + i, precise_delays[i].delay_time);
            __HAL_TIM_ENABLE_IT(&htim5, TIM_IT_CC1 << i);
            
            return i;  // è¿”å›å»¶æ—¶ID
        }
    }
    return 0xFF;  // æ— å¯ç”¨å»¶æ—¶æ§½
}

// å–æ¶ˆç²¾ç¡®å»¶æ—¶
void Cancel_Precise_Delay(uint8_t delay_id)
{
    if(delay_id < 8)
    {
        precise_delays[delay_id].active = 0;
        __HAL_TIM_DISABLE_IT(&htim5, TIM_IT_CC1 << delay_id);
    }
}

// ç²¾ç¡®å»¶æ—¶ä¸­æ–­å¤„ç†
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM5)
    {
        for(int i = 0; i < 8; i++)
        {
            if(precise_delays[i].active && 
               __HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1 << i))
            {
                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1 << i);
                
                // æ‰§è¡Œå›è°ƒå‡½æ•°
                if(precise_delays[i].callback)
                {
                    precise_delays[i].callback();
                }
                
                // æ£€æŸ¥æ˜¯å¦é‡å¤
                if(precise_delays[i].repeat)
                {
                    // é‡æ–°è®¾ç½®ä¸‹æ¬¡è§¦å‘æ—¶é—´
                    precise_delays[i].delay_time = __HAL_TIM_GET_COUNTER(htim) + 
                                                  precise_delays[i].delay_time;
                    __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_1 + i, 
                                         precise_delays[i].delay_time);
                }
                else
                {
                    precise_delays[i].active = 0;
                    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1 << i);
                }
            }
        }
    }
}
```

## ğŸš€ ä¸²å£ä¸­æ–­åº”ç”¨

### DMA+ä¸­æ–­æ¥æ”¶

```c
// ä¸²å£æ¥æ”¶ç¼“å†²åŒºç®¡ç†
#define UART_RX_BUFFER_SIZE 256
#define UART_RX_DMA_SIZE    64

typedef struct
{
    uint8_t rx_buffer[UART_RX_BUFFER_SIZE];  // æ¥æ”¶ç¯å½¢ç¼“å†²åŒº
    uint8_t dma_buffer[UART_RX_DMA_SIZE];    // DMAæ¥æ”¶ç¼“å†²åŒº
    uint16_t write_index;                    // å†™å…¥ç´¢å¼•
    uint16_t read_index;                     // è¯»å–ç´¢å¼•
    uint16_t data_count;                     // æ•°æ®è®¡æ•°
    uint8_t overflow_flag;                   // æº¢å‡ºæ ‡å¿—
} UART_RxBuffer_t;

UART_RxBuffer_t uart_rx;
UART_HandleTypeDef huart1;

// ä¸²å£DMAåˆå§‹åŒ–
void UART_DMA_Init(void)
{
    // GPIOé…ç½® (PA9-TX, PA10-RX)
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_USART1_CLK_ENABLE();
    __HAL_RCC_DMA2_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // UARTé…ç½®
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    
    if (HAL_UART_Init(&huart1) != HAL_OK)
    {
        Error_Handler();
    }
    
    // DMAé…ç½®
    DMA_HandleTypeDef hdma_usart1_rx;
    
    hdma_usart1_rx.Instance = DMA2_Stream5;
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_HIGH;
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
    {
        Error_Handler();
    }
    
    __HAL_LINKDMA(&huart1, hdmarx, hdma_usart1_rx);
    
    // ä¸­æ–­é…ç½®
    HAL_NVIC_SetPriority(USART1_IRQn, 2, 0);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
    
    HAL_NVIC_SetPriority(DMA2_Stream5_IRQn, 2, 1);
    HAL_NVIC_EnableIRQ(DMA2_Stream5_IRQn);
    
    // å¯åŠ¨DMAæ¥æ”¶
    HAL_UART_Receive_DMA(&huart1, uart_rx.dma_buffer, UART_RX_DMA_SIZE);
    
    // ä½¿èƒ½ç©ºé—²ä¸­æ–­
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
    
    // åˆå§‹åŒ–ç¼“å†²åŒº
    memset(&uart_rx, 0, sizeof(uart_rx));
}

// ç©ºé—²ä¸­æ–­å¤„ç† (ä¸€å¸§æ•°æ®æ¥æ”¶å®Œæˆ)
void UART_IDLE_IRQHandler(void)
{
    if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))
    {
        __HAL_UART_CLEAR_IDLEFLAG(&huart1);
        
        // è®¡ç®—æ¥æ”¶åˆ°çš„æ•°æ®é•¿åº¦
        uint16_t dma_count = UART_RX_DMA_SIZE - __HAL_DMA_GET_COUNTER(huart1.hdmarx);
        
        if(dma_count > 0)
        {
            // å°†DMAç¼“å†²åŒºæ•°æ®å¤åˆ¶åˆ°ç¯å½¢ç¼“å†²åŒº
            for(uint16_t i = 0; i < dma_count; i++)
            {
                uart_rx.rx_buffer[uart_rx.write_index] = uart_rx.dma_buffer[i];
                uart_rx.write_index = (uart_rx.write_index + 1) % UART_RX_BUFFER_SIZE;
                
                if(uart_rx.data_count < UART_RX_BUFFER_SIZE)
                {
                    uart_rx.data_count++;
                }
                else
                {
                    uart_rx.overflow_flag = 1;  // ç¼“å†²åŒºæº¢å‡º
                    uart_rx.read_index = (uart_rx.read_index + 1) % UART_RX_BUFFER_SIZE;
                }
            }
            
            // æ•°æ®å¤„ç†
            UART_Data_Process();
        }
        
        // é‡æ–°å¯åŠ¨DMAæ¥æ”¶
        HAL_UART_DMAStop(&huart1);
        HAL_UART_Receive_DMA(&huart1, uart_rx.dma_buffer, UART_RX_DMA_SIZE);
    }
}

// è¯»å–æ¥æ”¶ç¼“å†²åŒºæ•°æ®
uint16_t UART_Read_Buffer(uint8_t* data, uint16_t max_len)
{
    uint16_t read_count = 0;
    
    while(uart_rx.data_count > 0 && read_count < max_len)
    {
        data[read_count] = uart_rx.rx_buffer[uart_rx.read_index];
        uart_rx.read_index = (uart_rx.read_index + 1) % UART_RX_BUFFER_SIZE;
        uart_rx.data_count--;
        read_count++;
    }
    
    return read_count;
}

// ä¸²å£ä¸­æ–­æœåŠ¡å‡½æ•°
void USART1_IRQHandler(void)
{
    if(__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))
    {
        UART_IDLE_IRQHandler();
    }
    
    HAL_UART_IRQHandler(&huart1);
}

void DMA2_Stream5_IRQHandler(void)
{
    HAL_DMA_IRQHandler(&hdma_usart1_rx);
}
```

## ğŸ”§ ä¸­æ–­è°ƒè¯•ä¸ä¼˜åŒ–

### ä¸­æ–­æ€§èƒ½ç›‘æµ‹

```c
// ä¸­æ–­æ€§èƒ½ç»Ÿè®¡ç»“æ„ä½“
typedef struct
{
    IRQn_Type irq_num;
    uint32_t count;              // ä¸­æ–­æ¬¡æ•°
    uint32_t total_time;         // æ€»æ‰§è¡Œæ—¶é—´
    uint32_t max_time;           // æœ€é•¿æ‰§è¡Œæ—¶é—´
    uint32_t last_enter_time;    // ä¸Šæ¬¡è¿›å…¥æ—¶é—´
    uint8_t active;              // æ˜¯å¦æ­£åœ¨æ‰§è¡Œ
} IRQ_Stats_t;

IRQ_Stats_t irq_stats[16];  // ç›‘æµ‹16ä¸ªä¸­æ–­

// ä¸­æ–­æ€§èƒ½ç›‘æµ‹åˆå§‹åŒ–
void IRQ_Monitor_Init(void)
{
    memset(irq_stats, 0, sizeof(irq_stats));
    
    // æ³¨å†Œéœ€è¦ç›‘æµ‹çš„ä¸­æ–­
    irq_stats[0].irq_num = EXTI0_IRQn;
    irq_stats[1].irq_num = TIM7_IRQn;
    irq_stats[2].irq_num = USART1_IRQn;
    // ... æ·»åŠ æ›´å¤šä¸­æ–­
}

// ä¸­æ–­è¿›å…¥è®°å½•
void IRQ_Enter_Record(IRQn_Type irq)
{
    for(int i = 0; i < 16; i++)
    {
        if(irq_stats[i].irq_num == irq)
        {
            irq_stats[i].last_enter_time = HAL_GetTick();
            irq_stats[i].active = 1;
            irq_stats[i].count++;
            break;
        }
    }
}

// ä¸­æ–­é€€å‡ºè®°å½•
void IRQ_Exit_Record(IRQn_Type irq)
{
    for(int i = 0; i < 16; i++)
    {
        if(irq_stats[i].irq_num == irq && irq_stats[i].active)
        {
            uint32_t exec_time = HAL_GetTick() - irq_stats[i].last_enter_time;
            irq_stats[i].total_time += exec_time;
            
            if(exec_time > irq_stats[i].max_time)
            {
                irq_stats[i].max_time = exec_time;
            }
            
            irq_stats[i].active = 0;
            break;
        }
    }
}

// ä¸­æ–­ç»Ÿè®¡æŠ¥å‘Š
void IRQ_Stats_Report(void)
{
    printf("Interrupt Statistics:\r\n");
    printf("IRQ\tCount\tTotal(ms)\tMax(ms)\tAvg(ms)\r\n");
    
    for(int i = 0; i < 16; i++)
    {
        if(irq_stats[i].count > 0)
        {
            uint32_t avg_time = irq_stats[i].total_time / irq_stats[i].count;
            printf("%d\t%d\t%d\t\t%d\t%d\r\n",
                   irq_stats[i].irq_num,
                   irq_stats[i].count,
                   irq_stats[i].total_time,
                   irq_stats[i].max_time,
                   avg_time);
        }
    }
}

// åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­ä½¿ç”¨
void EXTI0_IRQHandler(void)
{
    IRQ_Enter_Record(EXTI0_IRQn);
    
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
    
    IRQ_Exit_Record(EXTI0_IRQn);
}
```

### ä¸­æ–­ä¼˜å…ˆçº§ä¼˜åŒ–

```c
// ä¸­æ–­ä¼˜å…ˆçº§é…ç½®å»ºè®®
void Optimal_IRQ_Priority_Config(void)
{
    // è®¾ç½®ä¼˜å…ˆçº§åˆ†ç»„
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
    
    // ç³»ç»Ÿå…³é”®ä¸­æ–­ (æŠ¢å ä¼˜å…ˆçº§0)
    HAL_NVIC_SetPriority(HardFault_IRQn, 0, 0);
    HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
    HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
    HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
    
    // å®æ—¶æ€§è¦æ±‚é«˜çš„ä¸­æ–­ (æŠ¢å ä¼˜å…ˆçº§1)
    HAL_NVIC_SetPriority(TIM7_IRQn, 1, 0);          // ç³»ç»Ÿæ—¶åŸº
    HAL_NVIC_SetPriority(DMA2_Stream5_IRQn, 1, 1);  // ä¸²å£DMA
    
    // ä¸€èˆ¬å¤–è®¾ä¸­æ–­ (æŠ¢å ä¼˜å…ˆçº§2)
    HAL_NVIC_SetPriority(USART1_IRQn, 2, 0);        // ä¸²å£
    HAL_NVIC_SetPriority(TIM3_IRQn, 2, 1);          // é€šç”¨å®šæ—¶å™¨
    HAL_NVIC_SetPriority(ADC_IRQn, 2, 2);           // ADC
    
    // ç”¨æˆ·è¾“å…¥ä¸­æ–­ (æŠ¢å ä¼˜å…ˆçº§3)
    HAL_NVIC_SetPriority(EXTI0_IRQn, 3, 0);         // æŒ‰é”®
    HAL_NVIC_SetPriority(EXTI1_IRQn, 3, 1);
    HAL_NVIC_SetPriority(EXTI2_IRQn, 3, 2);
    HAL_NVIC_SetPriority(EXTI3_IRQn, 3, 3);
}
```

## ğŸ’¡ ä¸­æ–­ä½¿ç”¨å»ºè®®

### ä¸­æ–­è®¾è®¡åŸåˆ™

**å¿«è¿›å¿«å‡º**ï¼š
```c
// å¥½çš„ä¸­æ–­å¤„ç†æ–¹å¼
void TIMx_IRQHandler(void)
{
    if(__HAL_TIM_GET_FLAG(&htimx, TIM_FLAG_UPDATE))
    {
        __HAL_TIM_CLEAR_FLAG(&htimx, TIM_FLAG_UPDATE);
        
        // è®¾ç½®æ ‡å¿—ä½
        task_flag = 1;
        
        // ç®€å•è®¡æ•°
        timer_count++;
    }
}

// åœ¨ä¸»å¾ªç¯ä¸­å¤„ç†å¤æ‚é€»è¾‘
void main_loop(void)
{
    if(task_flag)
    {
        task_flag = 0;
        // å¤æ‚çš„æ•°æ®å¤„ç†
        Process_Complex_Data();
    }
}
```

**é¿å…é•¿æ—¶é—´æ“ä½œ**ï¼š
```c
// é¿å…åœ¨ä¸­æ–­ä¸­è¿›è¡Œçš„æ“ä½œ
void Bad_IRQ_Handler(void)
{
    // âŒ é¿å…é•¿å»¶æ—¶
    HAL_Delay(100);
    
    // âŒ é¿å…å¤æ‚è®¡ç®—
    float result = complex_calculation();
    
    // âŒ é¿å…ä¸²å£æ‰“å°
    printf("Interrupt occurred\r\n");
    
    // âŒ é¿å…åŠ¨æ€å†…å­˜åˆ†é…
    char* buffer = malloc(256);
}
```

### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

**ä½¿ç”¨ä¸´ç•ŒåŒºä¿æŠ¤**ï¼š
```c
// ä¸´ç•ŒåŒºä¿æŠ¤ç¤ºä¾‹
void Critical_Section_Example(void)
{
    uint32_t primask;
    
    // è¿›å…¥ä¸´ç•ŒåŒº
    primask = __get_PRIMASK();
    __disable_irq();
    
    // å…³é”®ä»£ç æ®µ
    shared_variable++;
    
    // é€€å‡ºä¸´ç•ŒåŒº
    __set_PRIMASK(primask);
}
```

**ä¸­æ–­åµŒå¥—æ§åˆ¶**ï¼š
```c
// æ§åˆ¶ä¸­æ–­åµŒå¥—æ·±åº¦
void Nested_IRQ_Control(void)
{
    // ä¸´æ—¶æé«˜å½“å‰ä¸­æ–­ä¼˜å…ˆçº§
    uint32_t basepri = __get_BASEPRI();
    __set_BASEPRI(0x40);  // å±è”½ä¼˜å…ˆçº§ä½äº4çš„ä¸­æ–­
    
    // å…³é”®ä»£ç 
    Critical_Process();
    
    // æ¢å¤åŸä¼˜å…ˆçº§
    __set_BASEPRI(basepri);
}
```

---

> **ä¸­æ–­æ€»ç»“**ï¼šä¸­æ–­ç³»ç»Ÿæ˜¯å®æ—¶åµŒå…¥å¼ç³»ç»Ÿçš„æ ¸å¿ƒã€‚æ­£ç¡®è®¾è®¡ä¸­æ–­ä¼˜å…ˆçº§ã€éµå¾ªå¿«è¿›å¿«å‡ºåŸåˆ™ã€åˆç†ä½¿ç”¨ä¸­æ–­åµŒå¥—ï¼Œæ˜¯æ„å»ºç¨³å®šé«˜æ•ˆç³»ç»Ÿçš„å…³é”®ã€‚é€šè¿‡æ€§èƒ½ç›‘æµ‹å’Œä¼˜åŒ–ï¼Œå¯ä»¥ç¡®ä¿ç³»ç»Ÿçš„å®æ—¶æ€§è¦æ±‚ã€‚

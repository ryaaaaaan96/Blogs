# 定时器基础与应用

## 📋 概述

定时器是STM32最重要的外设之一，具有强大的功能和灵活的配置选项。STM32定时器不仅可以实现精确的时间控制，还能生成PWM信号、输入捕获、输出比较等多种功能。掌握定时器的使用对于嵌入式开发至关重要。

## 🎯 STM32定时器分类

### 定时器类型概览

| 定时器类型 | 数量 | 位数 | 主要功能 | 应用场景 |
|------------|------|------|----------|----------|
| **基本定时器** | TIM6、TIM7 | 16位 | 定时、DAC触发 | 系统时基、定时任务 |
| **通用定时器** | TIM2-5、TIM9-14 | 16/32位 | 全功能定时器 | PWM、输入捕获、编码器 |
| **高级定时器** | TIM1、TIM8 | 16位 | 高级控制功能 | 电机控制、复杂PWM |

### 各类定时器特点

```
┌─────────────────────────────────────────────────┐
│                STM32定时器架构                   │
├─────────────────────────────────────────────────┤
│  基本定时器 (TIM6/7)：                          │
│  ┌─────┐   ┌─────┐   ┌─────┐                   │
│  │预分频│→│计数器│→│自动重装│→ DAC触发           │
│  └─────┘   └─────┘   └─────┘                   │
│                                                 │
│  通用定时器 (TIM2-5)：                          │
│  ┌─────┐   ┌─────┐   ┌─────┐                   │
│  │预分频│→│计数器│→│比较器│→ PWM输出            │
│  └─────┘   └─────┘   └─────┘                   │
│      ↑                   ↓                     │
│  外部时钟              输入捕获                  │
│                                                 │
│  高级定时器 (TIM1/8)：                          │
│  包含通用定时器所有功能 +                       │
│  ┌─────┐   ┌─────┐   ┌─────┐                   │
│  │死区 │   │刹车 │   │重复 │                   │
│  │生成 │   │保护 │   │计数器│                   │
│  └─────┘   └─────┘   └─────┘                   │
└─────────────────────────────────────────────────┘
```

## ⚙️ 定时器基础配置

### 定时器时钟源

```c
// 定时器时钟配置分析
/*
系统时钟: SYSCLK = 168MHz (F407)
AHB时钟:  HCLK = SYSCLK = 168MHz  
APB1时钟: PCLK1 = HCLK/4 = 42MHz   (TIM2-7, TIM12-14)
APB2时钟: PCLK2 = HCLK/2 = 84MHz   (TIM1, TIM8-11)

定时器时钟计算规则:
- 当APBx预分频系数 = 1时，定时器时钟 = PCLKx
- 当APBx预分频系数 > 1时，定时器时钟 = PCLKx × 2

实际时钟频率:
TIM2-7:   84MHz (42MHz × 2)
TIM1,8-11: 168MHz (84MHz × 2)
*/

// 获取定时器时钟频率
uint32_t Get_Timer_Clock(TIM_TypeDef* TIMx)
{
    uint32_t tim_clock = 0;
    
    if(TIMx == TIM1 || TIMx == TIM8 || TIMx == TIM9 || 
       TIMx == TIM10 || TIMx == TIM11)
    {
        // APB2定时器
        tim_clock = 168000000;  // 168MHz
    }
    else
    {
        // APB1定时器  
        tim_clock = 84000000;   // 84MHz
    }
    
    return tim_clock;
}
```

### 基本定时功能

```c
// 基本定时器配置示例
TIM_HandleTypeDef htim6;

// 定时器初始化
void Timer_Basic_Init(uint16_t period_ms)
{
    // 使能时钟
    __HAL_RCC_TIM6_CLK_ENABLE();
    
    // 计算预分频和重装载值
    uint32_t tim_clock = 84000000;      // 84MHz
    uint32_t target_freq = 1000;        // 1kHz (1ms)
    
    htim6.Instance = TIM6;
    htim6.Init.Prescaler = (tim_clock / target_freq) - 1;  // 预分频
    htim6.Init.CounterMode = TIM_COUNTERMODE_UP;           // 向上计数
    htim6.Init.Period = period_ms - 1;                     // 自动重装载值
    htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
    {
        Error_Handler();
    }
}

// 定时器中断配置
void Timer_IT_Config(void)
{
    // 配置NVIC
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
    
    // 启动定时器中断
    HAL_TIM_Base_Start_IT(&htim6);
}

// 定时器中断回调函数
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM6)
    {
        // 定时器中断处理
        static uint32_t count = 0;
        count++;
        
        if(count >= 1000)  // 1秒
        {
            HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);  // LED闪烁
            count = 0;
        }
    }
}

// 定时器中断服务函数
void TIM6_DAC_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&htim6);
}
```

## 🔄 PWM信号生成

### PWM基础原理

```c
/*
PWM参数计算:
PWM频率 = 定时器时钟 / [(预分频值+1) × (重装载值+1)]
占空比 = 比较值 / (重装载值+1) × 100%

示例: 生成1kHz PWM，占空比50%
定时器时钟 = 84MHz
预分频值 = 83 (84MHz/84 = 1MHz)
重装载值 = 999 (1MHz/1000 = 1kHz)
比较值 = 500 (50%占空比)
*/

// PWM配置结构
typedef struct
{
    TIM_HandleTypeDef* htim;     // 定时器句柄
    uint32_t channel;            // PWM通道
    uint16_t frequency;          // PWM频率(Hz)
    uint8_t duty_cycle;          // 占空比(0-100)
} PWM_Config_t;
```

### PWM输出配置

```c
// PWM初始化示例 - TIM3 CH1 (PA6)
TIM_HandleTypeDef htim3;
TIM_OC_InitTypeDef sConfigOC = {0};

void PWM_Init(uint16_t frequency, uint8_t duty_cycle)
{
    // GPIO配置
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_TIM3_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_6;                    // TIM3_CH1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;              // 复用推挽输出
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;           // 复用为TIM3
    
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // 定时器配置
    uint32_t tim_clock = 84000000;                       // 84MHz
    uint16_t prescaler = (tim_clock / (frequency * 1000)) - 1;
    uint16_t period = 999;                               // ARR值
    
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = prescaler;
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = period;
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
    {
        Error_Handler();
    }
    
    // PWM通道配置
    sConfigOC.OCMode = TIM_OCMODE_PWM1;                  // PWM模式1
    sConfigOC.Pulse = (period + 1) * duty_cycle / 100;  // 计算CCR值
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;          // 高电平有效
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    
    if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
    {
        Error_Handler();
    }
    
    // 启动PWM输出
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
}

// 动态调整PWM占空比
void PWM_SetDutyCycle(uint8_t duty_cycle)
{
    if(duty_cycle > 100) duty_cycle = 100;
    
    uint16_t pulse = (htim3.Init.Period + 1) * duty_cycle / 100;
    __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, pulse);
}

// 调整PWM频率
void PWM_SetFrequency(uint16_t frequency)
{
    uint32_t tim_clock = 84000000;
    uint16_t prescaler = (tim_clock / (frequency * 1000)) - 1;
    
    __HAL_TIM_SET_PRESCALER(&htim3, prescaler);
}
```

### 多路PWM控制

```c
// 多路PWM控制结构
typedef struct
{
    TIM_HandleTypeDef* htim;
    uint32_t channel;
    uint8_t duty_cycle;
    uint16_t target_duty;
    uint8_t step;
    uint32_t last_update;
    uint16_t update_period;
} PWM_Channel_t;

// PWM通道数组
PWM_Channel_t pwm_channels[] = {
    {&htim3, TIM_CHANNEL_1, 0, 50, 1, 0, 20},    // 舵机1
    {&htim3, TIM_CHANNEL_2, 0, 75, 1, 0, 30},    // 舵机2
    {&htim3, TIM_CHANNEL_3, 0, 25, 1, 0, 40},    // LED亮度
    {&htim3, TIM_CHANNEL_4, 0, 90, 1, 0, 25},    // 风扇转速
};

#define PWM_CHANNEL_COUNT (sizeof(pwm_channels)/sizeof(pwm_channels[0]))

// PWM渐变效果
void PWM_Gradient_Task(void)
{
    uint32_t current_time = HAL_GetTick();
    
    for(int i = 0; i < PWM_CHANNEL_COUNT; i++)
    {
        if(current_time - pwm_channels[i].last_update >= pwm_channels[i].update_period)
        {
            if(pwm_channels[i].duty_cycle != pwm_channels[i].target_duty)
            {
                if(pwm_channels[i].duty_cycle < pwm_channels[i].target_duty)
                {
                    pwm_channels[i].duty_cycle += pwm_channels[i].step;
                    if(pwm_channels[i].duty_cycle > pwm_channels[i].target_duty)
                        pwm_channels[i].duty_cycle = pwm_channels[i].target_duty;
                }
                else
                {
                    pwm_channels[i].duty_cycle -= pwm_channels[i].step;
                    if(pwm_channels[i].duty_cycle < pwm_channels[i].target_duty)
                        pwm_channels[i].duty_cycle = pwm_channels[i].target_duty;
                }
                
                // 更新PWM输出
                uint16_t pulse = (pwm_channels[i].htim->Init.Period + 1) * 
                                pwm_channels[i].duty_cycle / 100;
                __HAL_TIM_SET_COMPARE(pwm_channels[i].htim, pwm_channels[i].channel, pulse);
            }
            
            pwm_channels[i].last_update = current_time;
        }
    }
}

// 设置PWM目标值
void PWM_SetTarget(uint8_t channel, uint8_t target_duty, uint8_t step, uint16_t period)
{
    if(channel < PWM_CHANNEL_COUNT)
    {
        pwm_channels[channel].target_duty = target_duty;
        pwm_channels[channel].step = step;
        pwm_channels[channel].update_period = period;
    }
}
```

## 📊 输入捕获功能

### 脉宽测量

```c
// 输入捕获配置
TIM_HandleTypeDef htim2;
TIM_IC_InitTypeDef sConfigIC = {0};

// 脉宽测量结构体
typedef struct
{
    uint32_t rising_edge;     // 上升沿时间
    uint32_t falling_edge;    // 下降沿时间
    uint32_t pulse_width;     // 脉宽(us)
    uint32_t period;          // 周期(us)
    uint8_t capture_state;    // 捕获状态
} PulseWidth_t;

PulseWidth_t pulse_data;

// 输入捕获初始化
void InputCapture_Init(void)
{
    // GPIO配置 (PA0 - TIM2_CH1)
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_TIM2_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
    
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // 定时器配置 (1MHz计数频率，1us分辨率)
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 83;                          // 84MHz/84 = 1MHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 0xFFFFFFFF;                     // 32位最大值
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    
    if (HAL_TIM_IC_Init(&htim2) != HAL_OK)
    {
        Error_Handler();
    }
    
    // 输入捕获通道配置
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;   // 上升沿触发
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;         // 直连输入
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;                   // 不分频
    sConfigIC.ICFilter = 0;                                   // 无滤波
    
    if (HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
    {
        Error_Handler();
    }
    
    // 启动输入捕获中断
    HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
    
    // 配置NVIC
    HAL_NVIC_SetPriority(TIM2_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

// 输入捕获中断回调
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM2)
    {
        if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
        {
            uint32_t capture_value = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
            
            if(pulse_data.capture_state == 0)  // 检测到上升沿
            {
                pulse_data.rising_edge = capture_value;
                pulse_data.capture_state = 1;
                
                // 切换到下降沿检测
                __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);
            }
            else  // 检测到下降沿
            {
                pulse_data.falling_edge = capture_value;
                
                // 计算脉宽 (处理计数器溢出)
                if(pulse_data.falling_edge >= pulse_data.rising_edge)
                {
                    pulse_data.pulse_width = pulse_data.falling_edge - pulse_data.rising_edge;
                }
                else
                {
                    pulse_data.pulse_width = (0xFFFFFFFF - pulse_data.rising_edge) + 
                                           pulse_data.falling_edge + 1;
                }
                
                pulse_data.capture_state = 0;
                
                // 切换回上升沿检测
                __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
                
                // 数据处理
                printf("Pulse Width: %d us\r\n", pulse_data.pulse_width);
            }
        }
    }
}

// 定时器中断服务函数
void TIM2_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&htim2);
}
```

### 频率测量

```c
// 频率测量结构体
typedef struct
{
    uint32_t last_capture;    // 上次捕获值
    uint32_t current_capture; // 当前捕获值
    uint32_t period_us;       // 周期(us)
    float frequency;          // 频率(Hz)
    uint8_t first_capture;    // 首次捕获标志
} FreqMeasure_t;

FreqMeasure_t freq_data = {0};

// 频率测量初始化 (测量上升沿间隔)
void FreqMeasure_Init(void)
{
    // 配置与脉宽测量类似，但保持上升沿检测
    InputCapture_Init();
    
    // 只检测上升沿
    TIM_IC_InitTypeDef sConfigIC = {0};
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
    sConfigIC.ICFilter = 0;
    
    HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1);
}

// 频率测量中断回调
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM2 && htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
        freq_data.current_capture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        
        if(freq_data.first_capture == 0)
        {
            freq_data.last_capture = freq_data.current_capture;
            freq_data.first_capture = 1;
        }
        else
        {
            // 计算周期
            if(freq_data.current_capture >= freq_data.last_capture)
            {
                freq_data.period_us = freq_data.current_capture - freq_data.last_capture;
            }
            else
            {
                freq_data.period_us = (0xFFFFFFFF - freq_data.last_capture) + 
                                     freq_data.current_capture + 1;
            }
            
            // 计算频率
            if(freq_data.period_us > 0)
            {
                freq_data.frequency = 1000000.0f / freq_data.period_us;  // Hz
                printf("Frequency: %.2f Hz\r\n", freq_data.frequency);
            }
            
            freq_data.last_capture = freq_data.current_capture;
        }
    }
}
```

## 🎛️ 编码器接口

### 正交编码器

```c
// 编码器配置
TIM_HandleTypeDef htim4;
TIM_Encoder_InitTypeDef sConfig = {0};

// 编码器数据结构
typedef struct
{
    int32_t position;         // 当前位置
    int32_t last_count;       // 上次计数值
    int32_t velocity;         // 速度 (脉冲/秒)
    float angle;              // 角度 (度)
    uint32_t ppr;             // 每转脉冲数
    uint32_t last_time;       // 上次更新时间
} Encoder_t;

Encoder_t encoder = {0};

// 编码器初始化
void Encoder_Init(uint32_t pulses_per_revolution)
{
    // GPIO配置 (PB6-TIM4_CH1, PB7-TIM4_CH2)
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_TIM4_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;                   // 上拉电阻
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    
    // 编码器接口配置
    htim4.Instance = TIM4;
    htim4.Init.Prescaler = 0;                             // 不分频
    htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim4.Init.Period = 0xFFFF;                           // 16位最大值
    htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    
    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;           // 两路编码
    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;          // A相极性
    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC1Filter = 0;
    
    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;          // B相极性  
    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC2Filter = 0;
    
    if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK)
    {
        Error_Handler();
    }
    
    // 启动编码器接口
    HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);
    
    // 初始化编码器参数
    encoder.ppr = pulses_per_revolution;
    encoder.last_count = __HAL_TIM_GET_COUNTER(&htim4);
    encoder.last_time = HAL_GetTick();
}

// 编码器数据更新
void Encoder_Update(void)
{
    uint32_t current_time = HAL_GetTick();
    int32_t current_count = (int32_t)__HAL_TIM_GET_COUNTER(&htim4);
    
    // 计算位置变化 (处理溢出)
    int32_t delta_count = current_count - encoder.last_count;
    
    if(delta_count > 32767)
    {
        delta_count -= 65536;  // 处理向下溢出
    }
    else if(delta_count < -32768)
    {
        delta_count += 65536;  // 处理向上溢出
    }
    
    encoder.position += delta_count;
    
    // 计算速度 (脉冲/秒)
    uint32_t delta_time = current_time - encoder.last_time;
    if(delta_time > 0)
    {
        encoder.velocity = (delta_count * 1000) / delta_time;
    }
    
    // 计算角度
    encoder.angle = (float)encoder.position * 360.0f / encoder.ppr;
    
    // 更新历史值
    encoder.last_count = current_count;
    encoder.last_time = current_time;
}

// 获取编码器数据
int32_t Encoder_GetPosition(void)
{
    return encoder.position;
}

float Encoder_GetAngle(void)
{
    return encoder.angle;
}

int32_t Encoder_GetVelocity(void)
{
    return encoder.velocity;
}

// 编码器清零
void Encoder_Reset(void)
{
    encoder.position = 0;
    encoder.last_count = __HAL_TIM_GET_COUNTER(&htim4);
    __HAL_TIM_SET_COUNTER(&htim4, 0);
}
```

## 🚀 高级应用

### 电机PWM控制

```c
// 直流电机PWM控制
typedef struct
{
    TIM_HandleTypeDef* htim;
    uint32_t pwm_channel;
    GPIO_TypeDef* dir_port;
    uint16_t dir_pin;
    int16_t speed;              // -100 到 +100
    uint8_t enable;
} Motor_t;

Motor_t motor = {
    .htim = &htim3,
    .pwm_channel = TIM_CHANNEL_1,
    .dir_port = GPIOB,
    .dir_pin = GPIO_PIN_0,
    .speed = 0,
    .enable = 0
};

// 电机控制初始化
void Motor_Init(void)
{
    // PWM初始化 (在前面已实现)
    PWM_Init(1000, 0);  // 1kHz PWM, 0%占空比
    
    // 方向控制引脚
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOB_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

// 设置电机速度
void Motor_SetSpeed(int16_t speed)
{
    if(speed > 100) speed = 100;
    if(speed < -100) speed = -100;
    
    motor.speed = speed;
    
    if(!motor.enable)
    {
        PWM_SetDutyCycle(0);
        return;
    }
    
    // 设置方向
    if(speed >= 0)
    {
        HAL_GPIO_WritePin(motor.dir_port, motor.dir_pin, GPIO_PIN_RESET);  // 正转
        PWM_SetDutyCycle(speed);
    }
    else
    {
        HAL_GPIO_WritePin(motor.dir_port, motor.dir_pin, GPIO_PIN_SET);    // 反转
        PWM_SetDutyCycle(-speed);
    }
}

// 电机使能控制
void Motor_Enable(uint8_t enable)
{
    motor.enable = enable;
    
    if(!enable)
    {
        PWM_SetDutyCycle(0);  // 停止输出
    }
    else
    {
        Motor_SetSpeed(motor.speed);  // 恢复输出
    }
}
```

### 舵机控制

```c
// 舵机控制结构体
typedef struct
{
    TIM_HandleTypeDef* htim;
    uint32_t channel;
    uint16_t min_pulse;         // 最小脉宽(us)
    uint16_t max_pulse;         // 最大脉宽(us)
    uint16_t center_pulse;      // 中心脉宽(us)
    float current_angle;        // 当前角度
    float target_angle;         // 目标角度
    uint8_t is_moving;          // 运动状态
} Servo_t;

Servo_t servo = {
    .htim = &htim3,
    .channel = TIM_CHANNEL_2,
    .min_pulse = 500,           // 0.5ms
    .max_pulse = 2500,          // 2.5ms
    .center_pulse = 1500,       // 1.5ms
    .current_angle = 90.0f,     // 初始中心位置
    .target_angle = 90.0f,
    .is_moving = 0
};

// 舵机初始化 (20ms周期, 50Hz)
void Servo_Init(void)
{
    // PWM配置: 50Hz频率
    uint32_t tim_clock = 84000000;
    uint16_t prescaler = 83;                // 1MHz计数频率
    uint16_t period = 19999;                // 20ms周期
    
    htim3.Init.Prescaler = prescaler;
    htim3.Init.Period = period;
    
    // 重新初始化定时器
    HAL_TIM_PWM_Init(&htim3);
    
    // PWM通道配置
    TIM_OC_InitTypeDef sConfigOC = {0};
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = servo.center_pulse;   // 1.5ms脉宽
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    
    HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, servo.channel);
    HAL_TIM_PWM_Start(&htim3, servo.channel);
}

// 角度转换为脉宽
uint16_t Servo_AngleToPulse(float angle)
{
    if(angle < 0) angle = 0;
    if(angle > 180) angle = 180;
    
    // 线性插值计算脉宽
    uint16_t pulse = servo.min_pulse + 
                    (uint16_t)((angle / 180.0f) * (servo.max_pulse - servo.min_pulse));
    
    return pulse;
}

// 设置舵机角度
void Servo_SetAngle(float angle)
{
    servo.target_angle = angle;
    uint16_t pulse = Servo_AngleToPulse(angle);
    
    __HAL_TIM_SET_COMPARE(servo.htim, servo.channel, pulse);
    servo.current_angle = angle;
}

// 舵机平滑运动
void Servo_SmoothMove(float target_angle, float speed)
{
    servo.target_angle = target_angle;
    servo.is_moving = 1;
    
    // 在定时任务中实现平滑运动
}

// 舵机运动任务 (在定时器中断中调用)
void Servo_Task(void)
{
    if(servo.is_moving)
    {
        float angle_diff = servo.target_angle - servo.current_angle;
        
        if(fabs(angle_diff) < 1.0f)  // 到达目标
        {
            servo.current_angle = servo.target_angle;
            servo.is_moving = 0;
        }
        else
        {
            float step = (angle_diff > 0) ? 1.0f : -1.0f;
            servo.current_angle += step;
        }
        
        uint16_t pulse = Servo_AngleToPulse(servo.current_angle);
        __HAL_TIM_SET_COMPARE(servo.htim, servo.channel, pulse);
    }
}
```

## 🔧 定时器调试技巧

### 性能监测

```c
// 定时器性能测试
void Timer_PerformanceTest(void)
{
    uint32_t start_time, end_time;
    
    // 测试PWM更新速度
    start_time = HAL_GetTick();
    
    for(uint32_t i = 0; i < 10000; i++)
    {
        PWM_SetDutyCycle(i % 101);  // 0-100%占空比
    }
    
    end_time = HAL_GetTick();
    printf("PWM Update Test: %d ms for 10000 updates\r\n", end_time - start_time);
    
    // 测试定时器读取速度
    start_time = HAL_GetTick();
    
    uint32_t dummy;
    for(uint32_t i = 0; i < 100000; i++)
    {
        dummy = __HAL_TIM_GET_COUNTER(&htim3);
    }
    
    end_time = HAL_GetTick();
    printf("Timer Read Test: %d ms for 100000 reads\r\n", end_time - start_time);
}

// 定时器状态监控
void Timer_StatusMonitor(TIM_HandleTypeDef* htim)
{
    printf("Timer Status Monitor:\r\n");
    printf("Counter: %d\r\n", __HAL_TIM_GET_COUNTER(htim));
    printf("Period: %d\r\n", htim->Init.Period);
    printf("Prescaler: %d\r\n", htim->Init.Prescaler);
    
    if(htim->Instance == TIM3)
    {
        printf("CCR1: %d\r\n", __HAL_TIM_GET_COMPARE(htim, TIM_CHANNEL_1));
        printf("CCR2: %d\r\n", __HAL_TIM_GET_COMPARE(htim, TIM_CHANNEL_2));
        printf("CCR3: %d\r\n", __HAL_TIM_GET_COMPARE(htim, TIM_CHANNEL_3));
        printf("CCR4: %d\r\n", __HAL_TIM_GET_COMPARE(htim, TIM_CHANNEL_4));
    }
    
    printf("Control Register: 0x%08X\r\n", htim->Instance->CR1);
    printf("Status Register: 0x%08X\r\n", htim->Instance->SR);
    printf("------------------------\r\n");
}
```

### 常见问题排查

```c
// 定时器问题诊断
void Timer_Diagnose(TIM_HandleTypeDef* htim)
{
    printf("Timer Diagnosis:\r\n");
    
    // 检查时钟使能
    if(htim->Instance == TIM1)
    {
        printf("TIM1 Clock: %s\r\n", 
               (__HAL_RCC_TIM1_IS_CLK_ENABLED()) ? "Enabled" : "Disabled");
    }
    else if(htim->Instance == TIM2)
    {
        printf("TIM2 Clock: %s\r\n", 
               (__HAL_RCC_TIM2_IS_CLK_ENABLED()) ? "Enabled" : "Disabled");
    }
    
    // 检查定时器使能
    printf("Timer Enable: %s\r\n", 
           (__HAL_TIM_IS_TIM_COUNTING_DOWN(htim) || 
            (htim->Instance->CR1 & TIM_CR1_CEN)) ? "Yes" : "No");
    
    // 检查中断使能
    printf("Update Interrupt: %s\r\n", 
           (htim->Instance->DIER & TIM_DIER_UIE) ? "Enabled" : "Disabled");
    
    // 检查输出使能 (PWM)
    if(htim->Instance == TIM1 || htim->Instance == TIM8)
    {
        printf("Main Output: %s\r\n", 
               (htim->Instance->BDTR & TIM_BDTR_MOE) ? "Enabled" : "Disabled");
    }
    
    printf("------------------------\r\n");
}
```

## 💡 使用建议

### 定时器选择原则

**基本定时功能**：
- 选择基本定时器 (TIM6/7)
- 占用资源少，配置简单

**PWM输出**：
- 选择通用定时器 (TIM2-5)
- 多通道输出，功能完整

**电机控制**：
- 选择高级定时器 (TIM1/8)
- 支持死区、刹车保护

**编码器接口**：
- 选择通用定时器
- 32位定时器(TIM2/5)更适合高分辨率

### 性能优化技巧

**减少中断开销**：
```c
// 使用DMA代替中断
HAL_TIM_PWM_Start_DMA(&htim3, TIM_CHANNEL_1, pwm_buffer, buffer_size);
```

**批量更新PWM**：
```c
// 同时更新多个通道
__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, value1);
__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, value2);
__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_3, value3);
```

### 调试建议

**使用示波器**：
- 观察PWM波形
- 测量频率和占空比
- 检查信号质量

**逻辑分析仪**：
- 多路信号时序分析
- 编码器信号解码
- 通信协议分析

---

> **定时器总结**：STM32定时器功能强大，应用广泛。掌握基本定时、PWM生成、输入捕获和编码器接口等功能，能够应对大部分嵌入式应用需求。合理选择定时器类型和配置参数，注重性能优化和调试技巧。

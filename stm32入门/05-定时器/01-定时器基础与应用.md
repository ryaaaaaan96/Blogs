# å®šæ—¶å™¨åŸºç¡€ä¸åº”ç”¨

## ğŸ“‹ æ¦‚è¿°

å®šæ—¶å™¨æ˜¯STM32æœ€é‡è¦çš„å¤–è®¾ä¹‹ä¸€ï¼Œå…·æœ‰å¼ºå¤§çš„åŠŸèƒ½å’Œçµæ´»çš„é…ç½®é€‰é¡¹ã€‚STM32å®šæ—¶å™¨ä¸ä»…å¯ä»¥å®ç°ç²¾ç¡®çš„æ—¶é—´æ§åˆ¶ï¼Œè¿˜èƒ½ç”ŸæˆPWMä¿¡å·ã€è¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒç­‰å¤šç§åŠŸèƒ½ã€‚æŒæ¡å®šæ—¶å™¨çš„ä½¿ç”¨å¯¹äºåµŒå…¥å¼å¼€å‘è‡³å…³é‡è¦ã€‚

## ğŸ¯ STM32å®šæ—¶å™¨åˆ†ç±»

### å®šæ—¶å™¨ç±»å‹æ¦‚è§ˆ

| å®šæ—¶å™¨ç±»å‹ | æ•°é‡ | ä½æ•° | ä¸»è¦åŠŸèƒ½ | åº”ç”¨åœºæ™¯ |
|------------|------|------|----------|----------|
| **åŸºæœ¬å®šæ—¶å™¨** | TIM6ã€TIM7 | 16ä½ | å®šæ—¶ã€DACè§¦å‘ | ç³»ç»Ÿæ—¶åŸºã€å®šæ—¶ä»»åŠ¡ |
| **é€šç”¨å®šæ—¶å™¨** | TIM2-5ã€TIM9-14 | 16/32ä½ | å…¨åŠŸèƒ½å®šæ—¶å™¨ | PWMã€è¾“å…¥æ•è·ã€ç¼–ç å™¨ |
| **é«˜çº§å®šæ—¶å™¨** | TIM1ã€TIM8 | 16ä½ | é«˜çº§æ§åˆ¶åŠŸèƒ½ | ç”µæœºæ§åˆ¶ã€å¤æ‚PWM |

### å„ç±»å®šæ—¶å™¨ç‰¹ç‚¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                STM32å®šæ—¶å™¨æ¶æ„                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŸºæœ¬å®šæ—¶å™¨ (TIM6/7)ï¼š                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚é¢„åˆ†é¢‘â”‚â†’â”‚è®¡æ•°å™¨â”‚â†’â”‚è‡ªåŠ¨é‡è£…â”‚â†’ DACè§¦å‘           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                 â”‚
â”‚  é€šç”¨å®šæ—¶å™¨ (TIM2-5)ï¼š                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚é¢„åˆ†é¢‘â”‚â†’â”‚è®¡æ•°å™¨â”‚â†’â”‚æ¯”è¾ƒå™¨â”‚â†’ PWMè¾“å‡º            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚      â†‘                   â†“                     â”‚
â”‚  å¤–éƒ¨æ—¶é’Ÿ              è¾“å…¥æ•è·                  â”‚
â”‚                                                 â”‚
â”‚  é«˜çº§å®šæ—¶å™¨ (TIM1/8)ï¼š                          â”‚
â”‚  åŒ…å«é€šç”¨å®šæ—¶å™¨æ‰€æœ‰åŠŸèƒ½ +                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚æ­»åŒº â”‚   â”‚åˆ¹è½¦ â”‚   â”‚é‡å¤ â”‚                   â”‚
â”‚  â”‚ç”Ÿæˆ â”‚   â”‚ä¿æŠ¤ â”‚   â”‚è®¡æ•°å™¨â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## âš™ï¸ å®šæ—¶å™¨åŸºç¡€é…ç½®

### å®šæ—¶å™¨æ—¶é’Ÿæº

```c
// å®šæ—¶å™¨æ—¶é’Ÿé…ç½®åˆ†æ
/*
ç³»ç»Ÿæ—¶é’Ÿ: SYSCLK = 168MHz (F407)
AHBæ—¶é’Ÿ:  HCLK = SYSCLK = 168MHz  
APB1æ—¶é’Ÿ: PCLK1 = HCLK/4 = 42MHz   (TIM2-7, TIM12-14)
APB2æ—¶é’Ÿ: PCLK2 = HCLK/2 = 84MHz   (TIM1, TIM8-11)

å®šæ—¶å™¨æ—¶é’Ÿè®¡ç®—è§„åˆ™:
- å½“APBxé¢„åˆ†é¢‘ç³»æ•° = 1æ—¶ï¼Œå®šæ—¶å™¨æ—¶é’Ÿ = PCLKx
- å½“APBxé¢„åˆ†é¢‘ç³»æ•° > 1æ—¶ï¼Œå®šæ—¶å™¨æ—¶é’Ÿ = PCLKx Ã— 2

å®é™…æ—¶é’Ÿé¢‘ç‡:
TIM2-7:   84MHz (42MHz Ã— 2)
TIM1,8-11: 168MHz (84MHz Ã— 2)
*/

// è·å–å®šæ—¶å™¨æ—¶é’Ÿé¢‘ç‡
uint32_t Get_Timer_Clock(TIM_TypeDef* TIMx)
{
    uint32_t tim_clock = 0;
    
    if(TIMx == TIM1 || TIMx == TIM8 || TIMx == TIM9 || 
       TIMx == TIM10 || TIMx == TIM11)
    {
        // APB2å®šæ—¶å™¨
        tim_clock = 168000000;  // 168MHz
    }
    else
    {
        // APB1å®šæ—¶å™¨  
        tim_clock = 84000000;   // 84MHz
    }
    
    return tim_clock;
}
```

### åŸºæœ¬å®šæ—¶åŠŸèƒ½

```c
// åŸºæœ¬å®šæ—¶å™¨é…ç½®ç¤ºä¾‹
TIM_HandleTypeDef htim6;

// å®šæ—¶å™¨åˆå§‹åŒ–
void Timer_Basic_Init(uint16_t period_ms)
{
    // ä½¿èƒ½æ—¶é’Ÿ
    __HAL_RCC_TIM6_CLK_ENABLE();
    
    // è®¡ç®—é¢„åˆ†é¢‘å’Œé‡è£…è½½å€¼
    uint32_t tim_clock = 84000000;      // 84MHz
    uint32_t target_freq = 1000;        // 1kHz (1ms)
    
    htim6.Instance = TIM6;
    htim6.Init.Prescaler = (tim_clock / target_freq) - 1;  // é¢„åˆ†é¢‘
    htim6.Init.CounterMode = TIM_COUNTERMODE_UP;           // å‘ä¸Šè®¡æ•°
    htim6.Init.Period = period_ms - 1;                     // è‡ªåŠ¨é‡è£…è½½å€¼
    htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
    {
        Error_Handler();
    }
}

// å®šæ—¶å™¨ä¸­æ–­é…ç½®
void Timer_IT_Config(void)
{
    // é…ç½®NVIC
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
    
    // å¯åŠ¨å®šæ—¶å™¨ä¸­æ–­
    HAL_TIM_Base_Start_IT(&htim6);
}

// å®šæ—¶å™¨ä¸­æ–­å›è°ƒå‡½æ•°
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM6)
    {
        // å®šæ—¶å™¨ä¸­æ–­å¤„ç†
        static uint32_t count = 0;
        count++;
        
        if(count >= 1000)  // 1ç§’
        {
            HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);  // LEDé—ªçƒ
            count = 0;
        }
    }
}

// å®šæ—¶å™¨ä¸­æ–­æœåŠ¡å‡½æ•°
void TIM6_DAC_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&htim6);
}
```

## ğŸ”„ PWMä¿¡å·ç”Ÿæˆ

### PWMåŸºç¡€åŸç†

```c
/*
PWMå‚æ•°è®¡ç®—:
PWMé¢‘ç‡ = å®šæ—¶å™¨æ—¶é’Ÿ / [(é¢„åˆ†é¢‘å€¼+1) Ã— (é‡è£…è½½å€¼+1)]
å ç©ºæ¯” = æ¯”è¾ƒå€¼ / (é‡è£…è½½å€¼+1) Ã— 100%

ç¤ºä¾‹: ç”Ÿæˆ1kHz PWMï¼Œå ç©ºæ¯”50%
å®šæ—¶å™¨æ—¶é’Ÿ = 84MHz
é¢„åˆ†é¢‘å€¼ = 83 (84MHz/84 = 1MHz)
é‡è£…è½½å€¼ = 999 (1MHz/1000 = 1kHz)
æ¯”è¾ƒå€¼ = 500 (50%å ç©ºæ¯”)
*/

// PWMé…ç½®ç»“æ„
typedef struct
{
    TIM_HandleTypeDef* htim;     // å®šæ—¶å™¨å¥æŸ„
    uint32_t channel;            // PWMé€šé“
    uint16_t frequency;          // PWMé¢‘ç‡(Hz)
    uint8_t duty_cycle;          // å ç©ºæ¯”(0-100)
} PWM_Config_t;
```

### PWMè¾“å‡ºé…ç½®

```c
// PWMåˆå§‹åŒ–ç¤ºä¾‹ - TIM3 CH1 (PA6)
TIM_HandleTypeDef htim3;
TIM_OC_InitTypeDef sConfigOC = {0};

void PWM_Init(uint16_t frequency, uint8_t duty_cycle)
{
    // GPIOé…ç½®
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_TIM3_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_6;                    // TIM3_CH1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;              // å¤ç”¨æ¨æŒ½è¾“å‡º
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;           // å¤ç”¨ä¸ºTIM3
    
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // å®šæ—¶å™¨é…ç½®
    uint32_t tim_clock = 84000000;                       // 84MHz
    uint16_t prescaler = (tim_clock / (frequency * 1000)) - 1;
    uint16_t period = 999;                               // ARRå€¼
    
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = prescaler;
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = period;
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
    
    if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
    {
        Error_Handler();
    }
    
    // PWMé€šé“é…ç½®
    sConfigOC.OCMode = TIM_OCMODE_PWM1;                  // PWMæ¨¡å¼1
    sConfigOC.Pulse = (period + 1) * duty_cycle / 100;  // è®¡ç®—CCRå€¼
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;          // é«˜ç”µå¹³æœ‰æ•ˆ
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    
    if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
    {
        Error_Handler();
    }
    
    // å¯åŠ¨PWMè¾“å‡º
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
}

// åŠ¨æ€è°ƒæ•´PWMå ç©ºæ¯”
void PWM_SetDutyCycle(uint8_t duty_cycle)
{
    if(duty_cycle > 100) duty_cycle = 100;
    
    uint16_t pulse = (htim3.Init.Period + 1) * duty_cycle / 100;
    __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, pulse);
}

// è°ƒæ•´PWMé¢‘ç‡
void PWM_SetFrequency(uint16_t frequency)
{
    uint32_t tim_clock = 84000000;
    uint16_t prescaler = (tim_clock / (frequency * 1000)) - 1;
    
    __HAL_TIM_SET_PRESCALER(&htim3, prescaler);
}
```

### å¤šè·¯PWMæ§åˆ¶

```c
// å¤šè·¯PWMæ§åˆ¶ç»“æ„
typedef struct
{
    TIM_HandleTypeDef* htim;
    uint32_t channel;
    uint8_t duty_cycle;
    uint16_t target_duty;
    uint8_t step;
    uint32_t last_update;
    uint16_t update_period;
} PWM_Channel_t;

// PWMé€šé“æ•°ç»„
PWM_Channel_t pwm_channels[] = {
    {&htim3, TIM_CHANNEL_1, 0, 50, 1, 0, 20},    // èˆµæœº1
    {&htim3, TIM_CHANNEL_2, 0, 75, 1, 0, 30},    // èˆµæœº2
    {&htim3, TIM_CHANNEL_3, 0, 25, 1, 0, 40},    // LEDäº®åº¦
    {&htim3, TIM_CHANNEL_4, 0, 90, 1, 0, 25},    // é£æ‰‡è½¬é€Ÿ
};

#define PWM_CHANNEL_COUNT (sizeof(pwm_channels)/sizeof(pwm_channels[0]))

// PWMæ¸å˜æ•ˆæœ
void PWM_Gradient_Task(void)
{
    uint32_t current_time = HAL_GetTick();
    
    for(int i = 0; i < PWM_CHANNEL_COUNT; i++)
    {
        if(current_time - pwm_channels[i].last_update >= pwm_channels[i].update_period)
        {
            if(pwm_channels[i].duty_cycle != pwm_channels[i].target_duty)
            {
                if(pwm_channels[i].duty_cycle < pwm_channels[i].target_duty)
                {
                    pwm_channels[i].duty_cycle += pwm_channels[i].step;
                    if(pwm_channels[i].duty_cycle > pwm_channels[i].target_duty)
                        pwm_channels[i].duty_cycle = pwm_channels[i].target_duty;
                }
                else
                {
                    pwm_channels[i].duty_cycle -= pwm_channels[i].step;
                    if(pwm_channels[i].duty_cycle < pwm_channels[i].target_duty)
                        pwm_channels[i].duty_cycle = pwm_channels[i].target_duty;
                }
                
                // æ›´æ–°PWMè¾“å‡º
                uint16_t pulse = (pwm_channels[i].htim->Init.Period + 1) * 
                                pwm_channels[i].duty_cycle / 100;
                __HAL_TIM_SET_COMPARE(pwm_channels[i].htim, pwm_channels[i].channel, pulse);
            }
            
            pwm_channels[i].last_update = current_time;
        }
    }
}

// è®¾ç½®PWMç›®æ ‡å€¼
void PWM_SetTarget(uint8_t channel, uint8_t target_duty, uint8_t step, uint16_t period)
{
    if(channel < PWM_CHANNEL_COUNT)
    {
        pwm_channels[channel].target_duty = target_duty;
        pwm_channels[channel].step = step;
        pwm_channels[channel].update_period = period;
    }
}
```

## ğŸ“Š è¾“å…¥æ•è·åŠŸèƒ½

### è„‰å®½æµ‹é‡

```c
// è¾“å…¥æ•è·é…ç½®
TIM_HandleTypeDef htim2;
TIM_IC_InitTypeDef sConfigIC = {0};

// è„‰å®½æµ‹é‡ç»“æ„ä½“
typedef struct
{
    uint32_t rising_edge;     // ä¸Šå‡æ²¿æ—¶é—´
    uint32_t falling_edge;    // ä¸‹é™æ²¿æ—¶é—´
    uint32_t pulse_width;     // è„‰å®½(us)
    uint32_t period;          // å‘¨æœŸ(us)
    uint8_t capture_state;    // æ•è·çŠ¶æ€
} PulseWidth_t;

PulseWidth_t pulse_data;

// è¾“å…¥æ•è·åˆå§‹åŒ–
void InputCapture_Init(void)
{
    // GPIOé…ç½® (PA0 - TIM2_CH1)
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_TIM2_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
    
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // å®šæ—¶å™¨é…ç½® (1MHzè®¡æ•°é¢‘ç‡ï¼Œ1usåˆ†è¾¨ç‡)
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 83;                          // 84MHz/84 = 1MHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 0xFFFFFFFF;                     // 32ä½æœ€å¤§å€¼
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    
    if (HAL_TIM_IC_Init(&htim2) != HAL_OK)
    {
        Error_Handler();
    }
    
    // è¾“å…¥æ•è·é€šé“é…ç½®
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;   // ä¸Šå‡æ²¿è§¦å‘
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;         // ç›´è¿è¾“å…¥
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;                   // ä¸åˆ†é¢‘
    sConfigIC.ICFilter = 0;                                   // æ— æ»¤æ³¢
    
    if (HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
    {
        Error_Handler();
    }
    
    // å¯åŠ¨è¾“å…¥æ•è·ä¸­æ–­
    HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
    
    // é…ç½®NVIC
    HAL_NVIC_SetPriority(TIM2_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

// è¾“å…¥æ•è·ä¸­æ–­å›è°ƒ
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM2)
    {
        if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
        {
            uint32_t capture_value = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
            
            if(pulse_data.capture_state == 0)  // æ£€æµ‹åˆ°ä¸Šå‡æ²¿
            {
                pulse_data.rising_edge = capture_value;
                pulse_data.capture_state = 1;
                
                // åˆ‡æ¢åˆ°ä¸‹é™æ²¿æ£€æµ‹
                __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);
            }
            else  // æ£€æµ‹åˆ°ä¸‹é™æ²¿
            {
                pulse_data.falling_edge = capture_value;
                
                // è®¡ç®—è„‰å®½ (å¤„ç†è®¡æ•°å™¨æº¢å‡º)
                if(pulse_data.falling_edge >= pulse_data.rising_edge)
                {
                    pulse_data.pulse_width = pulse_data.falling_edge - pulse_data.rising_edge;
                }
                else
                {
                    pulse_data.pulse_width = (0xFFFFFFFF - pulse_data.rising_edge) + 
                                           pulse_data.falling_edge + 1;
                }
                
                pulse_data.capture_state = 0;
                
                // åˆ‡æ¢å›ä¸Šå‡æ²¿æ£€æµ‹
                __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
                
                // æ•°æ®å¤„ç†
                printf("Pulse Width: %d us\r\n", pulse_data.pulse_width);
            }
        }
    }
}

// å®šæ—¶å™¨ä¸­æ–­æœåŠ¡å‡½æ•°
void TIM2_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&htim2);
}
```

### é¢‘ç‡æµ‹é‡

```c
// é¢‘ç‡æµ‹é‡ç»“æ„ä½“
typedef struct
{
    uint32_t last_capture;    // ä¸Šæ¬¡æ•è·å€¼
    uint32_t current_capture; // å½“å‰æ•è·å€¼
    uint32_t period_us;       // å‘¨æœŸ(us)
    float frequency;          // é¢‘ç‡(Hz)
    uint8_t first_capture;    // é¦–æ¬¡æ•è·æ ‡å¿—
} FreqMeasure_t;

FreqMeasure_t freq_data = {0};

// é¢‘ç‡æµ‹é‡åˆå§‹åŒ– (æµ‹é‡ä¸Šå‡æ²¿é—´éš”)
void FreqMeasure_Init(void)
{
    // é…ç½®ä¸è„‰å®½æµ‹é‡ç±»ä¼¼ï¼Œä½†ä¿æŒä¸Šå‡æ²¿æ£€æµ‹
    InputCapture_Init();
    
    // åªæ£€æµ‹ä¸Šå‡æ²¿
    TIM_IC_InitTypeDef sConfigIC = {0};
    sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
    sConfigIC.ICFilter = 0;
    
    HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1);
}

// é¢‘ç‡æµ‹é‡ä¸­æ–­å›è°ƒ
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM2 && htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
        freq_data.current_capture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        
        if(freq_data.first_capture == 0)
        {
            freq_data.last_capture = freq_data.current_capture;
            freq_data.first_capture = 1;
        }
        else
        {
            // è®¡ç®—å‘¨æœŸ
            if(freq_data.current_capture >= freq_data.last_capture)
            {
                freq_data.period_us = freq_data.current_capture - freq_data.last_capture;
            }
            else
            {
                freq_data.period_us = (0xFFFFFFFF - freq_data.last_capture) + 
                                     freq_data.current_capture + 1;
            }
            
            // è®¡ç®—é¢‘ç‡
            if(freq_data.period_us > 0)
            {
                freq_data.frequency = 1000000.0f / freq_data.period_us;  // Hz
                printf("Frequency: %.2f Hz\r\n", freq_data.frequency);
            }
            
            freq_data.last_capture = freq_data.current_capture;
        }
    }
}
```

## ğŸ›ï¸ ç¼–ç å™¨æ¥å£

### æ­£äº¤ç¼–ç å™¨

```c
// ç¼–ç å™¨é…ç½®
TIM_HandleTypeDef htim4;
TIM_Encoder_InitTypeDef sConfig = {0};

// ç¼–ç å™¨æ•°æ®ç»“æ„
typedef struct
{
    int32_t position;         // å½“å‰ä½ç½®
    int32_t last_count;       // ä¸Šæ¬¡è®¡æ•°å€¼
    int32_t velocity;         // é€Ÿåº¦ (è„‰å†²/ç§’)
    float angle;              // è§’åº¦ (åº¦)
    uint32_t ppr;             // æ¯è½¬è„‰å†²æ•°
    uint32_t last_time;       // ä¸Šæ¬¡æ›´æ–°æ—¶é—´
} Encoder_t;

Encoder_t encoder = {0};

// ç¼–ç å™¨åˆå§‹åŒ–
void Encoder_Init(uint32_t pulses_per_revolution)
{
    // GPIOé…ç½® (PB6-TIM4_CH1, PB7-TIM4_CH2)
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_TIM4_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;                   // ä¸Šæ‹‰ç”µé˜»
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    
    // ç¼–ç å™¨æ¥å£é…ç½®
    htim4.Instance = TIM4;
    htim4.Init.Prescaler = 0;                             // ä¸åˆ†é¢‘
    htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim4.Init.Period = 0xFFFF;                           // 16ä½æœ€å¤§å€¼
    htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    
    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;           // ä¸¤è·¯ç¼–ç 
    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;          // Aç›¸ææ€§
    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC1Filter = 0;
    
    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;          // Bç›¸ææ€§  
    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
    sConfig.IC2Filter = 0;
    
    if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK)
    {
        Error_Handler();
    }
    
    // å¯åŠ¨ç¼–ç å™¨æ¥å£
    HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);
    
    // åˆå§‹åŒ–ç¼–ç å™¨å‚æ•°
    encoder.ppr = pulses_per_revolution;
    encoder.last_count = __HAL_TIM_GET_COUNTER(&htim4);
    encoder.last_time = HAL_GetTick();
}

// ç¼–ç å™¨æ•°æ®æ›´æ–°
void Encoder_Update(void)
{
    uint32_t current_time = HAL_GetTick();
    int32_t current_count = (int32_t)__HAL_TIM_GET_COUNTER(&htim4);
    
    // è®¡ç®—ä½ç½®å˜åŒ– (å¤„ç†æº¢å‡º)
    int32_t delta_count = current_count - encoder.last_count;
    
    if(delta_count > 32767)
    {
        delta_count -= 65536;  // å¤„ç†å‘ä¸‹æº¢å‡º
    }
    else if(delta_count < -32768)
    {
        delta_count += 65536;  // å¤„ç†å‘ä¸Šæº¢å‡º
    }
    
    encoder.position += delta_count;
    
    // è®¡ç®—é€Ÿåº¦ (è„‰å†²/ç§’)
    uint32_t delta_time = current_time - encoder.last_time;
    if(delta_time > 0)
    {
        encoder.velocity = (delta_count * 1000) / delta_time;
    }
    
    // è®¡ç®—è§’åº¦
    encoder.angle = (float)encoder.position * 360.0f / encoder.ppr;
    
    // æ›´æ–°å†å²å€¼
    encoder.last_count = current_count;
    encoder.last_time = current_time;
}

// è·å–ç¼–ç å™¨æ•°æ®
int32_t Encoder_GetPosition(void)
{
    return encoder.position;
}

float Encoder_GetAngle(void)
{
    return encoder.angle;
}

int32_t Encoder_GetVelocity(void)
{
    return encoder.velocity;
}

// ç¼–ç å™¨æ¸…é›¶
void Encoder_Reset(void)
{
    encoder.position = 0;
    encoder.last_count = __HAL_TIM_GET_COUNTER(&htim4);
    __HAL_TIM_SET_COUNTER(&htim4, 0);
}
```

## ğŸš€ é«˜çº§åº”ç”¨

### ç”µæœºPWMæ§åˆ¶

```c
// ç›´æµç”µæœºPWMæ§åˆ¶
typedef struct
{
    TIM_HandleTypeDef* htim;
    uint32_t pwm_channel;
    GPIO_TypeDef* dir_port;
    uint16_t dir_pin;
    int16_t speed;              // -100 åˆ° +100
    uint8_t enable;
} Motor_t;

Motor_t motor = {
    .htim = &htim3,
    .pwm_channel = TIM_CHANNEL_1,
    .dir_port = GPIOB,
    .dir_pin = GPIO_PIN_0,
    .speed = 0,
    .enable = 0
};

// ç”µæœºæ§åˆ¶åˆå§‹åŒ–
void Motor_Init(void)
{
    // PWMåˆå§‹åŒ– (åœ¨å‰é¢å·²å®ç°)
    PWM_Init(1000, 0);  // 1kHz PWM, 0%å ç©ºæ¯”
    
    // æ–¹å‘æ§åˆ¶å¼•è„š
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOB_CLK_ENABLE();
    
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

// è®¾ç½®ç”µæœºé€Ÿåº¦
void Motor_SetSpeed(int16_t speed)
{
    if(speed > 100) speed = 100;
    if(speed < -100) speed = -100;
    
    motor.speed = speed;
    
    if(!motor.enable)
    {
        PWM_SetDutyCycle(0);
        return;
    }
    
    // è®¾ç½®æ–¹å‘
    if(speed >= 0)
    {
        HAL_GPIO_WritePin(motor.dir_port, motor.dir_pin, GPIO_PIN_RESET);  // æ­£è½¬
        PWM_SetDutyCycle(speed);
    }
    else
    {
        HAL_GPIO_WritePin(motor.dir_port, motor.dir_pin, GPIO_PIN_SET);    // åè½¬
        PWM_SetDutyCycle(-speed);
    }
}

// ç”µæœºä½¿èƒ½æ§åˆ¶
void Motor_Enable(uint8_t enable)
{
    motor.enable = enable;
    
    if(!enable)
    {
        PWM_SetDutyCycle(0);  // åœæ­¢è¾“å‡º
    }
    else
    {
        Motor_SetSpeed(motor.speed);  // æ¢å¤è¾“å‡º
    }
}
```

### èˆµæœºæ§åˆ¶

```c
// èˆµæœºæ§åˆ¶ç»“æ„ä½“
typedef struct
{
    TIM_HandleTypeDef* htim;
    uint32_t channel;
    uint16_t min_pulse;         // æœ€å°è„‰å®½(us)
    uint16_t max_pulse;         // æœ€å¤§è„‰å®½(us)
    uint16_t center_pulse;      // ä¸­å¿ƒè„‰å®½(us)
    float current_angle;        // å½“å‰è§’åº¦
    float target_angle;         // ç›®æ ‡è§’åº¦
    uint8_t is_moving;          // è¿åŠ¨çŠ¶æ€
} Servo_t;

Servo_t servo = {
    .htim = &htim3,
    .channel = TIM_CHANNEL_2,
    .min_pulse = 500,           // 0.5ms
    .max_pulse = 2500,          // 2.5ms
    .center_pulse = 1500,       // 1.5ms
    .current_angle = 90.0f,     // åˆå§‹ä¸­å¿ƒä½ç½®
    .target_angle = 90.0f,
    .is_moving = 0
};

// èˆµæœºåˆå§‹åŒ– (20mså‘¨æœŸ, 50Hz)
void Servo_Init(void)
{
    // PWMé…ç½®: 50Hzé¢‘ç‡
    uint32_t tim_clock = 84000000;
    uint16_t prescaler = 83;                // 1MHzè®¡æ•°é¢‘ç‡
    uint16_t period = 19999;                // 20mså‘¨æœŸ
    
    htim3.Init.Prescaler = prescaler;
    htim3.Init.Period = period;
    
    // é‡æ–°åˆå§‹åŒ–å®šæ—¶å™¨
    HAL_TIM_PWM_Init(&htim3);
    
    // PWMé€šé“é…ç½®
    TIM_OC_InitTypeDef sConfigOC = {0};
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = servo.center_pulse;   // 1.5msè„‰å®½
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    
    HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, servo.channel);
    HAL_TIM_PWM_Start(&htim3, servo.channel);
}

// è§’åº¦è½¬æ¢ä¸ºè„‰å®½
uint16_t Servo_AngleToPulse(float angle)
{
    if(angle < 0) angle = 0;
    if(angle > 180) angle = 180;
    
    // çº¿æ€§æ’å€¼è®¡ç®—è„‰å®½
    uint16_t pulse = servo.min_pulse + 
                    (uint16_t)((angle / 180.0f) * (servo.max_pulse - servo.min_pulse));
    
    return pulse;
}

// è®¾ç½®èˆµæœºè§’åº¦
void Servo_SetAngle(float angle)
{
    servo.target_angle = angle;
    uint16_t pulse = Servo_AngleToPulse(angle);
    
    __HAL_TIM_SET_COMPARE(servo.htim, servo.channel, pulse);
    servo.current_angle = angle;
}

// èˆµæœºå¹³æ»‘è¿åŠ¨
void Servo_SmoothMove(float target_angle, float speed)
{
    servo.target_angle = target_angle;
    servo.is_moving = 1;
    
    // åœ¨å®šæ—¶ä»»åŠ¡ä¸­å®ç°å¹³æ»‘è¿åŠ¨
}

// èˆµæœºè¿åŠ¨ä»»åŠ¡ (åœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­è°ƒç”¨)
void Servo_Task(void)
{
    if(servo.is_moving)
    {
        float angle_diff = servo.target_angle - servo.current_angle;
        
        if(fabs(angle_diff) < 1.0f)  // åˆ°è¾¾ç›®æ ‡
        {
            servo.current_angle = servo.target_angle;
            servo.is_moving = 0;
        }
        else
        {
            float step = (angle_diff > 0) ? 1.0f : -1.0f;
            servo.current_angle += step;
        }
        
        uint16_t pulse = Servo_AngleToPulse(servo.current_angle);
        __HAL_TIM_SET_COMPARE(servo.htim, servo.channel, pulse);
    }
}
```

## ğŸ”§ å®šæ—¶å™¨è°ƒè¯•æŠ€å·§

### æ€§èƒ½ç›‘æµ‹

```c
// å®šæ—¶å™¨æ€§èƒ½æµ‹è¯•
void Timer_PerformanceTest(void)
{
    uint32_t start_time, end_time;
    
    // æµ‹è¯•PWMæ›´æ–°é€Ÿåº¦
    start_time = HAL_GetTick();
    
    for(uint32_t i = 0; i < 10000; i++)
    {
        PWM_SetDutyCycle(i % 101);  // 0-100%å ç©ºæ¯”
    }
    
    end_time = HAL_GetTick();
    printf("PWM Update Test: %d ms for 10000 updates\r\n", end_time - start_time);
    
    // æµ‹è¯•å®šæ—¶å™¨è¯»å–é€Ÿåº¦
    start_time = HAL_GetTick();
    
    uint32_t dummy;
    for(uint32_t i = 0; i < 100000; i++)
    {
        dummy = __HAL_TIM_GET_COUNTER(&htim3);
    }
    
    end_time = HAL_GetTick();
    printf("Timer Read Test: %d ms for 100000 reads\r\n", end_time - start_time);
}

// å®šæ—¶å™¨çŠ¶æ€ç›‘æ§
void Timer_StatusMonitor(TIM_HandleTypeDef* htim)
{
    printf("Timer Status Monitor:\r\n");
    printf("Counter: %d\r\n", __HAL_TIM_GET_COUNTER(htim));
    printf("Period: %d\r\n", htim->Init.Period);
    printf("Prescaler: %d\r\n", htim->Init.Prescaler);
    
    if(htim->Instance == TIM3)
    {
        printf("CCR1: %d\r\n", __HAL_TIM_GET_COMPARE(htim, TIM_CHANNEL_1));
        printf("CCR2: %d\r\n", __HAL_TIM_GET_COMPARE(htim, TIM_CHANNEL_2));
        printf("CCR3: %d\r\n", __HAL_TIM_GET_COMPARE(htim, TIM_CHANNEL_3));
        printf("CCR4: %d\r\n", __HAL_TIM_GET_COMPARE(htim, TIM_CHANNEL_4));
    }
    
    printf("Control Register: 0x%08X\r\n", htim->Instance->CR1);
    printf("Status Register: 0x%08X\r\n", htim->Instance->SR);
    printf("------------------------\r\n");
}
```

### å¸¸è§é—®é¢˜æ’æŸ¥

```c
// å®šæ—¶å™¨é—®é¢˜è¯Šæ–­
void Timer_Diagnose(TIM_HandleTypeDef* htim)
{
    printf("Timer Diagnosis:\r\n");
    
    // æ£€æŸ¥æ—¶é’Ÿä½¿èƒ½
    if(htim->Instance == TIM1)
    {
        printf("TIM1 Clock: %s\r\n", 
               (__HAL_RCC_TIM1_IS_CLK_ENABLED()) ? "Enabled" : "Disabled");
    }
    else if(htim->Instance == TIM2)
    {
        printf("TIM2 Clock: %s\r\n", 
               (__HAL_RCC_TIM2_IS_CLK_ENABLED()) ? "Enabled" : "Disabled");
    }
    
    // æ£€æŸ¥å®šæ—¶å™¨ä½¿èƒ½
    printf("Timer Enable: %s\r\n", 
           (__HAL_TIM_IS_TIM_COUNTING_DOWN(htim) || 
            (htim->Instance->CR1 & TIM_CR1_CEN)) ? "Yes" : "No");
    
    // æ£€æŸ¥ä¸­æ–­ä½¿èƒ½
    printf("Update Interrupt: %s\r\n", 
           (htim->Instance->DIER & TIM_DIER_UIE) ? "Enabled" : "Disabled");
    
    // æ£€æŸ¥è¾“å‡ºä½¿èƒ½ (PWM)
    if(htim->Instance == TIM1 || htim->Instance == TIM8)
    {
        printf("Main Output: %s\r\n", 
               (htim->Instance->BDTR & TIM_BDTR_MOE) ? "Enabled" : "Disabled");
    }
    
    printf("------------------------\r\n");
}
```

## ğŸ’¡ ä½¿ç”¨å»ºè®®

### å®šæ—¶å™¨é€‰æ‹©åŸåˆ™

**åŸºæœ¬å®šæ—¶åŠŸèƒ½**ï¼š
- é€‰æ‹©åŸºæœ¬å®šæ—¶å™¨ (TIM6/7)
- å ç”¨èµ„æºå°‘ï¼Œé…ç½®ç®€å•

**PWMè¾“å‡º**ï¼š
- é€‰æ‹©é€šç”¨å®šæ—¶å™¨ (TIM2-5)
- å¤šé€šé“è¾“å‡ºï¼ŒåŠŸèƒ½å®Œæ•´

**ç”µæœºæ§åˆ¶**ï¼š
- é€‰æ‹©é«˜çº§å®šæ—¶å™¨ (TIM1/8)
- æ”¯æŒæ­»åŒºã€åˆ¹è½¦ä¿æŠ¤

**ç¼–ç å™¨æ¥å£**ï¼š
- é€‰æ‹©é€šç”¨å®šæ—¶å™¨
- 32ä½å®šæ—¶å™¨(TIM2/5)æ›´é€‚åˆé«˜åˆ†è¾¨ç‡

### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

**å‡å°‘ä¸­æ–­å¼€é”€**ï¼š
```c
// ä½¿ç”¨DMAä»£æ›¿ä¸­æ–­
HAL_TIM_PWM_Start_DMA(&htim3, TIM_CHANNEL_1, pwm_buffer, buffer_size);
```

**æ‰¹é‡æ›´æ–°PWM**ï¼š
```c
// åŒæ—¶æ›´æ–°å¤šä¸ªé€šé“
__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, value1);
__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, value2);
__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_3, value3);
```

### è°ƒè¯•å»ºè®®

**ä½¿ç”¨ç¤ºæ³¢å™¨**ï¼š
- è§‚å¯ŸPWMæ³¢å½¢
- æµ‹é‡é¢‘ç‡å’Œå ç©ºæ¯”
- æ£€æŸ¥ä¿¡å·è´¨é‡

**é€»è¾‘åˆ†æä»ª**ï¼š
- å¤šè·¯ä¿¡å·æ—¶åºåˆ†æ
- ç¼–ç å™¨ä¿¡å·è§£ç 
- é€šä¿¡åè®®åˆ†æ

---

> **å®šæ—¶å™¨æ€»ç»“**ï¼šSTM32å®šæ—¶å™¨åŠŸèƒ½å¼ºå¤§ï¼Œåº”ç”¨å¹¿æ³›ã€‚æŒæ¡åŸºæœ¬å®šæ—¶ã€PWMç”Ÿæˆã€è¾“å…¥æ•è·å’Œç¼–ç å™¨æ¥å£ç­‰åŠŸèƒ½ï¼Œèƒ½å¤Ÿåº”å¯¹å¤§éƒ¨åˆ†åµŒå…¥å¼åº”ç”¨éœ€æ±‚ã€‚åˆç†é€‰æ‹©å®šæ—¶å™¨ç±»å‹å’Œé…ç½®å‚æ•°ï¼Œæ³¨é‡æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•æŠ€å·§ã€‚

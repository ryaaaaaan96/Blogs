# 编程知识\_汇编\_反汇编_机器码 #

## 1. 程序处理的4个步骤

我们的第1个LED程序涉及2个文件：start.S、main.c，它们的处理过程如下：
![[001_4_steps 1.png]]
我们想深入理解ARM架构，想深入理解汇编与C，想深入理解栈的作用，想深入理解C语言的实质，
就必须把最终的可执行程序，反汇编后，阅读得到的汇编代码。

上述4个步骤的细节，在后面课程里再讲。
现在只需要理解“汇编”、“反汇编”的概念：

* 汇编
  汇编文件转换为目标文件(里面是机器码)。
* 反汇编
  可执行文件(目标文件，里面是机器码)，转换为汇编文件。

## 2. KEIL下怎么反汇编

在KEIL的User选项中，如下图添加这两项：

```
fromelf  --bin  --output=led.bin  Objects\led_c.axf
fromelf  --text  -a -c  --output=led.dis  Objects\led_c.axf
```

然后重新编译，即可得到二进制文件led.bin(以后会分析)、反汇编文件led.dis。
如下图操作：
![[002_keil_create_dis.png]]
## 3. GCC下反汇编

使用GCC工具链编译程序时，在Makefile中有这一句：

```
$(OBJDUMP) -D -m arm  led.elf  > led.dis	# OBJDUMP = arm-linux-gnueabihf-objdump
```

它就是把可执行程序led.elf，反汇编，得到led.dis。


## 4. 机器码与汇编

参考资料：
```
doc_and_source_for_mcu_mpu\通用资料\ARM:
    DDI0403E_B_armv7m_arm.pdf  P254  // cortex M3/M4
    ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf  P410  // cortex A7
```

前面介绍过伪指令，伪指令是实际不存在的ARM命令，编译器在编译时转换成存在的ARM指令。
我们代码中的`ldr r1, =0x????????`这条伪指令的真实指令是什么呢?
对于我们使用的3款板子，汇编代码如下(如果你的板子不是这3款之一，请灵活变通，知识是一样的)：

```
LDR SP, =(0x20000000+0x10000)   // STM32F103
ldr sp, =(0x80000000+0x100000)  // IMX6ULL
ldr sp, =0xc0000000 + 0x100000  // STM32MP157 A7
```

我们可以通过反汇编来查看, 只摘取前面一小段。

### 4.1 STM32F103反汇编

我们只摘取前面一小段，第一列是地址，第二列是机器码，第三列是汇编：
![[003_stm32f103_dis.png]]
### 4.2 STM32MP157反汇编
![[004_stm32mp157_a7.png]]

### 4.3 IMX6ULL反汇编
![[005_imx6ull_dis.png]]
### 4.4 机器码与汇编示例

#### 4.4.1 Thumb/Thumb2指令集
![[006_thumb_encoding.png]]
#### 4.4.2 ARM指令集
![[007_arm_encoding.png]]
### 4.5 解析LDR伪指令

为什么 PC=当前指令+4或8？

* CORTEX M3/M4
  使用Thumb2指令集，一条指令是16位或32位。

* CORTEX A7

  默认使用ARM指令集，一条指令是32位的。

* 流水线

  ARM指令采用流水线机制：

  * 当前执行地址A的指令，
  * 同时已经在对下一条指令进行译码
  * 同时已经在读取下下一条指令：PC = A +4 (Thumb/Thumb2指令集)、PC = A + 8 (ARM指令集)

### 4.5 总结

* C
  为了方便人类方便使用，发明的高级语言，要转换为汇编。

* 汇编
  为了解放人类的记忆，发明的“助记符”，不用去记各类机器码。

  最终要转换为机器码。
  
* 机器码

  给CPU使用


## 5. 汇编怎么调用C函数

### 5.1 直接调用

```
bl main
```

### 5.2 想传参数怎么办？

在arm中有个ATPCS规则(ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）。
约定r0-r15寄存器的用途：

* r0-r3

  调用者和被调用者之间传参数

* r4-r11

  函数可能被使用，所以在函数的入口保存它们，在函数的出口恢复它们。
  
![[008_atpcs.png]]
代码示例：

```c
int delay(unsigned int d)
{
	while (d--);
    return 0;
}
```

在汇编里调用delay：

```
ldr  r0, =1000000   /* 给delay函数传参数，保存在r0里 */
bl delay
cmp r0, #0          /* 返回值保存在r0中 */
```



## 6. C函数的反汇编码阅读

要解决这几个问题：

* 为什么调用C函数前要设置栈？栈的作用是？
* C函数传参
* C函数执行过程体验

## 7. Flash上的内容

### 7.1 反汇编示例
![[009_machine_code_on_flash.png]]
### 7.2 烧写在Flash上的内容

| 地址       | Flash内容 |
| ---------- | -------- |
| 0x08000000 | 00000000 |
| 0x08000004 | 08000009 |
| 0x08000008 | f8dfd004 |
| 0x0800000c | f000f80c |
| 0x08000010 | 20010000 |
| 0x08000014 | bf00b501 |
| 0x08000018 | 1e419800 |
| …… | …… |

### 7.3 启动流程

上电后：

* 设置栈：CPU会从0x08000000读取值，用来设置SP(我们的程序里再次设置了SP)
* 跳转：CPU从0x08000004得到地址值，根据它的BIT0切换为ARM状态或Thumb状态，然后跳转
  * 对于cortex M3/M4，它只支持Thumb状态，所以0x08000004上的值bit0必定是1
  * 0x08000004上的值 = Reset_Handler + 1
* 从Reset_Handler继续执行

## 8.课后作业

* 编写一个纯汇编程序，实现点灯
* 编写一个c程序，实现用按钮控制LED

## 9. 纯汇编点灯
### 9.1程序流程图

```flow
st=>start: start
gpio_on=>operation: 使能GPIO模块
gpio_mode=>operation: 设置引脚为GPIO功能
gpio_out=>operation: 设置引脚为输出
gpio_high=>operation: 设置引脚输出高电平
gpio_low=>operation: 设置引脚输出低电平
delay_func1=>subroutine: delay
delay_func2=>subroutine: delay
e=>end: end
st->gpio_on->gpio_mode->gpio_out->gpio_high
gpio_high->delay_func1->gpio_low->delay_func2(left)->gpio_high
```
### 9.2 delay函数流程图

```flow
st=>start: start
sub=>operation: R0减1
cmp_zero=>condition: 等于0?
return=>operation: 返回LR所示地址

st->sub->cmp_zero
cmp_zero(no)->sub
cmp_zero(yes)->return
```

### 9.3 写程序
* 寄存器操作
  对于寄存器的操作，主要涉及读、修改、写。

  * 读可以使用LDR指令，代码为`LDR R1, [R0]`

  * 写使用STR指令，代码为`STR R1, [R0]`

  * 修改稍微复杂，清除位使用BIC或AND指令，设置位使用ORR指令

    ```
    LDR R0, =(1<<20) | (1<<21)
    BIC R1, R1, R0              ; 清除R1的bit20, bit21
    LDR R0, =(1<<20)
    ORR R1, R1, R0              ; 设置R1的bit20
    ```

    

* 函数里的条件判断
比如减1操作，代码为`SUB R0, R0, #1`
但是顺便使用减1后的结果影响程序状态寄存器，代码为`SUBS R0, R0, #1`

* 程序的调用与返回
  * 传参，代码为`LDR R0, =VAL`
  + 调用，代码为`BL delay`，它顺便把下一条指令的地址保存在LR寄存器了
  + 返回，代码为`MOV PC, LR`


## 1 冯诺依曼和哈佛的结构差别是有没有单独的数据总线和地址总线，哈佛结构有单独的存储区域



## 2 对于计算机来说有大量的指令操作数是立即数，如果按照标准方法先要把常数加载到寄存器中进行操作，所以增加了使用目标操作数是立即数的指令。这种操作效率更高能耗更低


## 3 ARM v8的指令集和riscV一样包含一个常0寄存器，并且寄存器的个数也增加到了32个，和risc V采用了相同的模式。


## 4 完整的ARMv8指令和ARMv7中, ANDI 、 ORRI 和 EORI 的立即数字段并不是简单的12位立即数。在这些指令中，`imm12`可以是直接的12位值，也可以是一个通过移位操作得到的值。如果移位值不是0，那么`imm12`会被左移相应的位数，然后与寄存器`Rn`的值进行逻辑运算。这种操作并不是很常见，并且可能会影响寄存器的复杂程度。


## 5 对于switch case和if else if 的实现并不相同，使用通过分支地址表的形式实现的


## 6 存在一个LR寄存器，可以通过无条件跳转条件进行跳转，arm中为bl，在risc v中为 jalr 其中一个寄存器设置为x0（永远为0）


## 7 对于现代指令集来说（arm v8和risc v）都是将寄存器换成了2类，一类调用者保护，一类被调用者保护。都是根据需要进行保存。如果是调用非叶过程就需要进行细致的考虑。（应该是编译器考虑的事情）

## 8 对于调用过程中的栈考虑有两种通用做法，一种是使用fp（帧指针）作为基地址，用局部变量的时候都使用fp作为基地址来进行分析，
![[企业微信截图_17204869581120.png]]


## 9 对于risc V和arm V8来说，修改成了参数寄存器为8个，对于arm v7来说只有4个；

## 10 寄存器使用操作
![[Pasted image 20240709091232.png]]

## 11 实际中保存会应用进行16字节对齐，一个char也是16字节，一些编译器会对string进行压缩。

## 12 对于大立即数的寻址和操作在RISC V 和arm V8中完全不同。对于Arm V8来说有两种方式，对于位外的数保持之前的值，（寄存器中）或者保持值为0，对于Arm来说，还可以对位置进行选定，用于决定是0-15、16-31、32-55或56-64。

## 13 条件和分支指令都是基于当前的PC指令进行跳转。相对跳转是相对地址有正负。

## 14 指令并行的同步，对于RISC V和Arm V8都有这样的同步指令，加载一个数和存储一个数，实现了简单的一个锁的功能。


## 15 动态链接库的实现是通过单片机的操作来实现的，首次会进入一个系统的函数，然后通过约定寄存器传递参数，程序寻找动态链接的函数，然后将此函数的地址写入这个位置，在下次跳转的过程中就可以直接跳转了


## 16 在ARM V8和risc V中程序寄存器（PC）是一个单独的寄存器，不在32个寄存器当中。
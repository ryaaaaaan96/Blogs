# MATLAB运算符与表达式

## 📋 概述

MATLAB提供了丰富的运算符来处理标量、向量和矩阵运算。理解不同类型的运算符及其优先级对于编写高效的MATLAB代码至关重要。本文将详细介绍MATLAB中的各种运算符和表达式的使用方法。

## ➕ 算术运算符

### 标量算术运算

```matlab
% 基本算术运算符
a = 10;
b = 3;

addition = a + b;           % 加法
subtraction = a - b;        % 减法
multiplication = a * b;     % 乘法
division = a / b;           % 右除法
left_division = a \ b;      % 左除法
power = a ^ b;              % 乘方
modulo = mod(a, b);         % 取模

fprintf('标量算术运算 (a=%d, b=%d):\n', a, b);
fprintf('a + b = %d\n', addition);
fprintf('a - b = %d\n', subtraction);
fprintf('a * b = %d\n', multiplication);
fprintf('a / b = %.4f\n', division);
fprintf('a \\ b = %.4f\n', left_division);
fprintf('a ^ b = %d\n', power);
fprintf('mod(a, b) = %d\n', modulo);

% 特殊算术运算
sqrt_val = sqrt(16);        % 平方根
abs_val = abs(-5);          % 绝对值
sign_val = sign(-3.5);      % 符号函数
factorial_val = factorial(5); % 阶乘

fprintf('\n特殊算术函数:\n');
fprintf('sqrt(16) = %.2f\n', sqrt_val);
fprintf('abs(-5) = %d\n', abs_val);
fprintf('sign(-3.5) = %d\n', sign_val);
fprintf('factorial(5) = %d\n', factorial_val);
```

### 矩阵算术运算

```matlab
% 矩阵运算
A = [1, 2; 3, 4];
B = [5, 6; 7, 8];
C = [2; 3];

% 矩阵加法和减法
matrix_add = A + B;
matrix_sub = A - B;

% 矩阵乘法
matrix_mult = A * B;        % 矩阵乘法
matrix_vec_mult = A * C;    % 矩阵向量乘法

% 矩阵幂运算
matrix_power = A^2;         % 矩阵的平方

fprintf('矩阵运算:\n');
fprintf('A = \n'); disp(A);
fprintf('B = \n'); disp(B);
fprintf('A + B = \n'); disp(matrix_add);
fprintf('A - B = \n'); disp(matrix_sub);
fprintf('A * B = \n'); disp(matrix_mult);
fprintf('A^2 = \n'); disp(matrix_power);

% 矩阵的特殊运算
det_A = det(A);             % 行列式
inv_A = inv(A);             % 逆矩阵
trace_A = trace(A);         % 迹
rank_A = rank(A);           % 秩

fprintf('矩阵A的性质:\n');
fprintf('行列式: %.2f\n', det_A);
fprintf('迹: %.2f\n', trace_A);
fprintf('秩: %d\n', rank_A);
fprintf('逆矩阵:\n'); disp(inv_A);
```

### 元素级算术运算

```matlab
% 点运算符（element-wise operations）
x = [1, 2, 3, 4];
y = [2, 3, 4, 5];

% 元素级运算
elem_mult = x .* y;         % 元素级乘法
elem_div = x ./ y;          % 元素级除法
elem_power = x .^ y;        % 元素级乘方

fprintf('元素级运算:\n');
fprintf('x = [%s]\n', num2str(x));
fprintf('y = [%s]\n', num2str(y));
fprintf('x .* y = [%s]\n', num2str(elem_mult));
fprintf('x ./ y = [%s]\n', num2str(elem_div, '%.4f '));
fprintf('x .^ y = [%s]\n', num2str(elem_power));

% 矩阵的元素级运算
M1 = [1, 2; 3, 4];
M2 = [2, 1; 1, 2];

elem_matrix_mult = M1 .* M2;
elem_matrix_div = M1 ./ M2;
elem_matrix_power = M1 .^ 2;

fprintf('\n矩阵元素级运算:\n');
fprintf('M1 = \n'); disp(M1);
fprintf('M2 = \n'); disp(M2);
fprintf('M1 .* M2 = \n'); disp(elem_matrix_mult);
fprintf('M1 ./ M2 = \n'); disp(elem_matrix_div);
fprintf('M1 .^ 2 = \n'); disp(elem_matrix_power);
```

## 🔄 关系运算符

### 基本关系运算

```matlab
% 关系运算符
a = 5;
b = 3;
c = 5;

% 比较运算
equal = (a == c);           % 等于
not_equal = (a ~= b);       % 不等于
greater = (a > b);          % 大于
less = (a < b);             % 小于
greater_equal = (a >= c);   % 大于等于
less_equal = (a <= b);      % 小于等于

fprintf('关系运算 (a=%d, b=%d, c=%d):\n', a, b, c);
fprintf('a == c: %d\n', equal);
fprintf('a ~= b: %d\n', not_equal);
fprintf('a > b: %d\n', greater);
fprintf('a < b: %d\n', less);
fprintf('a >= c: %d\n', greater_equal);
fprintf('a <= b: %d\n', less_equal);
```

### 数组关系运算

```matlab
% 数组的关系运算
array1 = [1, 2, 3, 4, 5];
array2 = [2, 2, 1, 4, 6];

% 元素级比较
comparison_results = {
    array1 == array2, '等于';
    array1 > array2, '大于';
    array1 < array2, '小于';
    array1 >= array2, '大于等于';
    array1 <= array2, '小于等于'
};

fprintf('\n数组关系运算:\n');
fprintf('array1 = [%s]\n', num2str(array1));
fprintf('array2 = [%s]\n', num2str(array2));

for i = 1:size(comparison_results, 1)
    result = comparison_results{i, 1};
    operation = comparison_results{i, 2};
    fprintf('%s: [%s]\n', operation, num2str(result));
end

% 数组比较函数
is_equal_arrays = isequal(array1, array2);
is_equal_size = isequal(size(array1), size(array2));

fprintf('\nisequal(array1, array2): %d\n', is_equal_arrays);
fprintf('isequal(size(array1), size(array2)): %d\n', is_equal_size);
```

### 字符串关系运算

```matlab
% 字符串比较
str1 = 'apple';
str2 = 'banana';
str3 = 'apple';

% 字符串比较
str_equal = strcmp(str1, str3);        % 精确比较
str_equal_ignore = strcmpi(str1, 'APPLE'); % 忽略大小写
str_contains = contains(str2, 'nan');   % 包含关系

fprintf('\n字符串关系运算:\n');
fprintf('strcmp(''%s'', ''%s''): %d\n', str1, str3, str_equal);
fprintf('strcmpi(''%s'', ''APPLE''): %d\n', str1, str_equal_ignore);
fprintf('contains(''%s'', ''nan''): %d\n', str2, str_contains);

% 字符串数组比较（新版本MATLAB）
strings1 = ["apple", "banana", "cherry"];
strings2 = ["apple", "orange", "cherry"];
string_comparison = strings1 == strings2;

fprintf('字符串数组比较:\n');
fprintf('strings1: '); disp(strings1);
fprintf('strings2: '); disp(strings2);
fprintf('比较结果: '); disp(string_comparison);
```

## 🔗 逻辑运算符

### 基本逻辑运算

```matlab
% 逻辑运算符
p = true;
q = false;

% 逻辑运算
logical_and = p & q;        % 逻辑与
logical_or = p | q;         % 逻辑或
logical_not_p = ~p;         % 逻辑非
logical_not_q = ~q;

fprintf('逻辑运算 (p=%d, q=%d):\n', p, q);
fprintf('p & q: %d\n', logical_and);
fprintf('p | q: %d\n', logical_or);
fprintf('~p: %d\n', logical_not_p);
fprintf('~q: %d\n', logical_not_q);

% 短路逻辑运算符
short_circuit_and = p && q; % 短路与
short_circuit_or = p || q;  % 短路或

fprintf('\n短路逻辑运算:\n');
fprintf('p && q: %d\n', short_circuit_and);
fprintf('p || q: %d\n', short_circuit_or);
```

### 数组逻辑运算

```matlab
% 逻辑数组运算
logical_array1 = [true, false, true, false];
logical_array2 = [true, true, false, false];

% 元素级逻辑运算
array_and = logical_array1 & logical_array2;
array_or = logical_array1 | logical_array2;
array_not = ~logical_array1;

fprintf('数组逻辑运算:\n');
fprintf('array1 = [%s]\n', mat2str(logical_array1));
fprintf('array2 = [%s]\n', mat2str(logical_array2));
fprintf('array1 & array2 = [%s]\n', mat2str(array_and));
fprintf('array1 | array2 = [%s]\n', mat2str(array_or));
fprintf('~array1 = [%s]\n', mat2str(array_not));

% 逻辑数组函数
any_true = any(logical_array1);     % 任一元素为真
all_true = all(logical_array1);     % 所有元素为真
num_true = sum(logical_array1);     % 真值个数

fprintf('\n逻辑数组函数:\n');
fprintf('any(array1): %d\n', any_true);
fprintf('all(array1): %d\n', all_true);
fprintf('sum(array1): %d\n', num_true);
```

### 复合逻辑表达式

```matlab
% 复合逻辑条件
score = 85;
attendance = 0.9;
bonus_eligible = false;

% 复合条件判断
pass_grade = (score >= 60) & (attendance >= 0.8);
excellent = (score >= 90) & (attendance >= 0.95);
special_case = pass_grade | bonus_eligible;

fprintf('成绩评估 (分数=%d, 出勤率=%.1f, 奖励资格=%d):\n', ...
        score, attendance, bonus_eligible);
fprintf('及格: %d\n', pass_grade);
fprintf('优秀: %d\n', excellent);
fprintf('特殊情况: %d\n', special_case);

% 使用逻辑索引
data = [10, 25, 30, 5, 45, 15, 35];
condition = (data > 15) & (data < 40);
filtered_data = data(condition);

fprintf('\n逻辑索引示例:\n');
fprintf('原数据: [%s]\n', num2str(data));
fprintf('条件: (data > 15) & (data < 40)\n');
fprintf('筛选结果: [%s]\n', num2str(filtered_data));
```

## 🎯 位运算符

### 基本位运算

```matlab
% 位运算（适用于整数类型）
a = uint8(12);  % 二进制: 00001100
b = uint8(10);  % 二进制: 00001010

% 位运算操作
bit_and = bitand(a, b);     % 位与
bit_or = bitor(a, b);       % 位或
bit_xor = bitxor(a, b);     % 位异或
bit_not = bitcmp(a);        % 位取反
bit_shift_left = bitshift(a, 2);   % 左移
bit_shift_right = bitshift(a, -1); % 右移

fprintf('位运算 (a=%d, b=%d):\n', a, b);
fprintf('a的二进制: %s\n', dec2bin(a, 8));
fprintf('b的二进制: %s\n', dec2bin(b, 8));
fprintf('bitand(a,b) = %d (二进制: %s)\n', bit_and, dec2bin(bit_and, 8));
fprintf('bitor(a,b) = %d (二进制: %s)\n', bit_or, dec2bin(bit_or, 8));
fprintf('bitxor(a,b) = %d (二进制: %s)\n', bit_xor, dec2bin(bit_xor, 8));
fprintf('bitcmp(a) = %d (二进制: %s)\n', bit_not, dec2bin(bit_not, 8));
fprintf('bitshift(a,2) = %d\n', bit_shift_left);
fprintf('bitshift(a,-1) = %d\n', bit_shift_right);
```

### 位操作应用

```matlab
% 位掩码操作
flags = uint8(0);           % 初始化标志位

% 设置标志位
FLAG_READ = 1;      % 00000001
FLAG_WRITE = 2;     % 00000010
FLAG_EXECUTE = 4;   % 00000100

% 设置权限
flags = bitor(flags, FLAG_READ);
flags = bitor(flags, FLAG_WRITE);

fprintf('\n位掩码操作:\n');
fprintf('设置读写权限后: %d (二进制: %s)\n', flags, dec2bin(flags, 8));

% 检查权限
has_read = bitand(flags, FLAG_READ) > 0;
has_write = bitand(flags, FLAG_WRITE) > 0;
has_execute = bitand(flags, FLAG_EXECUTE) > 0;

fprintf('读权限: %d\n', has_read);
fprintf('写权限: %d\n', has_write);
fprintf('执行权限: %d\n', has_execute);

% 清除权限
flags = bitand(flags, bitcmp(FLAG_WRITE));
fprintf('清除写权限后: %d (二进制: %s)\n', flags, dec2bin(flags, 8));
```

## 📊 运算符优先级

### 优先级演示

```matlab
% 运算符优先级示例
% 从高到低优先级：
% 1. 括号 ()
% 2. 幂运算 ^, .^
% 3. 一元运算符 +, -, ~
% 4. 乘除 *, /, \, .*, ./, .\
% 5. 加减 +, -
% 6. 关系运算符 <, <=, >, >=, ==, ~=
% 7. 逻辑与 &
% 8. 逻辑或 |

% 不同优先级的表达式
expr1 = 2 + 3 * 4;          % 结果: 14 (不是 20)
expr2 = (2 + 3) * 4;        % 结果: 20
expr3 = 2 ^ 3 ^ 2;          % 结果: 512 (从右到左)
expr4 = (2 ^ 3) ^ 2;        % 结果: 64

fprintf('运算符优先级演示:\n');
fprintf('2 + 3 * 4 = %d\n', expr1);
fprintf('(2 + 3) * 4 = %d\n', expr2);
fprintf('2 ^ 3 ^ 2 = %d\n', expr3);
fprintf('(2 ^ 3) ^ 2 = %d\n', expr4);

% 逻辑运算优先级
x = 5;
logical_expr1 = x > 3 & x < 10;     % 结果: 1
logical_expr2 = x > 3 | x < 0 & x > 10; % 结果: 1

fprintf('\n逻辑运算优先级:\n');
fprintf('x = %d\n', x);
fprintf('x > 3 & x < 10 = %d\n', logical_expr1);
fprintf('x > 3 | x < 0 & x > 10 = %d\n', logical_expr2);
```

### 复杂表达式分析

```matlab
% 复杂表达式的计算顺序
a = 2; b = 3; c = 4; d = 5;

% 表达式分析
complex_expr = a + b * c ^ d / 2 - 1;

% 手动计算步骤
step1 = c ^ d;          % 4^5 = 1024
step2 = b * step1;      % 3 * 1024 = 3072
step3 = step2 / 2;      % 3072 / 2 = 1536
step4 = a + step3;      % 2 + 1536 = 1538
step5 = step4 - 1;      % 1538 - 1 = 1537

fprintf('复杂表达式分析:\n');
fprintf('a + b * c ^ d / 2 - 1 (a=%d, b=%d, c=%d, d=%d)\n', a, b, c, d);
fprintf('计算步骤:\n');
fprintf('1. c ^ d = %d ^ %d = %d\n', c, d, step1);
fprintf('2. b * step1 = %d * %d = %d\n', b, step1, step2);
fprintf('3. step2 / 2 = %d / 2 = %d\n', step2, step3);
fprintf('4. a + step3 = %d + %d = %d\n', a, step3, step4);
fprintf('5. step4 - 1 = %d - 1 = %d\n', step4, step5);
fprintf('最终结果: %d\n', complex_expr);
fprintf('验证: %d\n', complex_expr == step5);
```

## 🔍 特殊运算符和函数

### 赋值运算符

```matlab
% 基本赋值
x = 10;                     % 简单赋值
[a, b, c] = deal(1, 2, 3); % 多重赋值

fprintf('赋值运算:\n');
fprintf('x = %d\n', x);
fprintf('[a, b, c] = [%d, %d, %d]\n', a, b, c);

% 数组赋值
array = [1, 2, 3, 4, 5];
array(3) = 10;              % 单个元素赋值
array([1, 5]) = [100, 500]; % 多个元素赋值

fprintf('数组赋值后: [%s]\n', num2str(array));

% 条件赋值
condition = true;
result = condition * 10 + ~condition * 20;  % 条件赋值的技巧
fprintf('条件赋值结果: %d\n', result);
```

### 索引运算符

```matlab
% 索引运算
matrix = magic(4);

% 不同的索引方式
element = matrix(2, 3);              % 单个元素
row = matrix(2, :);                  % 整行
column = matrix(:, 3);               % 整列
submatrix = matrix(1:2, 2:3);       % 子矩阵
diagonal = diag(matrix);             % 对角线

fprintf('索引运算示例:\n');
fprintf('原矩阵:\n'); disp(matrix);
fprintf('matrix(2,3) = %d\n', element);
fprintf('matrix(2,:) = [%s]\n', num2str(row));
fprintf('matrix(:,3) = [%s]\n', num2str(column));
fprintf('matrix(1:2,2:3) =\n'); disp(submatrix);
fprintf('diag(matrix) = [%s]\n', num2str(diagonal'));

% 逻辑索引
logical_index = matrix > 10;
elements_gt_10 = matrix(logical_index);

fprintf('matrix > 10的元素: [%s]\n', num2str(elements_gt_10'));
```

### 冒号运算符

```matlab
% 冒号运算符的多种用法
range1 = 1:5;               % 步长为1
range2 = 0:0.5:3;           % 指定步长
range3 = 10:-2:0;           % 递减序列

fprintf('冒号运算符:\n');
fprintf('1:5 = [%s]\n', num2str(range1));
fprintf('0:0.5:3 = [%s]\n', num2str(range2));
fprintf('10:-2:0 = [%s]\n', num2str(range3));

% 冒号在矩阵操作中的应用
A = reshape(1:12, 3, 4);
column_vectorized = A(:);   % 将矩阵变为列向量
all_elements = A(:)';       % 所有元素的行向量

fprintf('\n冒号在矩阵中的应用:\n');
fprintf('原矩阵 A:\n'); disp(A);
fprintf('A(:) (列向量): [%s]\n', num2str(column_vectorized'));
```

## 🧮 表达式求值优化

### 向量化运算

```matlab
% 向量化 vs 循环
n = 10000;
x = 1:n;

% 方法1: 循环计算
tic;
result_loop = zeros(1, n);
for i = 1:n
    result_loop(i) = sin(x(i))^2 + cos(x(i))^2;
end
time_loop = toc;

% 方法2: 向量化计算
tic;
result_vectorized = sin(x).^2 + cos(x).^2;
time_vectorized = toc;

fprintf('向量化运算优化:\n');
fprintf('循环方法耗时: %.6f秒\n', time_loop);
fprintf('向量化方法耗时: %.6f秒\n', time_vectorized);
fprintf('性能提升: %.1f倍\n', time_loop / time_vectorized);
fprintf('结果验证: %d (应该为1)\n', all(abs(result_loop - result_vectorized) < 1e-10));
```

### 短路求值应用

```matlab
% 短路求值在条件检查中的应用
function result = safe_divide(a, b)
    % 使用短路求值避免除零错误
    if b ~= 0 && a / b > 1
        result = a / b;
    else
        result = 0;
    end
end

% 测试短路求值
test_cases = [
    10, 5;      % 正常情况
    10, 0;      % 除零情况
    5, 10       % 结果小于1的情况
];

fprintf('\n短路求值应用:\n');
for i = 1:size(test_cases, 1)
    a = test_cases(i, 1);
    b = test_cases(i, 2);
    result = safe_divide(a, b);
    fprintf('safe_divide(%d, %d) = %.2f\n', a, b, result);
end
```

## 🎯 实际应用示例

### 数据筛选和处理

```matlab
% 学生成绩数据处理示例
student_scores = [85, 92, 78, 96, 84, 89, 91, 77, 83, 94];
student_names = {'Alice', 'Bob', 'Charlie', 'Diana', 'Eve', ...
                'Frank', 'Grace', 'Henry', 'Ivy', 'Jack'};

% 使用运算符进行数据分析
high_achievers = student_scores >= 90;
low_achievers = student_scores < 80;
average_range = (student_scores >= 80) & (student_scores < 90);

% 统计信息
num_high = sum(high_achievers);
num_low = sum(low_achievers);
num_average = sum(average_range);

fprintf('学生成绩分析:\n');
fprintf('总学生数: %d\n', length(student_scores));
fprintf('高分学生 (≥90): %d人\n', num_high);
fprintf('低分学生 (<80): %d人\n', num_low);
fprintf('中等学生 (80-89): %d人\n', num_average);

% 显示各类别学生名单
high_achiever_names = student_names(high_achievers);
fprintf('\n高分学生名单:\n');
for i = 1:length(high_achiever_names)
    idx = find(high_achievers);
    fprintf('  %s: %d分\n', high_achiever_names{i}, student_scores(idx(i)));
end
```

### 矩阵运算综合应用

```matlab
% 线性方程组求解示例
% 3x + 2y + z = 7
% 2x + y + 3z = 8
% x + 3y + 2z = 9

% 系数矩阵和常数向量
A = [3, 2, 1; 2, 1, 3; 1, 3, 2];
b = [7; 8; 9];

% 求解方法1: 矩阵左除
solution1 = A \ b;

% 求解方法2: 逆矩阵
solution2 = inv(A) * b;

% 验证解的正确性
verification = A * solution1;

fprintf('\n线性方程组求解:\n');
fprintf('系数矩阵 A:\n'); disp(A);
fprintf('常数向量 b: [%s]\n', num2str(b'));
fprintf('解 (方法1): [%.4f, %.4f, %.4f]\n', solution1);
fprintf('解 (方法2): [%.4f, %.4f, %.4f]\n', solution2);
fprintf('验证 A*x: [%.4f, %.4f, %.4f]\n', verification);
fprintf('误差: %.2e\n', norm(verification - b));
```

---

> **运算符与表达式总结**：MATLAB的运算符系统支持从简单的算术运算到复杂的矩阵运算。理解不同运算符的特点、优先级和适用场景，正确使用向量化运算，可以显著提高代码的效率和可读性。掌握这些运算符是编写高效MATLAB程序的基础。

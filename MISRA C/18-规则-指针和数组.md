# 指针和数组

在C语言中，指针和数组紧密相关，但它们之间存在微妙的差别。指针算术是强大但易错的。

## 规则 18.1：指针算术不应在非数组对象上执行

- 必须

指针的加减运算只有在指针指向一个数组中的元素时才有明确定义。对一个指向单个对象（非数组）的指针进行算术运算，会导致未定义行为。

## 规则 18.2：指针减法的结果应只与 `==` 或 `!=` 进行比较

- 必须

两个指向同一数组元素的指针相减，结果是一个 `ptrdiff_t` 类型的值，表示它们之间的元素数量。这个结果不应与除了0之外的任何算术值进行比较，因为其大小是实现定义的。通常只用于检查两个指针是否指向同一位置。

## 规则 18.3：指针算术的结果应指向同一数组

- 必须

对指针进行算术运算后，结果指针必须仍然指向原来那个数组的内部，或者指向数组末尾的下一个位置。任何导致指针越出这个范围的运算（包括越出数组头部之前的位置）都会导致未定义行为。

## 规则 18.4：关系运算符不应用于不同数组中的指针

- 必须

`<`, `<=`, `>`, `>=` 等关系运算符只能用于比较指向同一个数组元素的指针。用它们来比较指向不同数组或对象的指针，其结果是未指定的。

## 规则 18.5：数组声明不应使用可变长度数组（VLA）

- 必须

可变长度数组（C99引入）的大小在运行时确定，这使得静态分析变得困难，并可能导致栈溢出。在安全关键系统中，应使用固定大小的数组或动态内存分配。

## 规则 18.6：指针不应指向已释放的内存

- 必须

当一块内存通过 `free()` 或类似函数被释放后，任何指向该内存区域的指针（悬挂指针）都变得无效。解引用或使用这些指针会导致未定义行为。

## 规则 18.7：柔性数组成员不应在结构体或联合体中使用

- 必须

C99引入的柔性数组成员（flexible array member）允许结构体的最后一个成员是一个大小未定的数组。这个特性在内存管理上容易出错，并且与许多静态分析工具不兼容。

## 规则 18.8：指针的算术运算不应导致回绕

- 建议

即使指针运算的结果仍在数组的有效范围内，如果中间计算过程发生了整数回绕（wrap-around），也可能导致问题。应确保指针运算的中间结果和最终结果都是有效的。

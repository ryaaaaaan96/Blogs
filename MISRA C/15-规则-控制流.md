# 控制流

程序的控制流应该是清晰和结构化的，以避免出现难以理解和维护的代码路径。

## 规则 15.1：`goto` 语句不应被使用

- 必须

`goto` 语句可以创建非结构化的控制流（俗称“意大利面条式代码”），使得程序的执行路径难以跟踪和分析。应使用 `if-else`、`switch`、`for`、`while` 等结构化语句来代替。

## 规则 15.2：`goto` 语句不应跳转到更深层嵌套的作用域

- 必须

即使在允许使用 `goto` 的极少数情况下（例如跳出多层循环），`goto` 也不应向前跳转，跳过变量的初始化。这样做会导致程序跳转到一个尚未完成初始化的代码块中，访问未初始化的变量将导致未定义行为。

## 规则 15.3：`goto` 语句的目标标签应在同一函数内

- 必须

C语言本身就禁止 `goto` 跳转到其他函数中。此规则重申了这一点，以防止任何非标准的编译器扩展。

## 规则 15.4：一个函数中最多只能有一个 `return` 语句

- 建议

一个函数有多个退出点（`return` 语句）会使函数的控制流变得复杂，难以确保在所有退出路径上都能正确地执行清理工作（如释放资源）。建议函数只有一个单一的退出点，通常在函数的末尾。

## 规则 15.5：函数不应包含不可达代码

- 必须

在 `return`、`break`、`continue`、`goto` 或无限循环之后的代码是永远不会被执行的。这种不可达代码（dead code）通常表明存在逻辑错误或代码编写失误，应被移除。

## 规则 15.6：循环体和 `if`、`else` 子句应为复合语句

- 必须

`if`、`else`、`while`、`for`、`do-while` 的主体部分必须是一个用花括号 `{...}` 包围的复合语句，即使它只包含一条语句。这可以防止在后续修改中因忘记添加花括号而引入的“悬挂 `else`”等经典错误。

## 规则 15.7：所有 `if ... else if` 结构都应以 `else` 子句结尾

- 必须

一个 `if ... else if ...` 链应该总是以一个最终的 `else` 子句结束。这个 `else` 子句用于处理所有未被前面条件覆盖到的情况。即使你认为所有情况都已被覆盖，也应保留一个 `else` 子句（可能用于断言或错误处理），以捕获预料之外的值。

# 预处理指令

预处理器是C语言编译过程的第一步，它的指令（如 `#include`, `#define`, `#if`）虽然强大，但也极易被滥用，导致代码难以阅读和调试。

## 规则 20.1：`#include` 指令应只用于包含头文件

- 必须

`#include` 指令应该只被用来包含 `.h` 后缀的头文件。不应使用它来包含 `.c` 源代码文件，因为这会破坏模块化并可能导致多重定义错误。

## 规则 20.2：`#include` 的文件名应使用 `<...>` 或 `"...`"` 形式

- 必须

包含标准库头文件时应使用 `<filename.h>` 的形式，包含项目自定义的头文件时应使用 `"filename.h"` 的形式。混合使用或使用其他形式可能导致可移植性问题。

## 规则 20.3：`#include` 指令不应在文件作用域之外使用

- 必须

`#include` 指令应该只出现在文件的顶层，即在任何函数或变量定义之外。在函数内部或代码块中包含头文件会使依赖关系变得混乱。

## 规则 20.4：宏定义不应包含不平衡的括号

- 必须

在定义宏时，所有的左括号 `(` 都必须有对应的右括号 `)`，反之亦然。不平衡的括号会导致难以追踪的语法错误。

## 规则 20.5：`#undef` 不应被使用

- 建议

`#undef` 用于取消一个宏的定义。使用 `#undef` 会使宏的定义状态在代码的不同位置发生变化，降低了代码的可预测性和可读性。应避免使用它。

## 规则 20.6：`#define` 或 `#undef` 不应出现在复合语句中

- 必须

宏的定义和取消定义应该在文件顶层进行，而不是在函数或代码块的内部。在块作用域内定义宏会严重影响代码的清晰度。

## 规则 20.7：类函数宏的参数不应在宏展开时被多次求值

- 必须

如果一个类函数宏（function-like macro）的参数在宏的替换体中出现了多次，并且调用时传入的实参带有副作用（如 `SQUARE(i++)`），那么这个副作用可能会被执行多次，导致未定义行为。

## 规则 20.8：类函数宏的参数列表不应为空

- 建议

如果一个宏的行为像函数但不需要参数，最好将其定义为对象式宏（object-like macro），而不是一个空的参数列表 `()` 的类函数宏，以避免混淆。

## 规则 20.9：类函数宏的参数不应包含或展开为预处理指令

- 必须

传递给宏的参数不应包含 `#` 或 `##` 等预处理操作符，也不应展开后形成预处理指令。

## 规则 20.10：`##` 预处理操作符不应被使用

- 建议

`##` 操作符（token pasting）用于在宏展开时将两个词法单元（token）连接成一个。这个特性非常强大但也很晦涩，容易产生难以理解和调试的代码。

## 规则 20.11：宏参数应在宏替换体中被括号包围

- 必须

在类函数宏的定义中，每个参数在替换体中出现时都应该被一对括号包围，以避免因运算符优先级问题导致的错误。例如，`#define SQUARE(x) (x)*(x)`。

## 规则 20.12：类函数宏的展开体应被括号包围

- 必须

整个类函数宏的替换体也应该被一对括号包围，以确保宏在更复杂的表达式中能被正确地求值。例如，`#define ADD(x, y) ((x) + (y))`。

## 规则 20.13：`#` 和 `##` 预处理操作符的结果应形成有效的词法单元

- 必须

当使用 `#`（stringizing）或 `##`（pasting）操作符时，必须确保其结果是一个合法的C语言词法单元。

## 规则 20.14：所有 `if`、`elif` 分支都应是合法的预处理指令

- 必须

在 `#if` 或 `#elif` 条件编译块中，即使某个分支的条件为假，其中的代码也必须是语法上完整的预处理指令。

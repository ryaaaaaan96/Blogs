# 字符集和词法约定

## 规则 4.1：只应使用可移植的字符和转义序列

- 建议

源代码应仅限于基本的96个字符的源字符集。在字符串或字符常量中使用的转义序列也应是可移植的。这可以防止在不同编译器或环境中出现未定义或实现定义的行为。

## 规则 4.2：不得使用Trigraph（三元符）

- 必须

Trigraph序列（例如 `??=` 表示 `#`）是为了在缺少某些字符的旧系统上编写C代码而设计的。现代系统已不再需要它们，并且它们会降低代码的可读性。使用Trigraph可能会导致代码混淆，应被禁止。

## 规则 5.1：外部标识符应是唯一的

- 必须

在链接时，某些编译器可能会截断长标识符，导致名称冲突。因此，外部标识符（如全局变量和函数名）必须是唯一的，以避免链接错误和意外行为。

## 规则 5.2：内部作用域中的标识符不应隐藏外部作用域中的标识符

- 必须

在嵌套的代码块中，如果内部作用域的变量名与外部作用域的变量名相同，会隐藏外部变量，导致可读性下降和潜在的编程错误。

## 规则 5.3：typedef名称应是唯一的标识符

- 必须

`typedef` 创建的类型别名在整个命名空间中必须是唯一的，以防止类型混淆和代码误解。

## 规则 5.4：标签名称应是唯一的标识符

- 必须

结构体（`struct`）、联合体（`union`）和枚举（`enum`）的标签名称在同一作用域内必须唯一，以避免定义冲突。

## 规则 5.6：不得将关键字用作标识符

- 必须

C语言的关键字（如 `if`, `while`, `int`）有特殊含义，不能用作变量名、函数名或其他标识符，否则会导致编译错误。

## 规则 5.7：不得重用标识符名称

- 必须

在同一作用域内，一个标识符不应被用于多种目的（例如，同时作为变量名和`typedef`名），这会引起混淆。

## 规则 5.8：标识符不应仅因字符大小写而不同

- 建议

创建仅大小写有别的标识符（如 `myVar` 和 `myvar`）会降低代码的可读性，并可能导致错误，尤其是在不区分大小写的系统中。

## 规则 5.9：标识符的有效字符数不应超过31个

- 建议

尽管C99标准要求编译器至少支持63个字符的标识符，但为了保证在不同编译器和链接器之间的可移植性，建议将标识符的有效长度限制在31个字符以内。

## 规则 6.1：位域应使用适当的类型声明

- 必须

位域（Bit-fields）只能声明为 `unsigned int` 或 `signed int`。使用其他类型（如 `char` 或 `short`）可能导致实现定义的行为。

## 规则 6.2：单比特位域不得为有符号类型

- 必须

一个单比特的位域只能表示0和1，如果声明为 `signed`，其行为是实现定义的。因此，单比特位域应始终为 `unsigned`。

## 规则 7.1：不得使用八进制常量

- 必须

以 `0` 开头的整型常量是八进制表示法。这很容易与十进制混淆（例如 `010` 是8而不是10），因此应避免使用，除非用于表示文件权限等特殊情况。

## 规则 7.2：无符号整型常量应使用 'u' 或 'U' 后缀

- 必须

所有无符号类型的整型常量都应明确添加 `u` 或 `U` 后缀，以避免在表达式中发生意外的类型转换。

## 规则 7.3：字面量后缀不得使用小写 'l'

- 必须

小写字母 `l` 很容易与数字 `1` 混淆，因此在指定长整型（`long`）或长双精度浮点型（`long double`）时，应始终使用大写 `L`。

## 规则 7.4：字符串字面量只能赋给指向const限定char的指针

- 必须

字符串字面量在C语言中是不可修改的（存储在只读内存区域）。将其赋给一个普通的 `char *` 指针可能会导致在试图修改字符串时发生未定义行为。因此，应始终使用 `const char *`。

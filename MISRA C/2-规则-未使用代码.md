# 无意义代码

## 2.1程序不应该包含不可到达代码

- 必须

1. return后还有代码，永远没法执行。
2. 循环条件导致无法执行的代码

>时为了处理异常情况，会插入看似不可达的代码。例如在 switch 语句中，当控制表达式的所有可能值都被显式的 case 覆盖时，按照 Rule 16.4 的要求，应提供 default 子句 。该子句用于捕获异常值，比如程序中的未定义行为或处理器硬件故障导致的异常情况。若编译器判定 default 子句不可达并将其移除，可能会消除这种防御性机制。此时，需要证明编译器不会移除该代码（这可能需要对目标代码进行审查或通过单元测试来支持），或者采取措施使防御性代码变为可达，例如通过 volatile 访问来实现。

## 2.2项目中不应包含死代码

- 必须

死代码指那些**被执行**但**删除后不会影响程序行为**的操作。需要注意的是，不可达代码（由于程序逻辑导致永远无法执行的代码）不属于死代码，因为它们根本无法被执行。例如在一个函数中，有一段代码在return语句之后，这段代码就是不可达代码，而非死代码；而如果一个变量赋值后从未被使用，这个赋值操作就可能是死代码。

死代码的存在可能暗示程序逻辑存在错误。而且，由于编译器可能会删除死代码，这可能会导致代码审查时的混淆，因为审查人员看到的代码和实际执行的代码可能不一致。例如，开发人员可能以为某段代码会执行某些操作，但实际上由于它是死代码被编译器删除了。

>将值强制转换为void类型的操作被认为是有意不使用该值，这种情况不属于死代码。例如(void)v是合规的，因为它明确表示对v的使用只是为了其副作用（如果有），而不是为了获取其值。

## 2.3项目中不应包含未使用的类型声明

- 建议

“未使用的类型声明” 指已定义但未在项目中任何位置被引用的类型，包括typedef定义的类型、结构体、联合体或枚举类型等。

## 2.4项目不应该包含未使用的标签声明

- 建议

标签声明在 C 语言中用于标识结构体、联合体或枚举类型等。当一个标签被声明但在整个项目中都未被使用时，就会违反这条规则。这可能会使代码阅读者产生困惑，难以判断该标签是冗余的，还是由于疏忽而未被使用。

## 2.5项目中不应包含未使用的宏声明

- 建议

宏是 C 语言中一种预处理机制，用于定义常量、函数式宏等。当一个宏被声明但在整个项目中都未被使用时，就违反了这条规则。这可能会导致代码的可读性变差，增加代码维护的难度，因为阅读代码的人需要判断这些未使用的宏是无用代码还是未来可能会用到的代码。

## 2.6函数中不应存在未使用的标签声明（label declarations）

- 建议

未使用的标签可能是冗余代码，也可能是开发过程中遗漏的逻辑，会影响代码的可读性和可维护性。开发者难以区分标签是无意遗留还是故意保留，增加了代码理解难度。

标签需通过 goto 语句显式引用才视为 “被使用”；
即使标签在条件分支中未执行，只要存在引用（如 goto label;），则不违反本规则；
本规则仅适用于函数内部的标签，全局范围的标签不适用。

## 2.7函数中不应存在未使用的参数

- 建议

大多数函数的设计预期会使用其声明的每个参数。未使用的参数可能表明函数实现与设计规格不匹配（例如参数定义错误、逻辑遗漏等），增加代码理解和维护难度 。

“未使用” 的判定：参数未在函数体内以任何形式被引用（包括读取、传递给其他函数等）；

例外场景：若参数为了兼容性（如回调函数接口）或未来扩展而保留，需通过注释明确说明，但仍建议尽量移除未使用参数以保持代码简洁；

分析范围：规则可在单个翻译单元内通过静态分析工具检查，无需跨文件验证 。

# 指令

## 编译器

### 任何程序输出所依赖的编译器定义行为都**必须**被文档化并被理解

见附录，分析了C90和C99未定义行为（由编译器定义的行为）

常见的一些行为如下：

1. 如何识别翻译过程中产生的诊断消息；
2. 函数 main 的类型，在独立实现中通常声明为 void main (void)；
3. 标识符中的有效字符数量 - 用于配置分析工具以符合规则 5.2；
4. 源字符集和执行字符集；
5. 整数类型的大小；
6. `# include` 的名称如何映射到文件名并在主机文件系统中定位。

#### 扩展

> 嵌入式
>
>嵌入式系统中经常使用扩展来提供对外部设备的访问，以及将对象放置到具有特殊属性的内存区域，例如 Flash EEPROM 或快速访问 RAM。符合标准的实现允许提供扩展，只要这些扩展不改变任何严格符合标准的程序的含义。一些 C90 实现可能提供实现 C99 特性子集的扩展。

编译器提供扩展的一些方法包括：

1. `# pragma` 预处理指令或 _Pragma 运算符（仅 C99）；
2. 新关键字。

#### 标准库

1. errno 值的分配：标准库中的 errno 实现是根据编译器来决定的，若程序依赖这些 errno 值进行错误处理，必须在文档中明确记录所使用标准库的具体 errno 分配规则，确保开发人员理解并正确处理这些行为。
2. clock 和时间函数的实现：clock 函数及其他时间相关函数的具体实现是另一个重要方面。这些函数的行为（如时间测量的精度、计时起点的定义等）可能因标准库实现的不同而存在差异，在依赖时间控制的关键系统中，这种差异可能导致程序行为的不确定性。
3. 文件系统的特性：标准库所涉及的文件系统特性也需要重点关注。例如文件操作的权限管理、文件路径的解析规则、文件读写的缓冲机制等，不同的文件系统实现可能会有不同的行为表现，这对涉及文件操作的关键系统的稳定性和可靠性至关重要。

#### 应用二进制接口（编译器提供的一组规范，用于实现不同代码之间的二进制级兼容与交互）

在临界系统的 C 语言使用场景中，有时需要将 C 代码与汇编语言接口（例如为了在关键位置提高执行速度），也可能需要将不同编译器（可能针对不同语言）生成的代码进行接口连接。

编译器的应用二进制接口（ABI）提供了执行此类任务所需的信息，包括一些实现定义行为。它通常规定以下内容：

- 函数参数如何在寄存器和栈上传递；
- 函数值如何返回；
- 哪些寄存器必须由函数保留；
- 具有自动存储期的对象如何分配到栈帧；
- 每种数据类型的对齐要求；
- 结构如何布局以及位域如何分配到存储单元。

一些处理器有标准的 ABI，所有实现都会使用。如果没有标准 ABI，实现将提供自己的 ABI。

#### 整数除法（Integer division）

在 C90 中，当有符号整数除法或取余运算中任一操作数为负值时，结果可能向下舍入或向零舍入。而在 C99 中，规定此类运算的舍入方向保证为向零舍入。

#### 浮点实现

浮点类型的实现会对程序行为产生重大影响，例如：

- 浮点值的范围和存储精度；
- 浮点运算后的舍入方向；
- 转换为较窄浮点类型或整数类型时的舍入方向；
- 下溢、上溢和非数值（NaNs）情况下的行为；
- 域错误和范围错误时库函数的行为。

## 编译和构建

### 所有源文件的编译不能有任何错误

符合标准的编译器允许在存在编译错误的情况下生成目标模块，但由此产生的程序执行时可能会出现不可预期的行为。因此，必须确保源文件编译过程无错误，以避免后续运行阶段的潜在风险。

## 需求可追踪

### 所有代码都应可追溯到已文档化的需求

不需要满足项目需求的功能会产生不必要的代码路径。
软件开发人员可能没有意识到这种额外功能可能带来的更广泛影响。例如，开发人员可能会添加代码，使得每次程序执行到特定位置时，就切换处理器输出引脚的状态。这在开发阶段可能非常有用，可用于测量时序或触发仿真器、逻辑分析仪。然而，尽管该引脚可能因未在软件需求规范中提及而看似未被使用，但在目标控制器中，它可能与执行器相连，从而导致不必要的外部效应。

代码追溯到已文档化需求的方法由项目决定。实现可追溯性的一种方法是，根据已对照需求审核过的相应设计文档，对代码进行审核。

注：本指南与保护性编码策略的规定不应存在冲突，因为在临界系统中，保护性编码策略应成为需求的一部分。

## 代码设计

### 最小化运行时故障

适用于 C90 和 C99 标准。这一要求的核心目标是通过主动预防和控制潜在风险，减少程序在运行过程中发生错误的可能性。

#### 原因

C 语言的设计哲学强调生成紧凑、高效的机器码，但代价是内置的运行时检查非常有限。例如，C 程序通常不会自动检查算术异常（如除零）、溢出、指针有效性或数组边界错误等常见问题，而是将这些检查的责任完全交给程序员。因此，为实现高可靠性，程序员必须在**可能发生运行时错误的地方主动添加动态检查**。

#### 常用场景

- 算数错误 ：算术表达式求值中的溢出、下溢、除零或移位导致的有效位丢失。对于无符号整数运算，虽然严格来说不会 “溢出” 而是按模运算 wrap around，但仍需关注其可能产生的非预期值。

- 指针算术：确保动态计算的地址合理且指向有意义的位置，特别是指针递增或修改后仍需指向同一数组内。

- 数组边界错误：用数组索引前，需检查索引是否在数组大小范围内（参考 Rule 18.1），在调用前确保数组大小匹配，或在函数内部添加动态大小检查（如通过额外参数传递实际大小）

- 函数参数：调用库函数前需检查参数有效性

- 指针解引用：除非指针已确定为非 NULL，否则解引用前需进行运行时检查。跨函数边界时更需谨慎，尤其是调用其他源文件或库中的函数时。

- 动态内存分配：若使用动态内存分配，必须检查每次分配是否成功，并设计适当的降级或恢复策略。

#### 流程要求

需规划并记录用于最小化运行时故障的技术，例如：

设计标准
测试计划
静态分析配置文件
代码审查清单

具体技术需根据项目的完整性要求确定（详见 Section 5.2）。

### 4.2 汇编语言使用要记录

所有汇编语言的使用都应被记录，属于 “Advisory”（**建议性**）准则，适用于 C90 和 C99 标准。其核心目标是通过规范文档记录，提高汇编语言使用的可追溯性和可维护性。

#### 文档记录内容

使用汇编语言的理由：需明确说明为何必须使用汇编语言（例如为了访问特定硬件外设、优化关键路径执行速度等）。

C 语言与汇编语言的接口机制：需详细描述两者之间的交互方式，包括函数调用约定、参数传递方式、寄存器使用规则、内存访问约定等。

>汇编语言代码具有实现定义性，其行为依赖于具体的处理器架构和编译器实现，因此可移植性较差。通过强制记录汇编语言的使用场景和接口机制，能够帮助开发人员和维护人员理解代码意图，减少因汇编语言使用不当导致的错误，同时为后续的代码审查、测试和移植提供依据。

### 4.3汇编语言应被封装和隔离

属于 “Required”（**强制性**）准则，适用于 C90 和 C99 标准。这一要求旨在通过规范汇编语言的使用方式，降低其对整体代码可维护性和安全性的影响。

#### 方式

根据准则要求，汇编语言指令的使用必须被封装和隔离在以下形式中：

汇编语言函数：将汇编代码独立编写为函数，通过函数调用与 C 代码交互。
C 函数（C99 优先使用内联函数）：在 C 函数内部嵌入汇编指令，利用函数的封装性限制汇编代码的作用范围。
C 宏：通过宏定义封装汇编指令，使汇编代码的调用像普通宏一样简洁，同时便于集中管理。

#### 封装和隔离汇编语言的核心原因包括

1. 提高可读性：封装后的汇编代码通过函数名或宏名清晰表达意图，减少对汇编语法的直接依赖。

2. 增强可维护性：所有用于特定目的的汇编语言可共享同一封装，修改时只需调整一处实现。

3. 便于移植和静态分析：汇编语言与硬件架构紧密相关，封装后可在不同目标平台上轻松替换实现；同时，隔离的形式也便于静态分析工具处理。

### 4.4代码段不应被 “注释掉”

属于 “Advisory”（**建议性**）准则，适用于 C90 和 C99 标准。该准则明确禁止使用 `/*...*/` 或 `//` 风格的注释来屏蔽代码段，旨在避免因注释嵌套或误操作导致的代码逻辑错误。

#### 风险原因

1. 注释嵌套问题：C 语言不支持嵌套注释，若被注释的代码中已有 /* 标记，会导致外层注释提前结束，未被预期的代码可能被执行。
2. 代码逻辑混乱：注释掉的代码可能被遗忘或误恢复，影响代码可读性和维护性，增加调试难度。

#### 推荐方案

准则建议使用条件编译替代注释来屏蔽代码，例如通过 #if、#ifdef 等预处理指令，并配合注释说明原因。

### 4.5同一命名空间中具有重叠可见性的标识符应在字形上明确区分

在同一命名空间中具有重叠可见性的标识符应在字形上明确区分，属于 “Advisory”（**建议性**）准则，适用于 C90 和 C99 标准。其核心目标是避免因标识符字形相似而导致的开发混淆和错误。

#### 实施要求

项目应根据源代码所使用的字母表和语言，确定 “明确区分” 的具体标准。对于英语中使用的拉丁字母表，准则明确建议至少应避免标识符因以下任意组合而产生差异：

- 小写字母与其大写等效字母的互换（如 abc 与 - ABC）；
- 下划线字符的存在或缺失（如 my_var 与 - myvar）；
- 字母 “O” 与数字 “0” 的互换；
- 字母 “I” 与数字 “1” 的互换；
- 字母 “I” 与字母 “l”（小写 L）的互换；
- 字母 “l”（小写 L）与数字 “1” 的互换；
- 字母 “S” 与数字 “5” 的互换；
- 字母 “Z” 与数字 “2” 的互换；
- 字母 “n” 与字母 “h” 的互换；
- 字母 “B” 与数字 “8” 的互换；
- 字母序列 “rn”（“r” 后接 “n”）与字母 “m” 的互换。

### 4.6应使用指示大小和符号性的 typedef 替代基本数值类型

应使用指示大小和符号性的 typedef 替代基本数值类型，属于 “Advisory”（**建议性**）准则，适用于 C90 和 C99 标准。其核心目标是通过明确类型的大小和符号属性，提高代码的可移植性和可读性，减少因基本类型大小不确定导致的错误。

#### 实施方案

禁止使用的基本数值类型：char、short、int、long、long long（C99）、float、double 和 long double。

推荐使用的类型：
对于 C99，应使用 <stdint.h> 中定义的特定长度类型（如 uint8_t、int16_t 等）。
对于 C90，应定义并使用等效的特定长度 typedef（如通过 typedef signed char int8_t; 等方式）。

>在内存分配至关重要的场景中，使用特定长度类型能清晰表明每个对象的存储占用大小。尽管遵循此准则不能完全保证可移植性（例如整数提升行为仍依赖 int 类型的实际大小），但能显著减少因类型大小不确定导致的移植问题。此外，避免定义大小与实际不符的类型，可防止存储需求和移植性方面的问题。
>
>若抽象类型基于特定长度类型定义，则无需在抽象类型中指定大小或符号。例如：typedef uint16_t mass_kg_t;，其中 mass_kg_t 无需显式体现大小。
>
>与标准库或项目控制外的代码交互时，可不受此准则限制。

### 4.7若函数返回错误信息，则该错误信息必须被测试

如果函数返回错误信息，那么该错误信息必须被测试，属于 “Required”（**强制性**）准则，适用于 C90 和 C99 标准。其核心目标是确保函数返回的错误状态得到妥善处理，避免因未检测错误而导致的程序异常或不可靠行为。

#### 核心要求

该准则适用于所有返回错误信息的函数，无论这些函数是标准库函数、第三方库函数还是用户自定义函数。项目需明确界定哪些函数属于 “返回错误信息的函数”。

错误信息的测试方式：对函数返回的错误信息的测试必须具有实际意义，即需根据错误类型采取相应的处理逻辑，而非形式化的无效检查。

例外情况：若能通过参数检查等方式证明函数不可能返回错误（例如提前验证输入参数的有效性，确保函数调用满足成功条件），则无需对该函数的错误信息进行测试。

### 4.8若指向结构体或联合体的指针在翻译单元内从未被解引用，则应隐藏该对象的实现

如果指向结构体或联合体的指针在一个翻译单元内从未被解引用，那么该对象的实现应当被隐藏，属于 “Advisory”（建议性）准则，适用于 C90 和 C99 标准。其核心目标是通过隐藏未被直接访问的结构体或联合体的内部实现，保护对象内容免受无意修改，提升代码的封装性和安全性。

#### 隐藏实现方式

准则要求通过指向不完整类型的指针来隐藏对象的实现。不完整类型（incomplete type）是指未定义完整结构的类型，仅通过声明告知编译器该类型的存在，但不暴露其内部成员。

1. 在头文件中声明不完整类型和指针类型：通过 typedef 定义指向不完整结构体或联合体的指针类型，仅暴露指针接口而不公开内部成员。

2. 在源文件中定义完整类型：在单独的源文件中实现结构体或联合体的完整定义，仅在该文件内可访问其成员。

3. 通过指针接口操作对象：在其他翻译单元中，仅通过头文件中声明的指针类型使用对象，无法直接访问内部成员。

### 4.9在可互换的情况下，应优先使用函数而非函数式宏

在可互换的情况下，应优先使用函数而非函数式宏，属于 “Advisory”（建议性）准则，适用于 C90 和 C99 标准。其核心目标是通过选择更安全、易维护的函数替代函数式宏，减少宏使用带来的潜在风险。

#### 函数的优势

1. 参数类型检查：函数会对参数类型进行严格检查，而宏仅进行文本替换，可能导致类型不匹配的错误未被发现。
2. 避免多次求值副作用：函数的参数仅在调用时求值一次，而宏的参数可能在展开时被多次求值，若参数包含自增、自减等副作用操作，会导致非预期结果。
3. 调试友好性：在调试工具中，函数调用可被逐步跟踪，而宏展开后难以定位问题。

#### 宏的使用场景

宏的合理使用场景
以下情况可保留函数式宏：

需要将 C 运算符作为参数（如示例中的 EVAL_BINOP 宏，需传入 + 等运算符）；
在静态存储 duration 对象的初始化中使用（函数调用不允许用于静态初始化，而宏可展开为常量表达式）。

### 4.10必须采取预防措施，防止头文件内容被多次包含

#### 使用宏

```c
<start-of-file>
#if !defined (identifier)
#define identifier
/* 头文件内容 */
#endif
<end-of-file>
```

```c
<start-of-file>
#ifndef identifier
#define identifier
#endif
/* 头文件内容 */
<end-of-file>
```

>唯一标识符：用于保护头文件的identifier必须在整个项目中唯一，避免不同头文件使用相同标识符导致意外屏蔽。
>
>注释位置：在保护结构中允许添加注释，但需确保不影响预处理指令的逻辑。
>
>嵌套包含场景：即使头文件本身正确实现了防重复包含机制，若其他头文件嵌套包含该头文件，仍需确保整体包含逻辑正确。

#### 目的

1. 避免重复定义：头文件中通常包含类型定义、宏定义、函数声明等内容，多次包含会导致这些内容被重复编译，可能引发编译器报错（如 “重定义”）。
2. 防止符号冲突：重复包含可能导致同一符号在同一翻译单元中被多次声明或定义，引发语义歧义或未定义行为。
3. 提高编译效率：避免重复处理头文件内容，减少编译时间和资源消耗。

### 4.11 传递给库函数的参数值有效性必须被检查

传递给库函数的参数值有效性必须被检查。这一要求适用于标准库函数(`<math.h>`、`<ctype.h>`)、第三方库函数(外部供应商提供)以及内部开发(团队内部)的库函数，旨在确保库函数接收的输入参数符合其预期的有效范围，避免因无效参数导致的未定义行为或意外结果。

>C 标准库及许多其他库的函数通常不强制要求对输入参数进行有效性检查，即使部分标准要求检查，编译器或库实现也可能未充分执行。若传递无效参数，可能导致未定义行为（如程序崩溃、结果错误等）。因此，程序员必须在调用库函数前主动检查输入参数的有效性。

#### 检查位置

调用前检查：在调用库函数前，显式检查输入参数是否在有效范围内。

库函数内部检查：对于内部开发的库，在函数实现中内置参数检查逻辑。

封装函数检查：对库函数进行封装，在封装层中执行参数检查后再调用原函数。

静态证明：通过静态分析等方式证明输入参数不可能为无效值。

### 4.12禁止使用动态内存分配

1. 避免未定义行为：标准库的动态内存分配和释放函数存在多种未定义行为风险，例如释放未动态分配的内存、使用已释放的指针、访问未初始化的动态分配内存等，其他动态内存分配系统也可能存在类似问题。

2. 防止内存分配失败：动态内存分配可能因内存不足而失败，若未妥善处理这种情况，会导致程序不可预测的行为。

3. 避免执行时间不确定性：动态内存分配和释放的执行时间可能因内存碎片等因素产生较大波动，不利于实时系统的确定性设计。

#### 调用库函数内是否包含动态内存代码

项目需检查第三方库的规格说明，确保未无意中使用动态内存分配功能。
若因特殊情况必须使用动态内存，需采取严格措施确保软件行为可预测，例如制定安全的内存分配失败处理策略、评估内存碎片对执行时间的影响等。

### 4.13为资源提供操作的函数应按适当的顺序调用

为资源提供操作的函数应按适当的顺序调用。这类函数通常围绕资源的生命周期形成一组操作，需遵循特定的调用序列以确保资源使用的安全性和正确性

#### 为资源提供操作的函数集

1. 资源分配：例如打开文件（fopen）、获取互斥锁（mutex_lock）等，用于获取资源的访问权。
2. 资源释放：例如关闭文件（fclose）、释放互斥锁（mutex_unlock）等，用于释放资源以允许其他操作访问。
3. 其他操作：例如读取文件（fread）、修改资源内容等，在资源分配后、释放前执行的具体操作。

对于每一组此类函数，所有操作的调用都应遵循合理的顺序，例如 “先分配、再操作、最后释放”。

> `else`路径中增加释放操作。

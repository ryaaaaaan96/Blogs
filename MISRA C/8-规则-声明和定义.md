# 声明和定义

## 规则 8.1：函数应有原型声明，且原型在定义和调用点都可见

- 必须

在调用一个函数之前，编译器必须知道它的完整原型（返回类型和所有参数的类型）。这可以确保编译器能够检查传递的参数是否正确。函数原型应该在一个头文件中声明，并在定义该函数的`.c`文件和所有调用该函数的文件中被包含。

## 规则 8.2：函数定义应采用带命名参数的原型形式

- 必须

函数的定义必须与它的原型声明相匹配，并且应该为所有参数提供有意义的名称。这增强了代码的可读性和可维护性。

## 规则 8.3：一个对象或函数的所有声明都应使用相同的名称和类型限定符

- 必须

同一个变量或函数在不同的地方（例如在不同的文件中 `extern` 声明）声明时，其类型、名称和类型限定符（`const`, `volatile`）必须完全一致。不一致的声明会导致链接错误或未定义行为。

## 规则 8.4：定义外部链接的对象或函数时，应有兼容的声明可见

- 必须

当在一个`.c`文件中定义一个全局变量或函数时，该文件中应该包含一个声明该变量或函数的头文件。这确保了定义与声明的一致性。

## 规则 8.5：一个对象或函数在整个程序中只应有一个定义

- 必须

这是“单一定义规则”（One Definition Rule, ODR）的核心。一个具有外部链接的变量或函数（即全局的）在整个项目中只能被定义一次。多个定义会导致链接器报错。

## 规则 8.6：具有外部链接的标识符应只有一个外部定义

- 必须

这条规则与8.5类似，强调了全局标识符的唯一定义。

## 规则 8.7：如果对象或函数只在一个翻译单元中使用，应定义为内部链接

- 建议

如果一个函数或变量只在它所在的那个`.c`文件内部使用，就应该使用 `static` 关键字将其声明为内部链接。这可以避免命名空间污染，并允许链接器进行更好的优化。

## 规则 8.8：`static` 关键字应用于所有内部链接的对象和函数的声明中

- 必须

如果一个对象或函数被定义为 `static`，那么它在同一文件中的所有前向声明（forward declarations）也必须使用 `static` 关键字。

## 规则 8.9：如果对象只在一个函数中使用，应在块作用域内定义

- 建议

变量的作用域应该尽可能小。如果一个变量只被一个函数使用，它就应该被定义为该函数的局部变量（如果不需要在多次调用间保持值）或静态局部变量（如果需要保持值）。

## 规则 8.10：内联函数应声明为 `static`

- 必须

非 `static` 的内联函数（`inline`）在链接时处理方式复杂且依赖于编译器实现。为了确保行为的一致性和可预测性，所有内联函数都应声明为 `static`。

## 规则 8.11：声明外部链接的数组时，应明确指定其大小

- 建议

当在头文件中使用 `extern` 声明一个全局数组时，最好明确地指定它的大小（例如 `extern int arr[10];` 而不是 `extern int arr[];`）。这为代码的其他部分提供了更明确的接口信息。

## 规则 8.12：枚举列表中隐式指定值的枚举常量应是唯一的

- 必须

在定义一个 `enum` 时，如果没有为枚举常量显式赋值，编译器会自动赋一个比前一个大1的值。必须确保这样隐式赋值的常量不会与任何显式赋值的常量发生冲突。

## 规则 8.13：指针应尽可能指向 `const` 限定的类型

- 必须

如果一个指针指向的数据不应该被修改，那么该指针应该被声明为指向 `const` 类型（例如 `const char *p`）。这利用了编译器的类型检查来防止意外的数据修改，增强了代码的健壮性。

## 规则 8.14：不得使用 `restrict` 类型限定符

- 必须

`restrict` 是C99引入的一个类型限定符，用于告知编译器某个指针是访问一块内存区域的唯一方式，以帮助优化。然而，它的语义复杂且容易被误用，滥用 `restrict` 会导致未定义行为。因此MISRA C禁止使用它。

# 指针类型转换

指针类型转换是C语言中一个强大但危险的特性。不当的转换会破坏类型系统，导致对内存的错误解释和未定义行为。

## 规则 11.1：转换不应移除对象的 `const` 或 `volatile` 限定符

- 必须

将一个指向 `const` 或 `volatile` 限定类型对象的指针，转换为一个指向没有这些限定符的类型的指针，会破坏类型系统的保护机制。通过转换后的指针修改一个 `const` 对象，或以非预期方式访问一个 `volatile` 对象，都会导致未定义行为。

## 规则 11.2：转换不应在不兼容的指针类型之间进行

- 建议

在不相关的指针类型之间进行转换（例如，从 `int *` 转换为 `float *`）通常是错误的，因为它意味着对同一块内存区域的解释方式发生了根本改变。这种转换应被避免，除非有非常特殊且经过仔细设计的理由。

## 规则 11.3：指针不应在函数指针和任何其他类型之间进行转换

- 必须

函数指针和对象指针（如 `int *`, `void *`）在许多体系结构上具有不同的大小或表示方式。在它们之间进行转换会导致未定义行为。`void *` 可以作为通用对象指针，但不能作为通用函数指针。

## 规则 11.4：指针不应在整型和指针类型之间进行转换

- 必须

将指针转换为整数，或将整数转换为指针，其行为是实现定义的。这种转换破坏了类型安全，并且高度依赖于具体的硬件架构。唯一的例外是将整数常量 `0` 转换为空指针常量。

## 规则 11.5：指针不应转换为更严格对齐的指针类型

- 必须

将一个指针转换为一个要求更严格内存对齐的指针类型（例如，从 `char *` 转换为 `int *`），如果原始指针的地址不满足新类型的对齐要求，解引用转换后的指针将导致未定义行为（通常是硬件异常）。

## 规则 11.6：`void` 指针不应被解引用

- 必须

`void *` 是一个通用的指针类型，它可以持有任何对象指针的地址，但它不包含任何类型信息。因此，它不能被直接解引用。必须先将其显式转换回一个具体的对象指针类型，然后才能访问其指向的数据。

## 规则 11.7：指向不完整类型的指针不应被解引用

- 必须

一个不完整类型（incomplete type）是指一个已被声明但尚未被定义的类型，例如一个只声明了名称但没有定义成员的结构体。指向这种类型的指针不能被解引用，因为编译器不知道该类型的大小和结构。

## 规则 11.8：指向 `void` 的指针在转换前后不应移除 `const` 或 `volatile` 限定

- 必须

当使用 `void *` 作为中介进行指针转换时（例如 `T1* -> void* -> T2*`），如果在转换过程中丢失了 `const` 或 `volatile` 限定符，就违反了类型安全。

## 规则 11.9：空指针常量 `NULL` 不应被定义为非 `void *` 类型

- 必须

宏 `NULL` 应该被定义为 `(void *)0`。将其定义为普通的 `0` 或 `0L` 可能会在函数重载（C++）或与非指针类型比较时引起歧义和错误。

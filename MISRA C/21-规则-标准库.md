# 标准库

C标准库提供了大量有用的函数，但在安全关键系统中，对标准库的使用必须加以限制，因为其中一些函数的行为是实现定义的、未定义的，或者可能导致安全漏洞。

## 规则 21.1：标准库宏、对象或函数不应被隐藏或重定义

- 必须

禁止定义与C标准库中的任何标识符（宏、类型、函数名等）同名的标识符。这样做会覆盖标准库的功能，导致不可预测的行为。

## 规则 21.2：标准库头文件中定义的宏不应被 `#undef`

- 必须

不应使用 `#undef` 来取消标准库头文件中定义的任何宏。这会改变标准库的行为，破坏代码的可移植性和正确性。

## 规则 21.3：标准库中的内存分配和释放函数不应被使用

- 必须

动态内存分配函数，如 `malloc`, `calloc`, `realloc`, `free`，在许多高完整性系统中是被禁止的。动态内存分配的行为（如分配时间、碎片化）难以预测，可能导致内存耗尽、内存泄漏等严重问题。应使用静态内存分配。

## 规则 21.4：标准库中的 `setjmp` 和 `longjmp` 函数不应被使用

- 必须

`<setjmp.h>` 中定义的 `setjmp` 和 `longjmp` 提供了一种非本地跳转（non-local goto）的机制。这种机制会严重破坏程序的结构化控制流，使得代码难以理解和分析，必须禁止使用。

## 规则 21.5：标准库中的信号处理函数不应被使用

- 必须

`<signal.h>` 中定义的信号处理机制具有复杂的、异步的特性，并且许多行为是实现定义的。在安全关键系统中，应使用更可预测的事件处理机制，而不是C语言的信号。

## 规则 21.6：标准库中的输入/输出函数不应被使用

- 必须

`<stdio.h>` 中定义的标准I/O函数（如 `printf`, `scanf`）通常不适用于嵌入式系统。它们的功能复杂、资源消耗大，并且其行为可能依赖于具体的操作系统环境。应使用为目标系统定制的I/O例程。

## 规则 21.7：标准库中的通用工具函数不应被使用

- 必须

`<stdlib.h>` 中的一些函数，如 `system`（执行外部命令）、`abort`（异常终止）、`exit`（正常终止）、`getenv`（访问环境变量），会引入不可预测的行为或依赖于特定的操作系统，必须禁止使用。

## 规则 21.8：标准库中的字符串处理函数不应被使用

- 建议

`<string.h>` 中的一些传统字符串函数（如 `strcpy`, `strcat`）不进行边界检查，容易导致缓冲区溢出。应使用更安全的替代方案（如 `strncpy`, `strncat`），并始终确保目标缓冲区足够大。

## 规则 21.9：标准库中的时间和日期函数不应被使用

- 必须

`<time.h>` 中的函数（如 `time`, `localtime`）的行为高度依赖于实现和硬件，并且可能不是线程安全的。在需要时间功能的系统中，应使用经过认证的、可预测的库。

## 规则 21.10：`<tgmath.h>` 库不应被使用

- 必须

`<tgmath.h>` 提供了类型通用的数学宏，它会根据参数的类型自动调用不同版本的数学函数（如 `sin`, `sinf`, `sinl`）。这种隐式的行为会降低代码的明确性，应显式调用所需版本的函数。

## 规则 21.11：`<errno.h>` 中的 `errno` 宏不应被使用

- 必须

`errno` 是一个用于报告库函数错误的全局变量。在多线程或并发环境中，对 `errno` 的访问和修改不是原子操作，可能导致竞争条件。函数应通过返回值来报告错误，而不是通过全局状态。

## 规则 21.12：`<locale.h>` 中的本地化特性不应被使用

- 必须

`<locale.h>` 用于处理与地域相关的设置（如货币符号、日期格式）。这些特性在嵌入式系统中通常是不需要的，并且会引入不必要的复杂性和依赖。

# 4. 单向链表（Singly Linked List）

本章详细讲解单链表的结构、实现与常用操作。

---

## 4.1 单向链表的定义

- 每个节点包含数据和指向下一个节点的指针。
- 头指针 head 指向第一个节点，最后一个节点 next 为 NULL。

## 4.2 单链表的常用操作

### 1. 头插法/尾插法创建链表

```c
// 头插法
Node* createListHead(int n) {
    Node* head = NULL;
    for (int i = 0; i < n; i++) {
        Node* node = malloc(sizeof(Node));
        node->data = i + 1;
        node->next = head;
        head = node;
    }
    return head;
}

// 尾插法
Node* createListTail(int n) {
    Node* head = NULL, *tail = NULL;
    for (int i = 0; i < n; i++) {
        Node* node = malloc(sizeof(Node));
        node->data = i + 1;
        node->next = NULL;
        if (!head) head = tail = node;
        else { tail->next = node; tail = node; }
    }
    return head;
}
```

### 2. 插入节点

```c
// 在指定位置插入节点（下标从0开始）
Node* insert(Node* head, int pos, int val) {
    Node* node = malloc(sizeof(Node));
    node->data = val;
    if (pos == 0) {
        node->next = head;
        return node;
    }
    Node* p = head;
    for (int i = 0; i < pos-1 && p; i++) p = p->next;
    if (!p) return head; // 位置非法
    node->next = p->next;
    p->next = node;
    return head;
}
```

### 3. 删除节点

```c
// 删除指定位置节点
Node* delete(Node* head, int pos) {
    if (!head) return NULL;
    if (pos == 0) {
        Node* tmp = head;
        head = head->next;
        free(tmp);
        return head;
    }
    Node* p = head;
    for (int i = 0; i < pos-1 && p->next; i++) p = p->next;
    if (!p->next) return head;
    Node* tmp = p->next;
    p->next = tmp->next;
    free(tmp);
    return head;
}
```

### 4. 遍历链表

```c
void printList(Node* head) {
    Node* p = head;
    while (p) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}
```

---

> 单链表是链式结构的基础，掌握其操作有助于理解更复杂的数据结构。

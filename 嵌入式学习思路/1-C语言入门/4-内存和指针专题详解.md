# 内存和指针专题详解

本文件详细介绍C语言中内存与指针相关的核心知识点，配以简明示例，帮助你理解底层原理和常见用法。

---

## 第1课：内存和地址（Memory）

- 十六进制表示
- 计算机内存结构
- 变量地址与&运算符

> 示例：

```c
int a = 10;
printf("a的地址: %p\n", &a);
```

---

## 第2课：指针（Pointer）

- 指针的定义与声明
- 指针的基本用法

> 示例：

```c
int a = 5;
int *p = &a;
printf("p指向的值: %d\n", *p);
```

---

## 第3课：字符串和数组的本质（首地址指针）

- 数组与指针的关系
- 数组在内存中的分布

> 示例：

```c
int arr[3] = {1, 2, 3};
printf("arr的首地址: %p, arr[0]的地址: %p\n", arr, &arr[0]);
```

---

## 第4课：字符串比较（理解strcmp原理）

strcmp（string compare）是 C 语言标准库中的字符串比较函数，用于比较两个以 null 字符（\0）结尾的字符串。其核心原理是逐字符比较两个字符串的 ASCII 码值，直到遇到不同字符或字符串结束符（\0）。
原理详解：
比较方式：
从两个字符串的第一个字符开始，逐个比较对应位置的字符的 ASCII 码值：
若当前字符的 ASCII 码值相等，则继续比较下一对字符；
若当前字符的 ASCII 码值不等，直接返回两个字符的差值（第一个字符串字符 - 第二个字符串字符）；
若所有字符都相等，直到遇到\0（字符串结束），则返回 0。
返回值规则：
返回正数：第一个字符串大于第二个字符串（在第一对不同字符处，前者 ASCII 值更大）；
返回0：两个字符串完全相同；
返回负数：第一个字符串小于第二个字符串（在第一对不同字符处，前者 ASCII 值更小）。
示例：
比较 "apple" 和 "app"：
前 3 个字符（'a','p','p'）均相等，第四个字符中，"apple" 是 'l'，而 "app" 是 \0（结束符）。'l' 的 ASCII 码（108）大于 \0 的 ASCII 码（0），因此返回正数。
比较 "cat" 和 "dog"：
第一个字符 'c'（99）小于 'd'（100），直接返回 99-100 = -1。

---

## 第5课：字符串的复制、数组越界、动态内存管理

### 一、strcpy 的用法

strcpy（string copy）是 C 语言标准库中的字符串复制函数，用于将一个字符串（源字符串）复制到另一个字符数组（目标字符串）中，包含结束符 `\0`。

**函数原型：**

```c
char *strcpy(char *dest, const char *src);
```

- `dest`：目标字符数组（接收复制结果）。
- `src`：源字符串（被复制的字符串，必须以 `\0` 结尾）。
- 返回值：指向目标数组 dest 的指针。

**用法示例：**

```c
#include <string.h>
#include <stdio.h>

int main() {
    char src[] = "hello";
    char dest[20];  // 确保目标数组足够大

    strcpy(dest, src);  // 将src复制到dest
    printf("复制结果：%s\n", dest);  // 输出：hello
    return 0;
}
```

**注意事项：**

- 目标数组必须足够大：若 dest 的长度小于 src（包含 `\0`），会导致数组越界，引发不可预知的错误（如覆盖其他内存数据）。
- 源字符串必须以 `\0` 结尾：否则 strcpy 会一直复制，直到意外遇到 `\0`，导致越界。

---

### 二、数组越界（segmentation fault）

数组越界：指访问数组时，使用的索引超出了数组的合法范围（例如，对 `int arr[5]` 访问 `arr[10]`）。

**为什么会导致 segmentation fault？**

- 数组在内存中是连续的存储空间，越界访问会读写不属于该数组的内存区域。
- 若越界区域是程序未分配的内存（如内核空间），操作系统会阻止访问，触发段错误（segmentation fault），程序崩溃。
- 若越界区域是程序其他变量的内存，会导致数据被意外修改，引发逻辑错误（更难调试）。

**示例（触发段错误）：**

```c
#include <stdio.h>

int main() {
    int arr[3] = {1, 2, 3};
    printf("%d\n", arr[10]);  // 越界访问，可能触发segmentation fault
    return 0;
}
```

---

### 三、malloc 和 valgrind 简介

#### 1. malloc（动态内存分配）

malloc（memory allocate）是 C 语言中用于动态分配内存的函数，在堆（heap）上申请一块指定大小的连续内存。

**函数原型：**

```c
void *malloc(size_t size);  // size：需要分配的字节数
```

- 成功：返回指向分配内存的指针（需强制转换为对应类型）。
- 失败：返回 NULL（如内存不足）。

**用法示例：**

```c
#include <stdlib.h>  // malloc所在头文件
#include <stdio.h>

int main() {
    int *ptr = (int*)malloc(5 * sizeof(int));  // 分配5个int的内存（20字节，假设int为4字节）
    if (ptr == NULL) {  // 必须检查分配是否成功
        printf("内存分配失败\n");
        return 1;
    }

    // 使用内存
    for (int i = 0; i < 5; i++) {
        ptr[i] = i + 1;
    }
    
    free(ptr);  // 释放内存，避免内存泄漏
    ptr = NULL;  // 避免悬空指针
    return 0;
}
```

**注意：**

- 动态分配的内存需手动用 free 释放，否则会导致内存泄漏（程序结束前内存未回收）。
- 释放后指针变为悬空指针（指向已释放的内存），需置为 NULL 避免误用。

#### 2. valgrind（内存调试工具）

Valgrind 是一个开源工具集，主要用于检测 C/C++ 程序的内存问题，最常用的组件是 memcheck（内存检查）。

**功能：**

- 检测内存泄漏（动态分配的内存未释放）。
- 检测越界访问（数组、动态内存的读写越界）。
- 检测使用已释放的内存（悬空指针）。
- 检测未初始化的内存使用。

**使用方法：**

- 编译程序时加入 `-g` 选项（保留调试信息）：

```bash
gcc -g program.c -o program
```

- 用 Valgrind 运行程序：

```bash
valgrind --leak-check=full ./program
```

**示例输出：**

- 若程序存在内存泄漏，Valgrind 会提示泄漏的内存大小和位置，帮助定位问题。

---

### 四、内存中的垃圾值

指内存单元中未被初始化的随机值。当内存被分配但未赋值时，其存储的是之前使用该内存的残留数据，称为“垃圾值”。

**产生场景：**

#### 1. 未初始化的局部变量

局部变量存储在栈（stack）中，若未初始化，其值是栈内存的残留数据（垃圾值）。

```c
int main() {
    int a;  // 未初始化
    printf("%d\n", a);  // 输出随机垃圾值
    return 0;
}
```

#### 2. 动态分配的内存

malloc 分配的内存不会自动初始化，存储的是堆内存的残留数据（垃圾值）。

```c
int *ptr = (int*)malloc(4);
printf("%d\n", *ptr);  // 输出垃圾值（未初始化）
```

#### 3. 避免方法

- 局部变量定义时立即初始化（如 `int a = 0;`）。
- 动态内存可用 calloc 分配（自动初始化为 0），或手动赋值（如 `*ptr = 0;`）。

```c
int *ptr = (int*)calloc(1, sizeof(int));  // calloc会初始化内存为0
```

垃圾值可能导致程序逻辑错误（如条件判断异常），因此使用内存前务必初始化。

> 注意：数组越界和未初始化变量会导致不可预期的行为，建议使用 valgrind 等工具检测内存问题。
> 注意：数组越界和未初始化变量会导致不可预期的行为，建议使用valgrind等工具检测内存问题。

---

> 建议每学完一节都动手实践代码，加深理解。


# 02. 嵌入式调试利器：SWD、SWV 与 SWO 深度解析

在嵌入式开发的世界里，调试工具和技术是开发者的“第三只眼”，帮助我们看透程序运行的每一个细节。对于基于 ARM Cortex-M 系列处理器的开发来说，SWD、SWV 和 SWO 是三个经常被提及的技术术语。它们看似相近，功能却各有侧重，协同工作时能为调试带来极大便利。今天，我们就来深入解读这三者的奥秘，看看它们如何让嵌入式调试变得更高效。

---

## 一、SWD：原理、协议与工程实践

SWD（Serial Wire Debug，串行线调试）是 ARM 推出的主流片上调试接口，广泛应用于 Cortex-M 系列等 ARM 处理器。它以极简的物理连接、优良的速度和丰富的调试功能成为嵌入式领域调试和烧录的标准。

### 1.1 协议概述与物理连接

- 仅需 SWDIO（数据线，双向）和 SWCLK（时钟线，单向），极大节省芯片引脚和 PCB 空间。
- 支持高达 50 MHz 的时钟频率，布线简单，适合高密度设计。
- 所有通信均由调试主机发起，实现无歧义主从关系。
- 推荐 SWDIO/SWCLK 各串 10kΩ 上拉电阻并对地 33pF 滤波电容，信号线尽量短（<15cm），与地线分组走双绞线提升抗干扰性。

### 1.2 协议分层与体系结构

| 层级         | 职责举例               | 典型操作           |
| ------------ | ---------------------- | ------------------ |
| 应用层       | Flash 编程、IAP 调用   | 烧录、断点、单步   |
| 核心调试层   | 处理器控制、寄存器访问 | 核暂停、寄存器读写 |
| 传输层 (SWD) | 命令帧传输、校验、应答 | 读写 AP/DP 寄存器  |
| 物理层       | 电气特性、时序         | 位传输、拉高/拉低  |

### 1.3 通信时序与数据包格式

SWD 通信以主机发起的请求-应答-数据模型为核心，一次完整事务由如下阶段构成：

#### 请求包格式

| 字段   | 位数 | 含义                 |
| ------ | ---- | -------------------- |
| Start  | 1    | 起始位(1)            |
| APnDP  | 1    | 0=DP 寄存器，1=AP 寄存器 |
| RnW    | 1    | 0=写操作，1=读操作   |
| A[2:3] | 2    | 寄存器低两位地址     |
| Parity | 1    | 奇偶校验（前5位）    |
| Stop   | 1    | 停止位(0)            |
| Park   | 1    | 保持位(1)            |

请求包发送后，目标芯片以 3 位 ACK 响应，之后根据读写类型进入数据传输阶段。

#### 应答与数据阶段

- ACK（3位）：OK（0b001）、WAIT（0b010）、FAULT（0b100）
- 数据包（32位数据+1位奇偶校验）

#### 完整事务时序举例（主机→目标）

1. 发送 8 位请求
2. 目标延迟响应，返回 3 位 ACK
3. 主机根据 ACK 处理
   - OK：继续数据阶段
   - WAIT：重试
   - FAULT：清除错误后重试
4. 数据阶段（读/写数据 + 校验）

### 1.4 典型应用流程

以 Flash 编程为例，一次 SWD 调试典型流程如下：

1. 初始化 DAP (Debug Access Port)
2. 使能/复位处理器核心
3. 设置目标内存地址（通过 AP 寄存器）
4. 下载数据到 RAM 或直接写入 Flash
5. 调用 IAP/Flash 编程功能
6. 校验写入结果

伪代码示意：

```c
void SWD_WriteFlash(uint32_t addr, uint32_t* buf, size_t len) {
    SWD_WriteAP(AP_TAR, addr);       // 设置目标地址
    for (size_t i = 0; i < len; ++i) {
        SWD_WriteAP(AP_DRW, buf[i]); // 连续写入数据
        SWD_WaitForACK();
    }
    // 触发 Flash 编程
}
```

### 1.5 错误处理机制

SWD 协议通过 ACK 响应和奇偶校验实现健壮的错误检测：

- OK：正常，继续操作
- WAIT：目标繁忙，主机需重试当前命令
- FAULT：非法访问或出错，主机需清除错误（如写 ABORT 寄存器）

实际应用时，建议实现超时和重试机制，确保调试链路健壮。

### 1.6 多设备与扩展拓扑

SWD v2 支持多芯片调试，通过 Daisy-chain 或星型总线拓扑：

- 设备选择序列：主机可动态“唤醒”特定设备
- 电源管理：未激活设备可休眠，降低功耗
- 兼容性：向下兼容 SWD v1，利于系统升级

### 1.7 工程实践建议与调试技巧

**硬件设计：**

- 信号线短且等长，避免串扰
- SWDIO/SWCLK 10kΩ 上拉，33pF 对地
- 加 ESD 防护，关键点加缓冲驱动

**软件实现：**

- 初始化时发送 50 个时钟周期的线复位
- 发送 JTAG-to-SWD 切换序列 (0xE79E)
- 读取 DP_IDCODE 验证链路
- 实现 ACK 超时/重试及错误日志

示例初始化代码片段：

```c
void SWD_Init(void) {
    SWD_LineReset(50);
    SWD_SendBits(0xE79E, 16); // 切换序列
    SWD_LineReset(8);
    uint32_t id = SWD_ReadDP(DP_IDCODE);
    if ((id & 0x1FFF) != 0x1BA0) {
        // 连接失败处理
    }
}
```

**调试技巧：**

- 使用逻辑分析仪捕获 SWDIO/SWCLK 信号，分析读写波形
- 软件层面详细记录 ACK 和奇偶校验错误，便于排查
- 对于异常 WAIT/FAULT，多检查目标芯片电源和时钟

---

## 二、SWO：跟踪数据的专属通道

SWO（Serial Wire Output，串行线输出）是一根专用的输出线，主要用于传输处理器产生的跟踪数据。它通常与 SWD 接口复用引脚，在硬件设计时需要特别引出，才能发挥作用。SWO（Serial Wire Output）是 ARM 制定的 Serial Wire Debug（SWD）的一个扩展，但是并不是所有支持 SWD 的 ARM 核心都支持 SWO。而 SWD 又是 ARM 公司 Cortex-M CoreSight 组件的一部分。CoreSight 是 ARM 设计的用于芯片内部的调试及跟踪的组件。

SWO 的核心作用是作为跟踪数据的“传输管道”。当处理器运行时，内部的跟踪模块（如 ITM、DWT、ETM）会产生大量的调试信息，这些信息正是通过 SWO 线以串行方式发送到调试主机的。SWO 的传输速率可根据需求配置，最高可达数十 Mbps，足以应对大多数场景下的跟踪数据量。

需要注意的是，SWO 本身并不产生跟踪数据，它只是一个物理传输通道。真正的“内容生产者”是处理器内部的跟踪模块，而 SWO 则负责将这些内容高效、实时地传递出去。

---

## 三、SWV：全方位的跟踪分析技术

SWV（Serial Wire Viewer，串行线查看器）是基于 SWD 和 SWO 实现的一套完整跟踪分析技术。它的核心功能是通过 SWD 接口配置处理器内部的跟踪模块，然后通过 SWO 线捕获这些模块产生的跟踪数据，最终由调试工具解析并可视化展示，帮助开发者深入了解程序的运行状态。

**对于某些芯片来说SWO不支持，就不支持SWV。**

SWV 包含多个核心功能模块，各自负责不同类型的跟踪任务：

- **ITM（Instrumentation Trace Macrocell）**：软件触发的跟踪模块，开发者可以在程序中通过特定函数（如 ITM_SendChar）输出调试日志，无需占用 UART、SPI 等外设资源。ITM 提供了 32 个不同的端口，可用于区分不同类型的信息。
- **DWT（Data Watchpoint and Trace）**：专注于硬件级的数据和指令跟踪。可以设置数据观察点，跟踪内存访问和指令执行轨迹，便于定位变量被意外修改、分析函数调用流程等问题。
- **ETM（Embedded Trace Macrocell）**：提供最全面的指令流跟踪，能记录处理器执行的每一条指令（需硬件支持），适用于深度调试和代码优化场景。
- **时间戳模块**：为所有跟踪事件添加精确的时间戳，帮助分析事件之间的时序关系，如测量中断响应时间、函数执行耗时等。

[SWV查看的使用思路](https://blog.csdn.net/Three_Future/article/details/124238309)
[ITM打印的使用](https://blog.csdn.net/2301_79036162/article/details/148892846)

>ITM_SendChar ：前文已着重介绍过 ITM_SendChar 函数，它是 ITM 模块中用于发送单个字符数据的核心函数。通过将字符写入 ITM 刺激端口寄存器，经 ITM 模块打包处理，再由 SWO 线传输到调试主机，实现调试信息的输出。在代码中使用时，只需简单调用ITM_SendChar('A');，即可将字符 'A' 发送出去，常用于输出简单的状态标志、变量值的单字符表示等。例如在一个简单的传感器数据采集程序中，可在每次成功采集数据时，调用ITM_SendChar('S');，表示数据采集成功，方便开发者在调试工具中实时知晓程序运行到该步骤。
>
>ITM_Port8/ITM_Port16/ITM_Port32 ： 这三个函数分别用于通过 ITM 模块向调试主机发送 8 位、16 位和 32 位的数据。其工作机制与 ITM_SendChar 类似，只是传输的数据位宽不同。以ITM_Port8为例，函数原型可能为void ITM_Port8(uint32_t port, uint8_t value);，其中port指定使用的 ITM 端口（0 - 31），value为要发送的 8 位数据。在实际应用中，比如需要发送一个 8 位的传感器状态字节，可使用ITM_Port8(1, sensor_status);，将传感器状态数据通过端口 1 发送出去。这种方式适用于传输稍复杂的数据结构，如状态标志字节、简单的计数器值等。对于 16 位和 32 位数据传输，ITM_Port16和ITM_Port32函数则发挥作用，例如在处理一个 16 位的 ADC 采样值时，可通过ITM_Port16(2, adc_value);将数据发送到调试主机，方便开发者观察 ADC 采样的实时结果。
>
>DWT_SetWatchpoint ： DWT（Data Watchpoint and Trace）模块相关函数在 SWV 调试中也十分重要。DWT_SetWatchpoint函数用于设置数据观察点，当指定的内存地址被访问（读或写）时，触发跟踪事件。函数原型可能为void DWT_SetWatchpoint(uint32_t addr, uint32_t size, uint32_t access_type);，其中addr是要设置观察点的内存地址，size表示观察的内存区域大小（通常为 1、2、4 字节），access_type指定访问类型（读、写或读写）。在调试过程中，若怀疑某个变量被意外修改，可使用DWT_SetWatchpoint((uint32_t)&suspected_variable, 4, DWT_ACCESS_WRITE);设置对该变量所在内存地址的写操作观察点。一旦该变量被写入新值，DWT 模块会记录相关事件，并通过 SWV 传输到调试主机，帮助开发者快速定位问题根源，了解变量在程序运行过程中的变化情况。
>
>DWT_ClearWatchpoint ： 与DWT_SetWatchpoint相对应，DWT_ClearWatchpoint函数用于清除已设置的数据观察点。当不再需要对某个内存地址进行观察时，调用此函数可避免不必要的跟踪事件记录和数据传输，节省系统资源。例如在完成对某个变量的调试分析后，可通过DWT_ClearWatchpoint(0);清除编号为 0 的观察点（假设之前设置的观察点编号为 0）。该函数可确保在程序后续运行中，不会因之前设置的观察点而产生额外的跟踪开销，保证程序的正常运行效率。
>
>ETM_Enable/ETM_Disable ：对于支持 ETM（Embedded Trace Macrocell）模块的处理器，ETM_Enable和ETM_Disable函数用于开启和关闭 ETM 跟踪功能。ETM_Enable函数可激活 ETM 模块，使其开始记录处理器执行的每一条指令，生成详细的指令流跟踪数据。而ETM_Disable函数则停止 ETM 的工作，停止数据记录。例如在需要对一段关键代码进行指令级分析时，可先调用ETM_Enable();开启 ETM 跟踪，在代码执行完毕后，调用ETM_Disable();停止跟踪，然后通过 SWV 将已记录的指令跟踪数据传输到调试主机进行分析。这两个函数在优化代码性能、分析程序执行路径等场景中发挥着重要作用，帮助开发者深入了解程序在指令层面的运行情况，发现潜在的性能瓶颈和逻辑问题。

### 3.2 ITM 多端口数据发送与分类调试

在嵌入式调试中，利用 ITM 模块的多端口特性可实现不同类型调试信息的分类传输。ITM 模块包含 32 个独立的刺激端口（编号 0 - 31），每个端口对应一组寄存器，用于传输特定类型的数据。以 8 位数据传输为例，端口 n 的 8 位寄存器地址可通过 `ITM->PORT[n].u8` 访问。

#### 使能目标端口

在初始化 ITM 模块时，需通过 ITM->TER 寄存器开启需要使用的端口。例如，同时使能端口 0 和端口 1：

```c
#define ITM_PORT0 0x00000001  // 端口0使能位
#define ITM_PORT1 0x00000002  // 端口1使能位（注意：端口n的使能位为第n位）
ITM->TER |= ITM_PORT0 | ITM_PORT1;  // 开启端口0和端口1
```

> 注意：ITM->TER 的第 n 位对应端口 n，因此端口 1 的使能位实际为 0x00000002，需根据硬件手册修正定义。

#### 向不同端口发送数据

针对不同类型的信息，选择对应的端口发送。发送前需检查端口是否就绪（如 ITM_PORT_READY_Msk，通常为 0x80，表示端口可接收新数据）：

端口 0 发送系统错误信息：

```c
void ITM_SendError(char ch) {
    if (ITM->TCR & ITM_TCR_ITMENA_Msk) {  // 检查ITM是否全局使能
        while (!(ITM->PORT[0].u8 & ITM_PORT_READY_Msk));  // 等待端口就绪
        ITM->PORT[0].u8 = ch;  // 发送到端口0
    }
}
```

端口 1 发送传感器数据：

```c
void ITM_SendSensorData(char ch) {
    if (ITM->TCR & ITM_TCR_ITMENA_Msk && (ITM->TER & ITM_PORT1)) {  // 检查端口1是否使能
        while (!(ITM->PORT[1].u8 & ITM_PORT_READY_Msk));  // 等待端口就绪
        ITM->PORT[1].u8 = ch;  // 发送到端口1
    }
}
```

#### 调试工具中区分端口信息

在 Keil MDK 等工具的 “Debug (printf) Viewer” 中，可通过配置显示不同端口的数据。例如：

- 端口 0 的数据显示为 “Error: xxx”
- 端口 1 的数据显示为 “Sensor: xxx”

部分工具支持按端口筛选信息，进一步提升调试效率。

#### 多端口使用的优势与注意事项

**优势：**

- 信息分类清晰：通过端口区分错误日志、状态信息、传感器数据等，避免调试信息混杂。
- 灵活筛选：调试时可只查看特定端口的信息，减少干扰。

**注意事项：**

- 端口使能与全局使能：需先通过 ITM->TCR 开启 ITM 全局功能（ITM_TCR_ITMENA_Msk），再通过 ITM->TER 开启目标端口，否则数据无法发送。
- 端口就绪检查：连续发送数据时，需通过 ITM->PORT[n].u8 的就绪位判断端口是否空闲，避免数据丢失（尤其在高频发送场景）。
- 数据位宽选择：除 u8（8 位）外，还可使用 u16（16 位）和 u32（32 位）寄存器发送多字节数据，如 `ITM->PORT[2].u32 = 0x12345678` 发送 32 位数据到端口 2。

通过合理使用 ITM 的多端口功能，开发者可构建结构化的调试信息传输体系，进一步提升嵌入式系统的调试效率，尤其适用于复杂系统的多模块协同调试场景。

---

## 四、三者的协同关系

SWD、SWV 和 SWO 并非相互独立，而是紧密协作的整体：

- **SWD** 是“控制中心”，负责调试主机对处理器的配置和控制，比如开启 SWV 跟踪功能、设置跟踪参数等。
- **SWO** 是“传输通道”，承载着 SWV 产生的所有跟踪数据，将其从处理器发送到调试主机。
- **SWV** 是“内容生产者和分析者”，通过内部模块生成跟踪信息，并由调试工具解析展示，为开发者提供调试依据。

简单来说，SWD 负责“指挥”，SWO 负责“运输”，SWV 负责“生产和解读”，三者缺一不可，共同构成了一套强大的嵌入式调试跟踪体系。

---

## 五、实际应用场景与注意事项

**应用场景：**

- 非侵入式调试：SWV 跟踪不会暂停处理器运行，适合调试实时系统。
- 高效日志输出：通过 ITM 输出调试日志，不占用外设资源，适合资源受限设备。
- 时序分析：利用时间戳功能，精确测量函数执行时间、中断响应延迟等。
- 异常定位：通过 DWT 跟踪内存访问，定位数组越界、野指针等问题；通过 ETM 指令跟踪，分析程序跑飞原因。

**注意事项：**

- 硬件支持是前提：处理器和开发板必须引出 SWO 线，调试器也需支持 SWO 数据捕获。
- 配置要匹配：需在调试工具中正确设置 SWO 时钟频率，否则可能导致数据传输错误。
- 控制数据量：ETM 等模块会产生大量数据，若 SWO 传输速率不足，可能导致数据丢失，需根据需求选择合适的跟踪模块。

---

## 结语

SWD、SWV 和 SWO 是 ARM Cortex-M 系列处理器调试的利器，它们的组合为开发者提供了从控制到跟踪、从传输到分析的全方位支持。掌握这些技术，能让我们在嵌入式开发中更轻松地定位问题、优化性能，尤其在复杂系统和实时场景中，其价值更是不可替代。希望通过本文的解析，能帮助大家更好地理解和运用这些技术，让调试工作事半功倍。

---

## 附录：SWD 协议原理与工程实践

ARM Serial Wire Debug（SWD）是现代 Cortex-M 系列等 ARM 处理器的主流片上调试接口。它以极简的物理连接、优良的速度和丰富的调试功能成为嵌入式领域调试和烧录的标准。本文将系统梳理 SWD 的原理、协议分层、数据包格式、典型时序、错误处理及工程应用建议，帮助你从原理到实践全面掌握 ARM SWD 协议。

### 1. SWD 协议概述

SWD 是 ARM 为替代传统 4 线 JTAG 所开发的两线制同步串行调试协议。其优势主要体现在：

- 引脚极少：仅需 SWDIO（数据线，双向）和 SWCLK（时钟线，单向）。
- 速度高效：支持高达 50 MHz 的时钟频率。
- 布线简单：极大方便小型封装和高密度 PCB 设计。
- 主机主导：所有通信均由调试主机发起，实现无歧义主从关系。

物理连接推荐：

- SWDIO/SWCLK 各串 10kΩ 上拉电阻并对地 33pF 滤波电容。
- 信号线尽量短（<15cm），与地线分组走双绞线，提升抗干扰性。

### 2. SWD 协议分层与体系结构

SWD 协议严格分层，便于软硬件实现和调试：

| 层级         | 职责举例               | 典型操作           |
| ------------ | ---------------------- | ------------------ |
| 应用层       | Flash 编程、IAP 调用   | 烧录、断点、单步   |
| 核心调试层   | 处理器控制、寄存器访问 | 核暂停、寄存器读写 |
| 传输层 (SWD) | 命令帧传输、校验、应答 | 读写 AP/DP 寄存器  |
| 物理层       | 电气特性、时序         | 位传输、拉高/拉低  |

### 3. 典型通信时序与数据包格式

SWD 通信以主机发起的请求-应答-数据模型为核心，一次完整事务由如下阶段构成：

#### 3.1 请求包格式

| 字段   | 位数 | 含义                 |
| ------ | ---- | -------------------- |
| Start  | 1    | 起始位(1)            |
| APnDP  | 1    | 0=DP 寄存器，1=AP 寄存器 |
| RnW    | 1    | 0=写操作，1=读操作   |
| A[2:3] | 2    | 寄存器低两位地址     |
| Parity | 1    | 奇偶校验（前5位）    |
| Stop   | 1    | 停止位(0)            |
| Park   | 1    | 保持位(1)            |

请求包发送后，目标芯片以 3 位 ACK 响应，之后根据读写类型进入数据传输阶段。

#### 3.2 应答与数据阶段

- ACK（3位）：OK（0b001）、WAIT（0b010）、FAULT（0b100）
- 数据包（32位数据+1位奇偶校验）

#### 3.3 完整事务时序举例（主机→目标）

1. 发送 8 位请求
2. 目标延迟响应，返回 3 位 ACK
3. 主机根据 ACK 处理
   - OK：继续数据阶段
   - WAIT：重试
   - FAULT：清除错误后重试
4. 数据阶段（读/写数据 + 校验）

### 4. 典型应用流程

以 Flash 编程为例，一次 SWD 调试典型流程如下：

1. 初始化 DAP (Debug Access Port)
2. 使能/复位处理器核心
3. 设置目标内存地址（通过 AP 寄存器）
4. 下载数据到 RAM 或直接写入 Flash
5. 调用 IAP/Flash 编程功能
6. 校验写入结果

伪代码示意：

```c
void SWD_WriteFlash(uint32_t addr, uint32_t* buf, size_t len) {
    SWD_WriteAP(AP_TAR, addr);       // 设置目标地址
    for (size_t i = 0; i < len; ++i) {
        SWD_WriteAP(AP_DRW, buf[i]); // 连续写入数据
        SWD_WaitForACK();
    }
    // 触发 Flash 编程
}
```

### 5. 错误处理机制

SWD 协议通过 ACK 响应和奇偶校验实现健壮的错误检测：

- OK：正常，继续操作
- WAIT：目标繁忙，主机需重试当前命令
- FAULT：非法访问或出错，主机需清除错误（如写 ABORT 寄存器）

实际应用时，建议实现超时和重试机制，确保调试链路健壮。

### 6. 多设备与扩展拓扑

SWD v2 支持多芯片调试，通过 Daisy-chain 或星型总线拓扑：

- 设备选择序列：主机可动态“唤醒”特定设备
- 电源管理：未激活设备可休眠，降低功耗
- 兼容性：向下兼容 SWD v1，利于系统升级

### 7. 工程实践建议

#### 7.1 硬件设计

- 信号线短且等长，避免串扰
- SWDIO/SWCLK 10kΩ 上拉，33pF 对地
- 加 ESD 防护，关键点加缓冲驱动

#### 7.2 软件实现

- 初始化时发送 50 个时钟周期的线复位
- 发送 JTAG-to-SWD 切换序列 (0xE79E)
- 读取 DP_IDCODE 验证链路
- 实现 ACK 超时/重试及错误日志

示例初始化代码片段：

```c
void SWD_Init(void) {
    SWD_LineReset(50);
    SWD_SendBits(0xE79E, 16); // 切换序列
    SWD_LineReset(8);
    uint32_t id = SWD_ReadDP(DP_IDCODE);
    if ((id & 0x1FFF) != 0x1BA0) {
        // 连接失败处理
    }
}
```

#### 7.3 调试技巧

- 使用逻辑分析仪捕获 SWDIO/SWCLK 信号，分析读写波形
- 软件层面详细记录 ACK 和奇偶校验错误，便于排查
- 对于异常 WAIT/FAULT，多检查目标芯片电源和时钟

### 8. 参考资料

- ARM IHI0031G - Debug Interface Architecture Specification
- NXP AN11553 - SWD Programming Specification
- Cortex-M3 Technical Reference Manual

# 内存映射和启动过程

在 STM32 等 ARM Cortex-M 系列 MCU 中，内存地址空间按照 存储功能 进行了严格划分，包括 Flash（程序存储）、RAM（数据存储）、外设寄存器（GPIO、UART、SPI 等）以及系统控制寄存器（中断、调试相关）。下面详细解析各个地址段的作用和特点。

---

## 1. 内存地址映射详解

### 1.1 内存地址映射总览

在 ARM Cortex-M 处理器（如 STM32 系列 MCU）中地址空间通常采用 32 位地址总线，因此可寻址 4GB（`0x00000000` ~ `0xFFFFFFFF`），但在嵌入式系统中，MCU 的可用内存远小于 4GB，并且地址空间被划分为多个功能区。

| 地址范围                 | 存储内容               | 描述                                                 |
| ------------------------ | ---------------------- | ---------------------------------------------------- |
| `0x00000000`-`0x000003FF` | 向量表（Vector Table） | 存放复位向量（起始栈指针）、异常入口地址             |
| `0x08000000`-`0x0800FFFF` | Flash（代码存储）      | 存储 程序代码（`.text`） 和 只读数据（`.rodata`）      |
| `0x1FFFF000`-`0x1FFFF7FF` | 系统 Boot ROM          | 预留给 MCU BootLoader（ISP、IAP 相关）                 |
| `0x20000000`-`0x20004FFF` | RAM（可变数据存储）    | SRAM（RAM，存储 `.data`、`.bss`、堆、栈）             |
| `0x40000000`-`0x500607FF` | 外设寄存器             | 片上 GPIO、UART、SPI、I2C、TIM、ADC 等外设的控制寄存器 |
| `0xE0000000`-`0xE00FFFFF` | System 控制寄存器      | NVIC（中断控制）、SysTick（系统定时器）、调试接口      |

### 1.2 `0x00000000` - `0x000003FF`：向量表 (Vector Table)

MCU 复位后，系统从 `0x00000000` 地址处读取向量表，该表包含了复位后跳转到 `main()` 的入口地址。

**作用：**

- 存储异常和中断向量表，即异常/中断入口地址。
- 第一项存放的是栈指针初值（SP），用于 CPU 复位时初始化堆栈。
- 其余项是中断服务程序（ISR）地址，例如：
  - 复位向量（Reset Vector）
  - 硬件故障处理（HardFault、NMI）
  - 外设中断（UART、GPIO、TIM 等）

向量表示例

```c
0x00000000: 0x20004FFF   ; 初始栈指针地址（RAM 顶部）
0x00000004: 0x08000239   ; 复位处理函数（Reset_Handler）
0x00000008: 0x08000321   ; NMI_Handler
0x0000000C: 0x08000345   ; HardFault_Handler
```

> 该表通常存储于 Flash（`0x08000000`）

### 1.3 `0x08000000` - `0x0800FFFF`：Flash（程序存储）

作用

- 存放 MCU 固件（程序代码），包括：
- `.text`（代码段）
- `.rodata`（只读数据）
- 代码段的存储区域，运行时 CPU 直接从 Flash 取指令，不会加载到 RAM。

特点

- Flash 只能按扇区擦除，不能按字节修改（通常 1 次擦除需要 20ms 左右）。
- RAM 访问速度远快于 Flash，因此 **关键代码可拷贝到 RAM 执行**。

### 1.4 `0x1FFFF000` - `0x1FFFF7FF`：系统 Boot ROM

作用

- STM32 MCU 内置 Bootloader（引导程序），支持：
  - ISP（In-System Programming）：通过 UART/SWD 进行固件烧录。
  - IAP（In-Application Programming）：运行时更新 Flash 代码。
特点

- Bootloader 可以让 MCU 在 Flash 损坏的情况下仍然可以进行固件更新。
- 通过 `BOOT0` / `BOOT1` 硬件引脚可以选择启动 Flash 还是 Bootloader。

### 1.5 `0x20000000` - `0x20004FFF`：RAM（数据存储）

作用

- 存储 MCU 运行时的变量和数据，包括：
  - `.data` 段：已初始化的全局变量（上电后从 Flash 复制到 RAM）
  - `.bss` 段：未初始化的全局变量（上电后初始化为 0）
  - 堆（Heap）：`malloc()` 动态分配的内存
  - 栈（Stack）：局部变量、函数调用信息

RAM 内存布局

| 内存区域 | 描述 | 地址增长方向 |
| :--- | :--- | :--- |
| **高地址** | --- | `0x20005000` (RAM 结束) |
| Heap | 动态分配 (`malloc`) | 向上增长 |
| Stack | 局部变量、函数调用信息 | 向下增长 |
| .bss | 未初始化的全局变量 | 固定 |
| .data | 已初始化的全局变量 | 固定 |
| **低地址** | --- | `0x20000000` (RAM 起始) |

> **注意**
>
> - 栈向下增长，堆向上增长，如果二者相遇会导致崩溃（Stack Overflow）。
> - **优化方法：**
>   - 尽量使用 `const` 让数据存入 Flash，减少 RAM 占用。
>   - 避免使用 `malloc()`，防止内存碎片化。

### 1.6 `0x40000000` - `0x500607FF`：外设寄存器

作用

- 用于 MCU 片上外设的控制，如：
  - GPIO（`0x40010800`）：控制 I/O 口输入/输出。
  - UART（`0x40013800`）：串口收发数据。
  - SPI（`0x40013000`）：SPI 传输数据。
  - ADC（`0x40012400`）：模拟信号转换。

代码示例

```c
#define GPIOC_ODR  (*((volatile uint32_t*) 0x4001100C))
GPIOC_ODR |= (1 << 13); // 置位 PC13（LED 亮）
```

特点

- 访问外设寄存器时 **必须使用 `volatile` 修饰**，否则编译器可能优化导致错误。

### 1.7 `0xE0000000` - `0xE00FFFFF`：System 控制寄存器

作用

- 控制 **中断、调试、系统时钟**，主要包括：
  - NVIC（Nested Vectored Interrupt Controller，中断控制器）
  - SysTick（系统定时器）
  - SCB（System Control Block，系统控制块）

代码示例

```c
#define NVIC_ISER0 (*((volatile uint32_t*) 0xE000E100))
NVIC_ISER0 |= (1 << 6); // 使能外部中断 6
```

特点

- NVIC 允许中断嵌套，可以配置优先级。
- SysTick 是 Cortex-M 内置的 24-bit 计时器，用于系统心跳计时。

## 2.启动过程

以stm32为例的启动过程

### 2.1 MDK (armcc) 启动文件分析

MDK 使用的 `armcc` 编译器，其启动文件（如 `startup_stm32f10x_hd.s`）负责在 `main` 函数执行前完成最基本的硬件初始化。

#### 1. 堆栈空间定义

启动文件首先会定义 **栈（Stack）** 和 **堆（Heap）** 的大小。

```armasm
; <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>
Stack_Size      EQU     0x00000400

                AREA    STACK, NOINIT, READWRITE, ALIGN=3
Stack_Mem       SPACE   Stack_Size
__initial_sp

; <o> Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
Heap_Size       EQU     0x00000200

                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
__heap_base
Heap_Mem        SPACE   Heap_Size
__heap_limit
```

- `EQU`: 伪指令，用于定义常量。`Stack_Size` 和 `Heap_Size` 分别定义了栈和堆的大小。
- `AREA`: 伪指令，用于定义一个代码段或数据段。
  - `STACK` 和 `HEAP` 是段名。
  - `NOINIT`: 表示该段内存未初始化，对应 C 语言中的 `.bss` 段。
  - `READWRITE`: 表示该段内存可读可写。
  - `ALIGN=3`: 表示 8 字节对齐（2^3）。
- `SPACE`: 伪指令，用于分配一块指定大小的内存空间。
- `__initial_sp`, `__heap_base`, `__heap_limit`: 这些是链接器可以使用的符号，用于标记栈顶、堆的起始和结束地址。

#### 2. 中断向量表

接下来是中断向量表的定义，这是 MCU 启动的 **关键**。

```armasm
                AREA    RESET, DATA, READONLY
                EXPORT  __Vectors
                EXPORT  __Vectors_End
                EXPORT  __Vectors_Size

__Vectors       DCD     __initial_sp              ; Top of Stack
                DCD     Reset_Handler             ; Reset Handler
                DCD     NMI_Handler               ; NMI Handler
                DCD     HardFault_Handler         ; Hard Fault Handler
                ; ... 其他中断处理函数
__Vectors_End

__Vectors_Size  EQU     __Vectors_End - __Vectors
```

- `AREA RESET, DATA, READONLY`: 定义了一个名为 `RESET` 的只读数据段。在链接脚本 (`.sct`) 中，这个段会被放置在 Flash 的起始地址 `0x08000000`。
- `DCD`: 伪指令，分配一个 4 字节的内存空间，并用指定的值初始化。
- `__Vectors`: 向量表的起始地址。
  - **第一项 (`__initial_sp`)**: 存储栈的顶部地址。MCU 复位后，硬件会自动将这个值加载到主堆栈指针 (MSP)。
  - **第二项 (`Reset_Handler`)**: 复位处理函数的入口地址。CPU 在加载完 MSP 后，会跳转到这个地址开始执行代码。

#### 3. 复位处理函数 `Reset_Handler`

这是 MCU 上电后执行的第一个函数。

```armasm
; Reset handler routine
Reset_Handler   PROC
                EXPORT  Reset_Handler             [WEAK]
        IMPORT  SystemInit
        IMPORT  __main

                LDR     R0, =SystemInit
                BLX     R0
                LDR     R0, =__main
                BX      R0
                ENDP
```

- `PROC` / `ENDP`: 定义一个函数的开始和结束。
- `EXPORT`: 将符号 `Reset_Handler` 导出，使其对其他文件可见。`[WEAK]` 表示弱定义，如果其他地方有同名的强定义，将覆盖此处的定义。
- `IMPORT`: 导入外部符号。`SystemInit` 是系统时钟初始化函数，`__main` 是 `armcc` 库函数，负责 C 运行环境的初始化。
- **执行流程**:
  1. `LDR R0, =SystemInit` / `BLX R0`: 调用 `SystemInit()` 函数，初始化 MCU 的时钟系统（例如，配置 PLL）。
  2. `LDR R0, =__main` / `BX R0`: 跳转到 `__main`。

#### 4. C 库初始化 (`__main`)

`__main` 是一个复杂的库函数，它主要完成以下工作：

1. **Scatter-loading (分散加载)**: 调用 `__scatterload` 函数，将 Flash 中的 `.data` 段（已初始化的全局变量）复制到 RAM 中。
2. **清零 `.bss` 段**: 将 RAM 中未初始化的全局变量区域全部清零。
3. **初始化 C 库**: 例如 `stdio` 等。
4. **初始化堆栈**: 调用 `__rt_entry`，最终会跳转到用户程序的 `main()` 函数。

#### 5. 堆栈初始化函数 `__user_initial_stackheap`

这是一个由用户选择性实现的函数，用于向链接器指明堆和栈在内存中的具体位置。

```armasm
__user_initial_stackheap

                 LDR     R0, =  Heap_Mem
                 LDR     R1, =(Stack_Mem + Stack_Size)
                 LDR     R2, = (Heap_Mem +  Heap_Size)
                 LDR     R3, = Stack_Mem
                 BX      LR
```

这个函数通过寄存器返回堆和栈的边界地址，供 C 库的初始化函数使用。

### 2.2 GCC (arm-none-eabi-gcc) 启动文件分析

GCC 的启动流程与 MDK 类似，但实现方式更“裸露”，没有 `__main` 这样的黑盒库函数，所有操作都在启动文件中明确完成。

```armasm
  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  /* 1. 设置栈指针 */
  ldr   r0, =_estack
  mov   sp, r0

  /* 2. 调用 SystemInit 初始化时钟 */
  bl  SystemInit

  /* 3. 将 .data 段从 Flash 复制到 SRAM */
  ldr r0, =_sdata
  ldr r1, =_edata
  ldr r2, =_sidata
  movs r3, #0
  b LoopCopyDataInit
CopyDataInit:
  ldr r4, [r2, r3]
  str r4, [r0, r3]
  adds r3, r3, #4
LoopCopyDataInit:
  adds r4, r0, r3
  cmp r4, r1
  bcc CopyDataInit

  /* 4. 将 .bss 段清零 */
  ldr r2, =_sbss
  ldr r4, =_ebss
  movs r3, #0
  b LoopFillZerobss
FillZerobss:
  str  r3, [r2]
  adds r2, r2, #4
LoopFillZerobss:
  cmp r2, r4
  bcc FillZerobss

  /* 5. 跳转到 main 函数 */
  bl main
  bx lr
```

- **符号说明** (这些符号在链接脚本 `.ld` 中定义):
  - `_estack`: 栈顶地址。
  - `_sdata`, `_edata`: SRAM 中 `.data` 段的起始和结束地址。
  - `_sidata`: Flash 中 `.data` 段的加载地址（源地址）。
  - `_sbss`, `_ebss`: `.bss` 段的起始和结束地址。

### 2.3 常见问题：0x0 地址必须是栈顶指针吗？

**答案：非必须。**

- 在 ARM 官方手册中，`0x00000000` 地址是保留的。芯片厂商（如 ST）通常会实现为：MCU 上电后，硬件自动将存储在该地址的值加载到主堆栈指针（MSP）。
- FreeRTOS 等操作系统会利用这个机制，在内核启动后重新初始化 MSP。
- 实验验证：可以将此值定义为 0，只要在 `Reset_Handler` 中和内核启动后，通过代码将 MSP 设置为正确的 RAM 地址即可。

# ESP32实时操作系统与多任务编程

## 📋 概述

ESP32运行FreeRTOS实时操作系统，支持多任务并发处理。本文深入介绍FreeRTOS任务管理、同步机制、内存管理和性能优化技术，帮助开发者构建高效的多任务嵌入式应用系统。

## 🎯 FreeRTOS基础架构

### 系统架构概览

```
┌─────────────────────────────────────────────────────────┐
│                    应用层任务                            │
├─────────────────────────────────────────────────────────┤
│  Task1    Task2    Task3    Timer    ISR Handler       │
├─────────────────────────────────────────────────────────┤
│                 FreeRTOS内核                            │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │
│  │  任务调度器  │ │  内存管理   │ │  同步原语   │       │
│  └─────────────┘ └─────────────┘ └─────────────┘       │
├─────────────────────────────────────────────────────────┤
│                  ESP-IDF组件                            │
│  WiFi驱动  │  蓝牙栈  │  外设驱动  │  网络协议栈       │
├─────────────────────────────────────────────────────────┤
│              ESP32硬件抽象层(HAL)                       │
│  CPU0(PRO) │  CPU1(APP) │  WiFi │  蓝牙 │  外设        │
└─────────────────────────────────────────────────────────┘
```

### 系统配置参数

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "freertos/timers.h"
#include "esp_system.h"
#include "esp_log.h"

static const char *TAG = "RTOS_SYSTEM";

// 系统配置信息显示
void show_system_info(void)
{
    ESP_LOGI(TAG, "=== ESP32 FreeRTOS系统信息 ===");
    ESP_LOGI(TAG, "CPU频率: %d MHz", esp_clk_cpu_freq() / 1000000);
    ESP_LOGI(TAG, "FreeRTOS版本: %s", tskKERNEL_VERSION_NUMBER);
    ESP_LOGI(TAG, "系统时钟频率: %d Hz", configTICK_RATE_HZ);
    ESP_LOGI(TAG, "最大任务优先级: %d", configMAX_PRIORITIES);
    ESP_LOGI(TAG, "最小栈空间: %d bytes", configMINIMAL_STACK_SIZE);
    ESP_LOGI(TAG, "堆内存总大小: %d bytes", esp_get_free_heap_size() + heap_caps_get_total_size(MALLOC_CAP_8BIT) - esp_get_free_heap_size());
    ESP_LOGI(TAG, "空闲堆内存: %d bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "最小剩余堆内存: %d bytes", esp_get_minimum_free_heap_size());
    
    // 显示双核信息
    ESP_LOGI(TAG, "CPU核心数: 2");
    ESP_LOGI(TAG, "当前运行核心: %d", xPortGetCoreID());
    
    // 任务统计
    UBaseType_t task_count = uxTaskGetNumberOfTasks();
    ESP_LOGI(TAG, "当前任务数量: %d", task_count);
}

// 内存使用情况监控
void memory_monitor_task(void *pvParameters)
{
    uint32_t free_heap_size;
    uint32_t min_free_heap_size;
    
    while (1) {
        free_heap_size = esp_get_free_heap_size();
        min_free_heap_size = esp_get_minimum_free_heap_size();
        
        ESP_LOGI(TAG, "堆内存状态 - 可用: %u bytes, 历史最小: %u bytes", 
                 free_heap_size, min_free_heap_size);
        
        // 内存不足警告
        if (free_heap_size < 10240) {  // 小于10KB
            ESP_LOGW(TAG, "警告：可用内存不足！");
        }
        
        vTaskDelay(pdMS_TO_TICKS(10000));  // 10秒检查一次
    }
}
```

## 🏗️ 任务管理与调度

### 任务创建与管理

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// 任务参数结构
typedef struct {
    const char *name;
    TaskFunction_t function;
    uint32_t stack_size;
    UBaseType_t priority;
    BaseType_t core_id;  // -1表示不绑定核心
    TaskHandle_t *handle;
} task_config_t;

// 任务句柄
static TaskHandle_t led_task_handle = NULL;
static TaskHandle_t sensor_task_handle = NULL;
static TaskHandle_t communication_task_handle = NULL;
static TaskHandle_t data_process_task_handle = NULL;

// LED控制任务（高优先级，实时性要求高）
void led_control_task(void *pvParameters)
{
    ESP_LOGI(TAG, "LED控制任务启动 - 核心: %d", xPortGetCoreID());
    
    while (1) {
        // LED闪烁逻辑
        gpio_set_level(GPIO_NUM_2, 1);
        vTaskDelay(pdMS_TO_TICKS(500));
        
        gpio_set_level(GPIO_NUM_2, 0);
        vTaskDelay(pdMS_TO_TICKS(500));
        
        // 检查任务栈使用情况
        UBaseType_t high_water_mark = uxTaskGetStackHighWaterMark(NULL);
        if (high_water_mark < 100) {  // 剩余栈空间小于100字节
            ESP_LOGW(TAG, "LED任务栈空间不足: %d bytes", high_water_mark);
        }
    }
}

// 传感器采集任务（中等优先级）
void sensor_collection_task(void *pvParameters)
{
    ESP_LOGI(TAG, "传感器采集任务启动 - 核心: %d", xPortGetCoreID());
    
    TickType_t last_wake_time = xTaskGetTickCount();
    
    while (1) {
        // 传感器数据采集
        float temperature = read_temperature();
        float humidity = read_humidity();
        
        ESP_LOGI(TAG, "传感器读数 - 温度: %.1f°C, 湿度: %.1f%%", temperature, humidity);
        
        // 精确周期延时（1秒）
        vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(1000));
    }
}

// 数据处理任务（低优先级，CPU密集型）
void data_processing_task(void *pvParameters)
{
    ESP_LOGI(TAG, "数据处理任务启动 - 核心: %d", xPortGetCoreID());
    
    while (1) {
        // 模拟数据处理（CPU密集型操作）
        for (int i = 0; i < 1000000; i++) {
            // 复杂计算
            volatile float result = sqrt(i) * sin(i);
            (void)result;  // 避免编译器优化
        }
        
        ESP_LOGI(TAG, "数据处理完成一轮");
        
        // 主动让出CPU给其他任务
        taskYIELD();
        
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// 通信任务（中等优先级）
void communication_task(void *pvParameters)
{
    ESP_LOGI(TAG, "通信任务启动 - 核心: %d", xPortGetCoreID());
    
    while (1) {
        // 模拟网络通信
        ESP_LOGI(TAG, "发送数据到服务器...");
        
        // 模拟网络延时
        vTaskDelay(pdMS_TO_TICKS(2000));
        
        ESP_LOGI(TAG, "数据发送完成");
        
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}

// 批量创建任务
esp_err_t create_application_tasks(void)
{
    BaseType_t result;
    
    // 任务配置表
    task_config_t tasks[] = {
        {
            .name = "led_task",
            .function = led_control_task,
            .stack_size = 2048,
            .priority = 3,  // 高优先级
            .core_id = 0,   // 绑定到核心0
            .handle = &led_task_handle
        },
        {
            .name = "sensor_task",
            .function = sensor_collection_task,
            .stack_size = 4096,
            .priority = 2,  // 中等优先级
            .core_id = 1,   // 绑定到核心1
            .handle = &sensor_task_handle
        },
        {
            .name = "comm_task",
            .function = communication_task,
            .stack_size = 8192,
            .priority = 2,  // 中等优先级
            .core_id = -1,  // 不绑定核心
            .handle = &communication_task_handle
        },
        {
            .name = "data_process_task",
            .function = data_processing_task,
            .stack_size = 4096,
            .priority = 1,  // 低优先级
            .core_id = 1,   // 绑定到核心1
            .handle = &data_process_task_handle
        }
    };
    
    // 创建所有任务
    for (int i = 0; i < sizeof(tasks) / sizeof(task_config_t); i++) {
        if (tasks[i].core_id >= 0) {
            // 绑定到特定核心
            result = xTaskCreatePinnedToCore(
                tasks[i].function,
                tasks[i].name,
                tasks[i].stack_size,
                NULL,
                tasks[i].priority,
                tasks[i].handle,
                tasks[i].core_id
            );
        } else {
            // 不绑定核心
            result = xTaskCreate(
                tasks[i].function,
                tasks[i].name,
                tasks[i].stack_size,
                NULL,
                tasks[i].priority,
                tasks[i].handle
            );
        }
        
        if (result != pdPASS) {
            ESP_LOGE(TAG, "创建任务失败: %s", tasks[i].name);
            return ESP_FAIL;
        }
        
        ESP_LOGI(TAG, "任务创建成功: %s (优先级: %d, 核心: %d)", 
                 tasks[i].name, tasks[i].priority, tasks[i].core_id);
    }
    
    return ESP_OK;
}

// 动态任务管理
void task_manager_operations(void)
{
    // 暂停任务
    if (sensor_task_handle != NULL) {
        vTaskSuspend(sensor_task_handle);
        ESP_LOGI(TAG, "传感器任务已暂停");
    }
    
    vTaskDelay(pdMS_TO_TICKS(5000));
    
    // 恢复任务
    if (sensor_task_handle != NULL) {
        vTaskResume(sensor_task_handle);
        ESP_LOGI(TAG, "传感器任务已恢复");
    }
    
    // 修改任务优先级
    if (data_process_task_handle != NULL) {
        vTaskPrioritySet(data_process_task_handle, 3);  // 提高优先级
        ESP_LOGI(TAG, "数据处理任务优先级已提高到3");
    }
    
    vTaskDelay(pdMS_TO_TICKS(5000));
    
    // 恢复原优先级
    if (data_process_task_handle != NULL) {
        vTaskPrioritySet(data_process_task_handle, 1);
        ESP_LOGI(TAG, "数据处理任务优先级已恢复到1");
    }
}
```

### 任务状态监控系统

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// 任务状态统计
void print_task_statistics(void)
{
    char *task_list_buffer;
    char *runtime_stats_buffer;
    
    // 分配缓冲区
    task_list_buffer = malloc(2048);
    runtime_stats_buffer = malloc(2048);
    
    if (task_list_buffer != NULL && runtime_stats_buffer != NULL) {
        ESP_LOGI(TAG, "\n=== 任务列表 ===");
        ESP_LOGI(TAG, "任务名\t\t状态\t优先级\t栈剩余\t任务号");
        
        vTaskList(task_list_buffer);
        ESP_LOGI(TAG, "%s", task_list_buffer);
        
        ESP_LOGI(TAG, "\n=== 运行时统计 ===");
        ESP_LOGI(TAG, "任务名\t\t运行时间\t\t百分比");
        
        vTaskGetRunTimeStats(runtime_stats_buffer);
        ESP_LOGI(TAG, "%s", runtime_stats_buffer);
    }
    
    // 释放缓冲区
    if (task_list_buffer) free(task_list_buffer);
    if (runtime_stats_buffer) free(runtime_stats_buffer);
}

// 任务看门狗监控
typedef struct {
    TaskHandle_t task_handle;
    const char *task_name;
    uint32_t last_checkin;
    uint32_t timeout_ms;
    bool enabled;
} task_watchdog_t;

#define MAX_WATCHED_TASKS 10
static task_watchdog_t watched_tasks[MAX_WATCHED_TASKS];
static int watched_task_count = 0;

// 添加任务到看门狗
esp_err_t watchdog_add_task(TaskHandle_t task_handle, const char *name, uint32_t timeout_ms)
{
    if (watched_task_count >= MAX_WATCHED_TASKS) {
        return ESP_ERR_NO_MEM;
    }
    
    watched_tasks[watched_task_count] = (task_watchdog_t){
        .task_handle = task_handle,
        .task_name = name,
        .last_checkin = xTaskGetTickCount(),
        .timeout_ms = timeout_ms,
        .enabled = true
    };
    
    watched_task_count++;
    ESP_LOGI(TAG, "任务 %s 已添加到看门狗 (超时: %u ms)", name, timeout_ms);
    
    return ESP_OK;
}

// 任务签到
void watchdog_checkin(TaskHandle_t task_handle)
{
    for (int i = 0; i < watched_task_count; i++) {
        if (watched_tasks[i].task_handle == task_handle && watched_tasks[i].enabled) {
            watched_tasks[i].last_checkin = xTaskGetTickCount();
            break;
        }
    }
}

// 看门狗监控任务
void watchdog_monitor_task(void *pvParameters)
{
    ESP_LOGI(TAG, "任务看门狗监控启动");
    
    while (1) {
        uint32_t current_time = xTaskGetTickCount();
        
        for (int i = 0; i < watched_task_count; i++) {
            if (!watched_tasks[i].enabled) continue;
            
            uint32_t elapsed = (current_time - watched_tasks[i].last_checkin) * portTICK_PERIOD_MS;
            
            if (elapsed > watched_tasks[i].timeout_ms) {
                ESP_LOGE(TAG, "任务超时检测: %s (已超时 %u ms)", 
                         watched_tasks[i].task_name, elapsed);
                
                // 可以在这里执行恢复操作，如重启任务
                // restart_task(watched_tasks[i].task_handle);
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(1000));  // 每秒检查一次
    }
}
```

## 🔄 任务间同步与通信

### 队列通信机制

```c
#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/task.h"

// 消息类型定义
typedef enum {
    MSG_TYPE_SENSOR_DATA,
    MSG_TYPE_USER_INPUT,
    MSG_TYPE_NETWORK_EVENT,
    MSG_TYPE_SYSTEM_ALARM,
    MSG_TYPE_MAX
} message_type_t;

// 通用消息结构
typedef struct {
    message_type_t type;
    uint32_t timestamp;
    uint16_t data_length;
    uint8_t data[128];  // 消息数据
    uint8_t priority;   // 消息优先级
} queue_message_t;

// 传感器数据消息
typedef struct {
    float temperature;
    float humidity;
    float pressure;
    uint8_t sensor_id;
} sensor_data_message_t;

// 队列句柄
static QueueHandle_t sensor_data_queue;
static QueueHandle_t system_event_queue;
static QueueHandle_t high_priority_queue;

// 队列初始化
esp_err_t queue_system_init(void)
{
    // 创建传感器数据队列
    sensor_data_queue = xQueueCreate(20, sizeof(sensor_data_message_t));
    if (!sensor_data_queue) {
        ESP_LOGE(TAG, "创建传感器数据队列失败");
        return ESP_FAIL;
    }
    
    // 创建系统事件队列
    system_event_queue = xQueueCreate(10, sizeof(queue_message_t));
    if (!system_event_queue) {
        ESP_LOGE(TAG, "创建系统事件队列失败");
        return ESP_FAIL;
    }
    
    // 创建高优先级队列
    high_priority_queue = xQueueCreate(5, sizeof(queue_message_t));
    if (!high_priority_queue) {
        ESP_LOGE(TAG, "创建高优先级队列失败");
        return ESP_FAIL;
    }
    
    ESP_LOGI(TAG, "队列系统初始化完成");
    return ESP_OK;
}

// 传感器数据生产者任务
void sensor_data_producer_task(void *pvParameters)
{
    sensor_data_message_t sensor_msg;
    BaseType_t result;
    
    ESP_LOGI(TAG, "传感器数据生产者启动");
    
    while (1) {
        // 模拟传感器数据读取
        sensor_msg.temperature = 20.0 + (rand() % 200) / 10.0;  // 20-40°C
        sensor_msg.humidity = 30.0 + (rand() % 400) / 10.0;     // 30-70%
        sensor_msg.pressure = 1000.0 + (rand() % 100);          // 1000-1100hPa
        sensor_msg.sensor_id = 1;
        
        // 发送到队列（非阻塞）
        result = xQueueSend(sensor_data_queue, &sensor_msg, 0);
        if (result == pdTRUE) {
            ESP_LOGI(TAG, "传感器数据已发送 - T:%.1f H:%.1f P:%.1f", 
                     sensor_msg.temperature, sensor_msg.humidity, sensor_msg.pressure);
        } else {
            ESP_LOGW(TAG, "传感器数据队列满，数据丢失");
        }
        
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

// 传感器数据消费者任务
void sensor_data_consumer_task(void *pvParameters)
{
    sensor_data_message_t received_msg;
    BaseType_t result;
    
    ESP_LOGI(TAG, "传感器数据消费者启动");
    
    while (1) {
        // 从队列接收数据（阻塞等待）
        result = xQueueReceive(sensor_data_queue, &received_msg, portMAX_DELAY);
        if (result == pdTRUE) {
            ESP_LOGI(TAG, "处理传感器数据 - 传感器%d: T=%.1f°C, H=%.1f%%, P=%.1fhPa", 
                     received_msg.sensor_id,
                     received_msg.temperature,
                     received_msg.humidity,
                     received_msg.pressure);
            
            // 数据处理逻辑
            process_sensor_data(&received_msg);
        }
    }
}

// 系统事件处理任务
void system_event_handler_task(void *pvParameters)
{
    queue_message_t event_msg;
    BaseType_t result;
    
    ESP_LOGI(TAG, "系统事件处理器启动");
    
    while (1) {
        // 优先处理高优先级队列
        result = xQueueReceive(high_priority_queue, &event_msg, 0);
        if (result == pdTRUE) {
            ESP_LOGW(TAG, "处理高优先级事件: %d", event_msg.type);
            handle_high_priority_event(&event_msg);
            continue;
        }
        
        // 处理普通系统事件
        result = xQueueReceive(system_event_queue, &event_msg, pdMS_TO_TICKS(100));
        if (result == pdTRUE) {
            ESP_LOGI(TAG, "处理系统事件: %d (时间戳: %u)", 
                     event_msg.type, event_msg.timestamp);
            handle_system_event(&event_msg);
        }
    }
}

// 发送系统消息
esp_err_t send_system_message(message_type_t type, uint8_t *data, uint16_t length, uint8_t priority)
{
    queue_message_t msg;
    QueueHandle_t target_queue;
    
    if (length > sizeof(msg.data)) {
        ESP_LOGE(TAG, "消息数据过长: %d", length);
        return ESP_ERR_INVALID_SIZE;
    }
    
    // 构造消息
    msg.type = type;
    msg.timestamp = xTaskGetTickCount();
    msg.data_length = length;
    msg.priority = priority;
    memcpy(msg.data, data, length);
    
    // 根据优先级选择队列
    target_queue = (priority > 5) ? high_priority_queue : system_event_queue;
    
    // 发送消息
    BaseType_t result = xQueueSend(target_queue, &msg, pdMS_TO_TICKS(100));
    if (result != pdTRUE) {
        ESP_LOGW(TAG, "发送系统消息失败: 队列满");
        return ESP_FAIL;
    }
    
    return ESP_OK;
}

// 队列状态监控
void monitor_queue_status(void)
{
    UBaseType_t sensor_queue_count = uxQueueMessagesWaiting(sensor_data_queue);
    UBaseType_t event_queue_count = uxQueueMessagesWaiting(system_event_queue);
    UBaseType_t hp_queue_count = uxQueueMessagesWaiting(high_priority_queue);
    
    ESP_LOGI(TAG, "队列状态 - 传感器: %d, 系统事件: %d, 高优先级: %d", 
             sensor_queue_count, event_queue_count, hp_queue_count);
    
    // 队列使用率警告
    if (sensor_queue_count > 15) {  // 队列容量20，使用率75%
        ESP_LOGW(TAG, "传感器数据队列使用率过高");
    }
}
```

### 信号量与互斥锁

```c
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "freertos/task.h"

// 同步原语句柄
static SemaphoreHandle_t binary_semaphore;      // 二进制信号量
static SemaphoreHandle_t counting_semaphore;    // 计数信号量
static SemaphoreHandle_t mutex_semaphore;       // 互斥锁
static SemaphoreHandle_t recursive_mutex;       // 递归互斥锁

// 共享资源
static int shared_counter = 0;
static char shared_buffer[256];

// 同步原语初始化
esp_err_t sync_primitives_init(void)
{
    // 创建二进制信号量
    binary_semaphore = xSemaphoreCreateBinary();
    if (!binary_semaphore) {
        ESP_LOGE(TAG, "创建二进制信号量失败");
        return ESP_FAIL;
    }
    
    // 创建计数信号量（最大值5）
    counting_semaphore = xSemaphoreCreateCounting(5, 0);
    if (!counting_semaphore) {
        ESP_LOGE(TAG, "创建计数信号量失败");
        return ESP_FAIL;
    }
    
    // 创建互斥锁
    mutex_semaphore = xSemaphoreCreateMutex();
    if (!mutex_semaphore) {
        ESP_LOGE(TAG, "创建互斥锁失败");
        return ESP_FAIL;
    }
    
    // 创建递归互斥锁
    recursive_mutex = xSemaphoreCreateRecursiveMutex();
    if (!recursive_mutex) {
        ESP_LOGE(TAG, "创建递归互斥锁失败");
        return ESP_FAIL;
    }
    
    ESP_LOGI(TAG, "同步原语初始化完成");
    return ESP_OK;
}

// 生产者任务（使用计数信号量）
void producer_task(void *pvParameters)
{
    int producer_id = (int)pvParameters;
    
    ESP_LOGI(TAG, "生产者%d启动", producer_id);
    
    while (1) {
        // 模拟生产过程
        vTaskDelay(pdMS_TO_TICKS(1000 + rand() % 2000));
        
        // 释放信号量（表示生产了一个产品）
        xSemaphoreGive(counting_semaphore);
        ESP_LOGI(TAG, "生产者%d生产了一个产品", producer_id);
        
        // 检查信号量计数
        UBaseType_t count = uxSemaphoreGetCount(counting_semaphore);
        ESP_LOGI(TAG, "当前产品数量: %d", count);
    }
}

// 消费者任务（使用计数信号量）
void consumer_task(void *pvParameters)
{
    int consumer_id = (int)pvParameters;
    
    ESP_LOGI(TAG, "消费者%d启动", consumer_id);
    
    while (1) {
        // 等待产品（获取信号量）
        if (xSemaphoreTake(counting_semaphore, pdMS_TO_TICKS(5000)) == pdTRUE) {
            ESP_LOGI(TAG, "消费者%d消费了一个产品", consumer_id);
            
            // 模拟消费过程
            vTaskDelay(pdMS_TO_TICKS(500 + rand() % 1000));
        } else {
            ESP_LOGW(TAG, "消费者%d等待超时，没有产品可消费", consumer_id);
        }
    }
}

// 写入任务（使用互斥锁保护共享资源）
void writer_task(void *pvParameters)
{
    int writer_id = (int)pvParameters;
    
    ESP_LOGI(TAG, "写入任务%d启动", writer_id);
    
    while (1) {
        // 获取互斥锁
        if (xSemaphoreTake(mutex_semaphore, pdMS_TO_TICKS(1000)) == pdTRUE) {
            ESP_LOGI(TAG, "写入任务%d获得锁，开始写入", writer_id);
            
            // 临界区：修改共享资源
            shared_counter++;
            snprintf(shared_buffer, sizeof(shared_buffer), 
                    "Writer%d - Count: %d - Time: %u", 
                    writer_id, shared_counter, xTaskGetTickCount());
            
            ESP_LOGI(TAG, "写入完成: %s", shared_buffer);
            
            // 模拟写入操作耗时
            vTaskDelay(pdMS_TO_TICKS(200));
            
            // 释放互斥锁
            xSemaphoreGive(mutex_semaphore);
            ESP_LOGI(TAG, "写入任务%d释放锁", writer_id);
        } else {
            ESP_LOGW(TAG, "写入任务%d获取锁超时", writer_id);
        }
        
        vTaskDelay(pdMS_TO_TICKS(1500));
    }
}

// 读取任务（使用互斥锁保护共享资源）
void reader_task(void *pvParameters)
{
    int reader_id = (int)pvParameters;
    char local_buffer[256];
    int local_counter;
    
    ESP_LOGI(TAG, "读取任务%d启动", reader_id);
    
    while (1) {
        // 获取互斥锁
        if (xSemaphoreTake(mutex_semaphore, pdMS_TO_TICKS(1000)) == pdTRUE) {
            ESP_LOGI(TAG, "读取任务%d获得锁，开始读取", reader_id);
            
            // 临界区：读取共享资源
            local_counter = shared_counter;
            strncpy(local_buffer, shared_buffer, sizeof(local_buffer));
            
            // 模拟读取操作耗时
            vTaskDelay(pdMS_TO_TICKS(100));
            
            // 释放互斥锁
            xSemaphoreGive(mutex_semaphore);
            
            ESP_LOGI(TAG, "读取任务%d读取到: %s (计数: %d)", 
                     reader_id, local_buffer, local_counter);
        } else {
            ESP_LOGW(TAG, "读取任务%d获取锁超时", reader_id);
        }
        
        vTaskDelay(pdMS_TO_TICKS(800));
    }
}

// 递归函数示例（使用递归互斥锁）
void recursive_function(int depth, int max_depth)
{
    if (depth > max_depth) {
        return;
    }
    
    // 获取递归互斥锁
    if (xSemaphoreTakeRecursive(recursive_mutex, pdMS_TO_TICKS(1000)) == pdTRUE) {
        ESP_LOGI(TAG, "递归深度 %d - 获得递归锁", depth);
        
        // 递归调用
        if (depth < max_depth) {
            recursive_function(depth + 1, max_depth);
        }
        
        // 释放递归互斥锁
        xSemaphoreGiveRecursive(recursive_mutex);
        ESP_LOGI(TAG, "递归深度 %d - 释放递归锁", depth);
    }
}

// 递归测试任务
void recursive_test_task(void *pvParameters)
{
    ESP_LOGI(TAG, "递归测试任务启动");
    
    while (1) {
        ESP_LOGI(TAG, "开始递归测试...");
        recursive_function(1, 5);
        ESP_LOGI(TAG, "递归测试完成");
        
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}

// 创建同步测试任务
void create_sync_test_tasks(void)
{
    // 创建生产者消费者任务
    xTaskCreate(producer_task, "producer1", 2048, (void*)1, 2, NULL);
    xTaskCreate(producer_task, "producer2", 2048, (void*)2, 2, NULL);
    xTaskCreate(consumer_task, "consumer1", 2048, (void*)1, 2, NULL);
    xTaskCreate(consumer_task, "consumer2", 2048, (void*)2, 2, NULL);
    
    // 创建读写任务
    xTaskCreate(writer_task, "writer1", 2048, (void*)1, 3, NULL);
    xTaskCreate(writer_task, "writer2", 2048, (void*)2, 3, NULL);
    xTaskCreate(reader_task, "reader1", 2048, (void*)1, 2, NULL);
    xTaskCreate(reader_task, "reader2", 2048, (void*)2, 2, NULL);
    
    // 创建递归测试任务
    xTaskCreate(recursive_test_task, "recursive_test", 2048, NULL, 1, NULL);
}
```

## ⏰ 软件定时器

```c
#include "freertos/FreeRTOS.h"
#include "freertos/timers.h"
#include "freertos/task.h"

// 定时器句柄
static TimerHandle_t periodic_timer;
static TimerHandle_t oneshot_timer;
static TimerHandle_t heartbeat_timer;
static TimerHandle_t timeout_timer;

// 定时器回调函数
void periodic_timer_callback(TimerHandle_t xTimer)
{
    static int counter = 0;
    counter++;
    
    ESP_LOGI(TAG, "周期定时器触发 - 计数: %d", counter);
    
    // 每10次重置计数器
    if (counter >= 10) {
        counter = 0;
        ESP_LOGI(TAG, "计数器重置");
    }
}

void oneshot_timer_callback(TimerHandle_t xTimer)
{
    ESP_LOGI(TAG, "单次定时器触发");
    
    // 可以在这里重新启动定时器
    // xTimerStart(oneshot_timer, 0);
}

void heartbeat_timer_callback(TimerHandle_t xTimer)
{
    static bool led_state = false;
    
    // 心跳LED闪烁
    led_state = !led_state;
    gpio_set_level(GPIO_NUM_2, led_state);
    
    ESP_LOGI(TAG, "心跳信号 - LED: %s", led_state ? "ON" : "OFF");
}

void timeout_timer_callback(TimerHandle_t xTimer)
{
    ESP_LOGW(TAG, "操作超时！执行超时处理...");
    
    // 超时处理逻辑
    handle_timeout_event();
}

// 软件定时器初始化
esp_err_t software_timers_init(void)
{
    // 创建周期定时器（每2秒触发）
    periodic_timer = xTimerCreate(
        "periodic_timer",           // 定时器名称
        pdMS_TO_TICKS(2000),       // 周期 2秒
        pdTRUE,                    // 自动重载
        (void*)1,                  // 定时器ID
        periodic_timer_callback    // 回调函数
    );
    
    if (!periodic_timer) {
        ESP_LOGE(TAG, "创建周期定时器失败");
        return ESP_FAIL;
    }
    
    // 创建单次定时器（5秒后触发）
    oneshot_timer = xTimerCreate(
        "oneshot_timer",
        pdMS_TO_TICKS(5000),
        pdFALSE,                   // 不自动重载
        (void*)2,
        oneshot_timer_callback
    );
    
    if (!oneshot_timer) {
        ESP_LOGE(TAG, "创建单次定时器失败");
        return ESP_FAIL;
    }
    
    // 创建心跳定时器（每500ms触发）
    heartbeat_timer = xTimerCreate(
        "heartbeat_timer",
        pdMS_TO_TICKS(500),
        pdTRUE,
        (void*)3,
        heartbeat_timer_callback
    );
    
    if (!heartbeat_timer) {
        ESP_LOGE(TAG, "创建心跳定时器失败");
        return ESP_FAIL;
    }
    
    // 创建超时定时器（10秒超时）
    timeout_timer = xTimerCreate(
        "timeout_timer",
        pdMS_TO_TICKS(10000),
        pdFALSE,
        (void*)4,
        timeout_timer_callback
    );
    
    if (!timeout_timer) {
        ESP_LOGE(TAG, "创建超时定时器失败");
        return ESP_FAIL;
    }
    
    ESP_LOGI(TAG, "软件定时器初始化完成");
    return ESP_OK;
}

// 定时器控制任务
void timer_control_task(void *pvParameters)
{
    ESP_LOGI(TAG, "定时器控制任务启动");
    
    // 启动周期定时器和心跳定时器
    xTimerStart(periodic_timer, 0);
    xTimerStart(heartbeat_timer, 0);
    
    vTaskDelay(pdMS_TO_TICKS(3000));
    
    // 启动单次定时器
    ESP_LOGI(TAG, "启动单次定时器");
    xTimerStart(oneshot_timer, 0);
    
    vTaskDelay(pdMS_TO_TICKS(7000));
    
    // 修改周期定时器的周期
    ESP_LOGI(TAG, "修改周期定时器周期为1秒");
    xTimerChangePeriod(periodic_timer, pdMS_TO_TICKS(1000), 0);
    
    vTaskDelay(pdMS_TO_TICKS(5000));
    
    // 停止心跳定时器
    ESP_LOGI(TAG, "停止心跳定时器");
    xTimerStop(heartbeat_timer, 0);
    
    vTaskDelay(pdMS_TO_TICKS(3000));
    
    // 重新启动心跳定时器
    ESP_LOGI(TAG, "重新启动心跳定时器");
    xTimerStart(heartbeat_timer, 0);
    
    while (1) {
        // 模拟需要超时保护的操作
        ESP_LOGI(TAG, "开始操作，启动超时保护");
        xTimerStart(timeout_timer, 0);
        
        // 模拟操作（随机成功或失败）
        int operation_time = 2000 + rand() % 10000;  // 2-12秒
        vTaskDelay(pdMS_TO_TICKS(operation_time));
        
        // 操作完成，停止超时定时器
        if (xTimerIsTimerActive(timeout_timer)) {
            ESP_LOGI(TAG, "操作完成，停止超时保护");
            xTimerStop(timeout_timer, 0);
        }
        
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}

// 动态定时器创建示例
TimerHandle_t create_dynamic_timer(const char *name, uint32_t period_ms, 
                                  bool auto_reload, TimerCallbackFunction_t callback)
{
    TimerHandle_t timer = xTimerCreate(
        name,
        pdMS_TO_TICKS(period_ms),
        auto_reload ? pdTRUE : pdFALSE,
        NULL,
        callback
    );
    
    if (timer) {
        ESP_LOGI(TAG, "动态创建定时器: %s (周期: %u ms)", name, period_ms);
    } else {
        ESP_LOGE(TAG, "动态创建定时器失败: %s", name);
    }
    
    return timer;
}

// 定时器管理器
typedef struct {
    TimerHandle_t timer;
    const char *name;
    bool active;
    uint32_t period_ms;
} timer_info_t;

#define MAX_MANAGED_TIMERS 10
static timer_info_t managed_timers[MAX_MANAGED_TIMERS];
static int managed_timer_count = 0;

// 添加定时器到管理器
esp_err_t timer_manager_add(TimerHandle_t timer, const char *name, uint32_t period_ms)
{
    if (managed_timer_count >= MAX_MANAGED_TIMERS) {
        return ESP_ERR_NO_MEM;
    }
    
    managed_timers[managed_timer_count] = (timer_info_t){
        .timer = timer,
        .name = name,
        .active = false,
        .period_ms = period_ms
    };
    
    managed_timer_count++;
    return ESP_OK;
}

// 显示定时器状态
void show_timer_status(void)
{
    ESP_LOGI(TAG, "=== 定时器状态 ===");
    
    for (int i = 0; i < managed_timer_count; i++) {
        timer_info_t *info = &managed_timers[i];
        bool is_active = xTimerIsTimerActive(info->timer);
        TickType_t remaining = xTimerGetExpiryTime(info->timer) - xTaskGetTickCount();
        
        ESP_LOGI(TAG, "%s: %s, 周期: %u ms, 剩余时间: %u ms", 
                 info->name,
                 is_active ? "运行中" : "已停止",
                 info->period_ms,
                 (uint32_t)(remaining * portTICK_PERIOD_MS));
    }
}
```

---

> **FreeRTOS总结**：ESP32的FreeRTOS系统提供了强大的多任务处理能力。通过合理的任务设计、优先级配置、同步机制和定时器使用，可以构建高效稳定的实时系统。关键是要理解调度原理、避免优先级反转、合理使用同步原语，并进行充分的任务监控和性能分析。

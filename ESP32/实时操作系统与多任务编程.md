# ESP32å®æ—¶æ“ä½œç³»ç»Ÿä¸å¤šä»»åŠ¡ç¼–ç¨‹

## ğŸ“‹ æ¦‚è¿°

ESP32è¿è¡ŒFreeRTOSå®æ—¶æ“ä½œç³»ç»Ÿï¼Œæ”¯æŒå¤šä»»åŠ¡å¹¶å‘å¤„ç†ã€‚æœ¬æ–‡æ·±å…¥ä»‹ç»FreeRTOSä»»åŠ¡ç®¡ç†ã€åŒæ­¥æœºåˆ¶ã€å†…å­˜ç®¡ç†å’Œæ€§èƒ½ä¼˜åŒ–æŠ€æœ¯ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºé«˜æ•ˆçš„å¤šä»»åŠ¡åµŒå…¥å¼åº”ç”¨ç³»ç»Ÿã€‚

## ğŸ¯ FreeRTOSåŸºç¡€æ¶æ„

### ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ä»»åŠ¡                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Task1    Task2    Task3    Timer    ISR Handler       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 FreeRTOSå†…æ ¸                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  ä»»åŠ¡è°ƒåº¦å™¨  â”‚ â”‚  å†…å­˜ç®¡ç†   â”‚ â”‚  åŒæ­¥åŸè¯­   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  ESP-IDFç»„ä»¶                            â”‚
â”‚  WiFié©±åŠ¨  â”‚  è“ç‰™æ ˆ  â”‚  å¤–è®¾é©±åŠ¨  â”‚  ç½‘ç»œåè®®æ ˆ       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              ESP32ç¡¬ä»¶æŠ½è±¡å±‚(HAL)                       â”‚
â”‚  CPU0(PRO) â”‚  CPU1(APP) â”‚  WiFi â”‚  è“ç‰™ â”‚  å¤–è®¾        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç³»ç»Ÿé…ç½®å‚æ•°

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "freertos/timers.h"
#include "esp_system.h"
#include "esp_log.h"

static const char *TAG = "RTOS_SYSTEM";

// ç³»ç»Ÿé…ç½®ä¿¡æ¯æ˜¾ç¤º
void show_system_info(void)
{
    ESP_LOGI(TAG, "=== ESP32 FreeRTOSç³»ç»Ÿä¿¡æ¯ ===");
    ESP_LOGI(TAG, "CPUé¢‘ç‡: %d MHz", esp_clk_cpu_freq() / 1000000);
    ESP_LOGI(TAG, "FreeRTOSç‰ˆæœ¬: %s", tskKERNEL_VERSION_NUMBER);
    ESP_LOGI(TAG, "ç³»ç»Ÿæ—¶é’Ÿé¢‘ç‡: %d Hz", configTICK_RATE_HZ);
    ESP_LOGI(TAG, "æœ€å¤§ä»»åŠ¡ä¼˜å…ˆçº§: %d", configMAX_PRIORITIES);
    ESP_LOGI(TAG, "æœ€å°æ ˆç©ºé—´: %d bytes", configMINIMAL_STACK_SIZE);
    ESP_LOGI(TAG, "å †å†…å­˜æ€»å¤§å°: %d bytes", esp_get_free_heap_size() + heap_caps_get_total_size(MALLOC_CAP_8BIT) - esp_get_free_heap_size());
    ESP_LOGI(TAG, "ç©ºé—²å †å†…å­˜: %d bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "æœ€å°å‰©ä½™å †å†…å­˜: %d bytes", esp_get_minimum_free_heap_size());
    
    // æ˜¾ç¤ºåŒæ ¸ä¿¡æ¯
    ESP_LOGI(TAG, "CPUæ ¸å¿ƒæ•°: 2");
    ESP_LOGI(TAG, "å½“å‰è¿è¡Œæ ¸å¿ƒ: %d", xPortGetCoreID());
    
    // ä»»åŠ¡ç»Ÿè®¡
    UBaseType_t task_count = uxTaskGetNumberOfTasks();
    ESP_LOGI(TAG, "å½“å‰ä»»åŠ¡æ•°é‡: %d", task_count);
}

// å†…å­˜ä½¿ç”¨æƒ…å†µç›‘æ§
void memory_monitor_task(void *pvParameters)
{
    uint32_t free_heap_size;
    uint32_t min_free_heap_size;
    
    while (1) {
        free_heap_size = esp_get_free_heap_size();
        min_free_heap_size = esp_get_minimum_free_heap_size();
        
        ESP_LOGI(TAG, "å †å†…å­˜çŠ¶æ€ - å¯ç”¨: %u bytes, å†å²æœ€å°: %u bytes", 
                 free_heap_size, min_free_heap_size);
        
        // å†…å­˜ä¸è¶³è­¦å‘Š
        if (free_heap_size < 10240) {  // å°äº10KB
            ESP_LOGW(TAG, "è­¦å‘Šï¼šå¯ç”¨å†…å­˜ä¸è¶³ï¼");
        }
        
        vTaskDelay(pdMS_TO_TICKS(10000));  // 10ç§’æ£€æŸ¥ä¸€æ¬¡
    }
}
```

## ğŸ—ï¸ ä»»åŠ¡ç®¡ç†ä¸è°ƒåº¦

### ä»»åŠ¡åˆ›å»ºä¸ç®¡ç†

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// ä»»åŠ¡å‚æ•°ç»“æ„
typedef struct {
    const char *name;
    TaskFunction_t function;
    uint32_t stack_size;
    UBaseType_t priority;
    BaseType_t core_id;  // -1è¡¨ç¤ºä¸ç»‘å®šæ ¸å¿ƒ
    TaskHandle_t *handle;
} task_config_t;

// ä»»åŠ¡å¥æŸ„
static TaskHandle_t led_task_handle = NULL;
static TaskHandle_t sensor_task_handle = NULL;
static TaskHandle_t communication_task_handle = NULL;
static TaskHandle_t data_process_task_handle = NULL;

// LEDæ§åˆ¶ä»»åŠ¡ï¼ˆé«˜ä¼˜å…ˆçº§ï¼Œå®æ—¶æ€§è¦æ±‚é«˜ï¼‰
void led_control_task(void *pvParameters)
{
    ESP_LOGI(TAG, "LEDæ§åˆ¶ä»»åŠ¡å¯åŠ¨ - æ ¸å¿ƒ: %d", xPortGetCoreID());
    
    while (1) {
        // LEDé—ªçƒé€»è¾‘
        gpio_set_level(GPIO_NUM_2, 1);
        vTaskDelay(pdMS_TO_TICKS(500));
        
        gpio_set_level(GPIO_NUM_2, 0);
        vTaskDelay(pdMS_TO_TICKS(500));
        
        // æ£€æŸ¥ä»»åŠ¡æ ˆä½¿ç”¨æƒ…å†µ
        UBaseType_t high_water_mark = uxTaskGetStackHighWaterMark(NULL);
        if (high_water_mark < 100) {  // å‰©ä½™æ ˆç©ºé—´å°äº100å­—èŠ‚
            ESP_LOGW(TAG, "LEDä»»åŠ¡æ ˆç©ºé—´ä¸è¶³: %d bytes", high_water_mark);
        }
    }
}

// ä¼ æ„Ÿå™¨é‡‡é›†ä»»åŠ¡ï¼ˆä¸­ç­‰ä¼˜å…ˆçº§ï¼‰
void sensor_collection_task(void *pvParameters)
{
    ESP_LOGI(TAG, "ä¼ æ„Ÿå™¨é‡‡é›†ä»»åŠ¡å¯åŠ¨ - æ ¸å¿ƒ: %d", xPortGetCoreID());
    
    TickType_t last_wake_time = xTaskGetTickCount();
    
    while (1) {
        // ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†
        float temperature = read_temperature();
        float humidity = read_humidity();
        
        ESP_LOGI(TAG, "ä¼ æ„Ÿå™¨è¯»æ•° - æ¸©åº¦: %.1fÂ°C, æ¹¿åº¦: %.1f%%", temperature, humidity);
        
        // ç²¾ç¡®å‘¨æœŸå»¶æ—¶ï¼ˆ1ç§’ï¼‰
        vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(1000));
    }
}

// æ•°æ®å¤„ç†ä»»åŠ¡ï¼ˆä½ä¼˜å…ˆçº§ï¼ŒCPUå¯†é›†å‹ï¼‰
void data_processing_task(void *pvParameters)
{
    ESP_LOGI(TAG, "æ•°æ®å¤„ç†ä»»åŠ¡å¯åŠ¨ - æ ¸å¿ƒ: %d", xPortGetCoreID());
    
    while (1) {
        // æ¨¡æ‹Ÿæ•°æ®å¤„ç†ï¼ˆCPUå¯†é›†å‹æ“ä½œï¼‰
        for (int i = 0; i < 1000000; i++) {
            // å¤æ‚è®¡ç®—
            volatile float result = sqrt(i) * sin(i);
            (void)result;  // é¿å…ç¼–è¯‘å™¨ä¼˜åŒ–
        }
        
        ESP_LOGI(TAG, "æ•°æ®å¤„ç†å®Œæˆä¸€è½®");
        
        // ä¸»åŠ¨è®©å‡ºCPUç»™å…¶ä»–ä»»åŠ¡
        taskYIELD();
        
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// é€šä¿¡ä»»åŠ¡ï¼ˆä¸­ç­‰ä¼˜å…ˆçº§ï¼‰
void communication_task(void *pvParameters)
{
    ESP_LOGI(TAG, "é€šä¿¡ä»»åŠ¡å¯åŠ¨ - æ ¸å¿ƒ: %d", xPortGetCoreID());
    
    while (1) {
        // æ¨¡æ‹Ÿç½‘ç»œé€šä¿¡
        ESP_LOGI(TAG, "å‘é€æ•°æ®åˆ°æœåŠ¡å™¨...");
        
        // æ¨¡æ‹Ÿç½‘ç»œå»¶æ—¶
        vTaskDelay(pdMS_TO_TICKS(2000));
        
        ESP_LOGI(TAG, "æ•°æ®å‘é€å®Œæˆ");
        
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}

// æ‰¹é‡åˆ›å»ºä»»åŠ¡
esp_err_t create_application_tasks(void)
{
    BaseType_t result;
    
    // ä»»åŠ¡é…ç½®è¡¨
    task_config_t tasks[] = {
        {
            .name = "led_task",
            .function = led_control_task,
            .stack_size = 2048,
            .priority = 3,  // é«˜ä¼˜å…ˆçº§
            .core_id = 0,   // ç»‘å®šåˆ°æ ¸å¿ƒ0
            .handle = &led_task_handle
        },
        {
            .name = "sensor_task",
            .function = sensor_collection_task,
            .stack_size = 4096,
            .priority = 2,  // ä¸­ç­‰ä¼˜å…ˆçº§
            .core_id = 1,   // ç»‘å®šåˆ°æ ¸å¿ƒ1
            .handle = &sensor_task_handle
        },
        {
            .name = "comm_task",
            .function = communication_task,
            .stack_size = 8192,
            .priority = 2,  // ä¸­ç­‰ä¼˜å…ˆçº§
            .core_id = -1,  // ä¸ç»‘å®šæ ¸å¿ƒ
            .handle = &communication_task_handle
        },
        {
            .name = "data_process_task",
            .function = data_processing_task,
            .stack_size = 4096,
            .priority = 1,  // ä½ä¼˜å…ˆçº§
            .core_id = 1,   // ç»‘å®šåˆ°æ ¸å¿ƒ1
            .handle = &data_process_task_handle
        }
    };
    
    // åˆ›å»ºæ‰€æœ‰ä»»åŠ¡
    for (int i = 0; i < sizeof(tasks) / sizeof(task_config_t); i++) {
        if (tasks[i].core_id >= 0) {
            // ç»‘å®šåˆ°ç‰¹å®šæ ¸å¿ƒ
            result = xTaskCreatePinnedToCore(
                tasks[i].function,
                tasks[i].name,
                tasks[i].stack_size,
                NULL,
                tasks[i].priority,
                tasks[i].handle,
                tasks[i].core_id
            );
        } else {
            // ä¸ç»‘å®šæ ¸å¿ƒ
            result = xTaskCreate(
                tasks[i].function,
                tasks[i].name,
                tasks[i].stack_size,
                NULL,
                tasks[i].priority,
                tasks[i].handle
            );
        }
        
        if (result != pdPASS) {
            ESP_LOGE(TAG, "åˆ›å»ºä»»åŠ¡å¤±è´¥: %s", tasks[i].name);
            return ESP_FAIL;
        }
        
        ESP_LOGI(TAG, "ä»»åŠ¡åˆ›å»ºæˆåŠŸ: %s (ä¼˜å…ˆçº§: %d, æ ¸å¿ƒ: %d)", 
                 tasks[i].name, tasks[i].priority, tasks[i].core_id);
    }
    
    return ESP_OK;
}

// åŠ¨æ€ä»»åŠ¡ç®¡ç†
void task_manager_operations(void)
{
    // æš‚åœä»»åŠ¡
    if (sensor_task_handle != NULL) {
        vTaskSuspend(sensor_task_handle);
        ESP_LOGI(TAG, "ä¼ æ„Ÿå™¨ä»»åŠ¡å·²æš‚åœ");
    }
    
    vTaskDelay(pdMS_TO_TICKS(5000));
    
    // æ¢å¤ä»»åŠ¡
    if (sensor_task_handle != NULL) {
        vTaskResume(sensor_task_handle);
        ESP_LOGI(TAG, "ä¼ æ„Ÿå™¨ä»»åŠ¡å·²æ¢å¤");
    }
    
    // ä¿®æ”¹ä»»åŠ¡ä¼˜å…ˆçº§
    if (data_process_task_handle != NULL) {
        vTaskPrioritySet(data_process_task_handle, 3);  // æé«˜ä¼˜å…ˆçº§
        ESP_LOGI(TAG, "æ•°æ®å¤„ç†ä»»åŠ¡ä¼˜å…ˆçº§å·²æé«˜åˆ°3");
    }
    
    vTaskDelay(pdMS_TO_TICKS(5000));
    
    // æ¢å¤åŸä¼˜å…ˆçº§
    if (data_process_task_handle != NULL) {
        vTaskPrioritySet(data_process_task_handle, 1);
        ESP_LOGI(TAG, "æ•°æ®å¤„ç†ä»»åŠ¡ä¼˜å…ˆçº§å·²æ¢å¤åˆ°1");
    }
}
```

### ä»»åŠ¡çŠ¶æ€ç›‘æ§ç³»ç»Ÿ

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// ä»»åŠ¡çŠ¶æ€ç»Ÿè®¡
void print_task_statistics(void)
{
    char *task_list_buffer;
    char *runtime_stats_buffer;
    
    // åˆ†é…ç¼“å†²åŒº
    task_list_buffer = malloc(2048);
    runtime_stats_buffer = malloc(2048);
    
    if (task_list_buffer != NULL && runtime_stats_buffer != NULL) {
        ESP_LOGI(TAG, "\n=== ä»»åŠ¡åˆ—è¡¨ ===");
        ESP_LOGI(TAG, "ä»»åŠ¡å\t\tçŠ¶æ€\tä¼˜å…ˆçº§\tæ ˆå‰©ä½™\tä»»åŠ¡å·");
        
        vTaskList(task_list_buffer);
        ESP_LOGI(TAG, "%s", task_list_buffer);
        
        ESP_LOGI(TAG, "\n=== è¿è¡Œæ—¶ç»Ÿè®¡ ===");
        ESP_LOGI(TAG, "ä»»åŠ¡å\t\tè¿è¡Œæ—¶é—´\t\tç™¾åˆ†æ¯”");
        
        vTaskGetRunTimeStats(runtime_stats_buffer);
        ESP_LOGI(TAG, "%s", runtime_stats_buffer);
    }
    
    // é‡Šæ”¾ç¼“å†²åŒº
    if (task_list_buffer) free(task_list_buffer);
    if (runtime_stats_buffer) free(runtime_stats_buffer);
}

// ä»»åŠ¡çœ‹é—¨ç‹—ç›‘æ§
typedef struct {
    TaskHandle_t task_handle;
    const char *task_name;
    uint32_t last_checkin;
    uint32_t timeout_ms;
    bool enabled;
} task_watchdog_t;

#define MAX_WATCHED_TASKS 10
static task_watchdog_t watched_tasks[MAX_WATCHED_TASKS];
static int watched_task_count = 0;

// æ·»åŠ ä»»åŠ¡åˆ°çœ‹é—¨ç‹—
esp_err_t watchdog_add_task(TaskHandle_t task_handle, const char *name, uint32_t timeout_ms)
{
    if (watched_task_count >= MAX_WATCHED_TASKS) {
        return ESP_ERR_NO_MEM;
    }
    
    watched_tasks[watched_task_count] = (task_watchdog_t){
        .task_handle = task_handle,
        .task_name = name,
        .last_checkin = xTaskGetTickCount(),
        .timeout_ms = timeout_ms,
        .enabled = true
    };
    
    watched_task_count++;
    ESP_LOGI(TAG, "ä»»åŠ¡ %s å·²æ·»åŠ åˆ°çœ‹é—¨ç‹— (è¶…æ—¶: %u ms)", name, timeout_ms);
    
    return ESP_OK;
}

// ä»»åŠ¡ç­¾åˆ°
void watchdog_checkin(TaskHandle_t task_handle)
{
    for (int i = 0; i < watched_task_count; i++) {
        if (watched_tasks[i].task_handle == task_handle && watched_tasks[i].enabled) {
            watched_tasks[i].last_checkin = xTaskGetTickCount();
            break;
        }
    }
}

// çœ‹é—¨ç‹—ç›‘æ§ä»»åŠ¡
void watchdog_monitor_task(void *pvParameters)
{
    ESP_LOGI(TAG, "ä»»åŠ¡çœ‹é—¨ç‹—ç›‘æ§å¯åŠ¨");
    
    while (1) {
        uint32_t current_time = xTaskGetTickCount();
        
        for (int i = 0; i < watched_task_count; i++) {
            if (!watched_tasks[i].enabled) continue;
            
            uint32_t elapsed = (current_time - watched_tasks[i].last_checkin) * portTICK_PERIOD_MS;
            
            if (elapsed > watched_tasks[i].timeout_ms) {
                ESP_LOGE(TAG, "ä»»åŠ¡è¶…æ—¶æ£€æµ‹: %s (å·²è¶…æ—¶ %u ms)", 
                         watched_tasks[i].task_name, elapsed);
                
                // å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œæ¢å¤æ“ä½œï¼Œå¦‚é‡å¯ä»»åŠ¡
                // restart_task(watched_tasks[i].task_handle);
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(1000));  // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
    }
}
```

## ğŸ”„ ä»»åŠ¡é—´åŒæ­¥ä¸é€šä¿¡

### é˜Ÿåˆ—é€šä¿¡æœºåˆ¶

```c
#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/task.h"

// æ¶ˆæ¯ç±»å‹å®šä¹‰
typedef enum {
    MSG_TYPE_SENSOR_DATA,
    MSG_TYPE_USER_INPUT,
    MSG_TYPE_NETWORK_EVENT,
    MSG_TYPE_SYSTEM_ALARM,
    MSG_TYPE_MAX
} message_type_t;

// é€šç”¨æ¶ˆæ¯ç»“æ„
typedef struct {
    message_type_t type;
    uint32_t timestamp;
    uint16_t data_length;
    uint8_t data[128];  // æ¶ˆæ¯æ•°æ®
    uint8_t priority;   // æ¶ˆæ¯ä¼˜å…ˆçº§
} queue_message_t;

// ä¼ æ„Ÿå™¨æ•°æ®æ¶ˆæ¯
typedef struct {
    float temperature;
    float humidity;
    float pressure;
    uint8_t sensor_id;
} sensor_data_message_t;

// é˜Ÿåˆ—å¥æŸ„
static QueueHandle_t sensor_data_queue;
static QueueHandle_t system_event_queue;
static QueueHandle_t high_priority_queue;

// é˜Ÿåˆ—åˆå§‹åŒ–
esp_err_t queue_system_init(void)
{
    // åˆ›å»ºä¼ æ„Ÿå™¨æ•°æ®é˜Ÿåˆ—
    sensor_data_queue = xQueueCreate(20, sizeof(sensor_data_message_t));
    if (!sensor_data_queue) {
        ESP_LOGE(TAG, "åˆ›å»ºä¼ æ„Ÿå™¨æ•°æ®é˜Ÿåˆ—å¤±è´¥");
        return ESP_FAIL;
    }
    
    // åˆ›å»ºç³»ç»Ÿäº‹ä»¶é˜Ÿåˆ—
    system_event_queue = xQueueCreate(10, sizeof(queue_message_t));
    if (!system_event_queue) {
        ESP_LOGE(TAG, "åˆ›å»ºç³»ç»Ÿäº‹ä»¶é˜Ÿåˆ—å¤±è´¥");
        return ESP_FAIL;
    }
    
    // åˆ›å»ºé«˜ä¼˜å…ˆçº§é˜Ÿåˆ—
    high_priority_queue = xQueueCreate(5, sizeof(queue_message_t));
    if (!high_priority_queue) {
        ESP_LOGE(TAG, "åˆ›å»ºé«˜ä¼˜å…ˆçº§é˜Ÿåˆ—å¤±è´¥");
        return ESP_FAIL;
    }
    
    ESP_LOGI(TAG, "é˜Ÿåˆ—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
    return ESP_OK;
}

// ä¼ æ„Ÿå™¨æ•°æ®ç”Ÿäº§è€…ä»»åŠ¡
void sensor_data_producer_task(void *pvParameters)
{
    sensor_data_message_t sensor_msg;
    BaseType_t result;
    
    ESP_LOGI(TAG, "ä¼ æ„Ÿå™¨æ•°æ®ç”Ÿäº§è€…å¯åŠ¨");
    
    while (1) {
        // æ¨¡æ‹Ÿä¼ æ„Ÿå™¨æ•°æ®è¯»å–
        sensor_msg.temperature = 20.0 + (rand() % 200) / 10.0;  // 20-40Â°C
        sensor_msg.humidity = 30.0 + (rand() % 400) / 10.0;     // 30-70%
        sensor_msg.pressure = 1000.0 + (rand() % 100);          // 1000-1100hPa
        sensor_msg.sensor_id = 1;
        
        // å‘é€åˆ°é˜Ÿåˆ—ï¼ˆéé˜»å¡ï¼‰
        result = xQueueSend(sensor_data_queue, &sensor_msg, 0);
        if (result == pdTRUE) {
            ESP_LOGI(TAG, "ä¼ æ„Ÿå™¨æ•°æ®å·²å‘é€ - T:%.1f H:%.1f P:%.1f", 
                     sensor_msg.temperature, sensor_msg.humidity, sensor_msg.pressure);
        } else {
            ESP_LOGW(TAG, "ä¼ æ„Ÿå™¨æ•°æ®é˜Ÿåˆ—æ»¡ï¼Œæ•°æ®ä¸¢å¤±");
        }
        
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

// ä¼ æ„Ÿå™¨æ•°æ®æ¶ˆè´¹è€…ä»»åŠ¡
void sensor_data_consumer_task(void *pvParameters)
{
    sensor_data_message_t received_msg;
    BaseType_t result;
    
    ESP_LOGI(TAG, "ä¼ æ„Ÿå™¨æ•°æ®æ¶ˆè´¹è€…å¯åŠ¨");
    
    while (1) {
        // ä»é˜Ÿåˆ—æ¥æ”¶æ•°æ®ï¼ˆé˜»å¡ç­‰å¾…ï¼‰
        result = xQueueReceive(sensor_data_queue, &received_msg, portMAX_DELAY);
        if (result == pdTRUE) {
            ESP_LOGI(TAG, "å¤„ç†ä¼ æ„Ÿå™¨æ•°æ® - ä¼ æ„Ÿå™¨%d: T=%.1fÂ°C, H=%.1f%%, P=%.1fhPa", 
                     received_msg.sensor_id,
                     received_msg.temperature,
                     received_msg.humidity,
                     received_msg.pressure);
            
            // æ•°æ®å¤„ç†é€»è¾‘
            process_sensor_data(&received_msg);
        }
    }
}

// ç³»ç»Ÿäº‹ä»¶å¤„ç†ä»»åŠ¡
void system_event_handler_task(void *pvParameters)
{
    queue_message_t event_msg;
    BaseType_t result;
    
    ESP_LOGI(TAG, "ç³»ç»Ÿäº‹ä»¶å¤„ç†å™¨å¯åŠ¨");
    
    while (1) {
        // ä¼˜å…ˆå¤„ç†é«˜ä¼˜å…ˆçº§é˜Ÿåˆ—
        result = xQueueReceive(high_priority_queue, &event_msg, 0);
        if (result == pdTRUE) {
            ESP_LOGW(TAG, "å¤„ç†é«˜ä¼˜å…ˆçº§äº‹ä»¶: %d", event_msg.type);
            handle_high_priority_event(&event_msg);
            continue;
        }
        
        // å¤„ç†æ™®é€šç³»ç»Ÿäº‹ä»¶
        result = xQueueReceive(system_event_queue, &event_msg, pdMS_TO_TICKS(100));
        if (result == pdTRUE) {
            ESP_LOGI(TAG, "å¤„ç†ç³»ç»Ÿäº‹ä»¶: %d (æ—¶é—´æˆ³: %u)", 
                     event_msg.type, event_msg.timestamp);
            handle_system_event(&event_msg);
        }
    }
}

// å‘é€ç³»ç»Ÿæ¶ˆæ¯
esp_err_t send_system_message(message_type_t type, uint8_t *data, uint16_t length, uint8_t priority)
{
    queue_message_t msg;
    QueueHandle_t target_queue;
    
    if (length > sizeof(msg.data)) {
        ESP_LOGE(TAG, "æ¶ˆæ¯æ•°æ®è¿‡é•¿: %d", length);
        return ESP_ERR_INVALID_SIZE;
    }
    
    // æ„é€ æ¶ˆæ¯
    msg.type = type;
    msg.timestamp = xTaskGetTickCount();
    msg.data_length = length;
    msg.priority = priority;
    memcpy(msg.data, data, length);
    
    // æ ¹æ®ä¼˜å…ˆçº§é€‰æ‹©é˜Ÿåˆ—
    target_queue = (priority > 5) ? high_priority_queue : system_event_queue;
    
    // å‘é€æ¶ˆæ¯
    BaseType_t result = xQueueSend(target_queue, &msg, pdMS_TO_TICKS(100));
    if (result != pdTRUE) {
        ESP_LOGW(TAG, "å‘é€ç³»ç»Ÿæ¶ˆæ¯å¤±è´¥: é˜Ÿåˆ—æ»¡");
        return ESP_FAIL;
    }
    
    return ESP_OK;
}

// é˜Ÿåˆ—çŠ¶æ€ç›‘æ§
void monitor_queue_status(void)
{
    UBaseType_t sensor_queue_count = uxQueueMessagesWaiting(sensor_data_queue);
    UBaseType_t event_queue_count = uxQueueMessagesWaiting(system_event_queue);
    UBaseType_t hp_queue_count = uxQueueMessagesWaiting(high_priority_queue);
    
    ESP_LOGI(TAG, "é˜Ÿåˆ—çŠ¶æ€ - ä¼ æ„Ÿå™¨: %d, ç³»ç»Ÿäº‹ä»¶: %d, é«˜ä¼˜å…ˆçº§: %d", 
             sensor_queue_count, event_queue_count, hp_queue_count);
    
    // é˜Ÿåˆ—ä½¿ç”¨ç‡è­¦å‘Š
    if (sensor_queue_count > 15) {  // é˜Ÿåˆ—å®¹é‡20ï¼Œä½¿ç”¨ç‡75%
        ESP_LOGW(TAG, "ä¼ æ„Ÿå™¨æ•°æ®é˜Ÿåˆ—ä½¿ç”¨ç‡è¿‡é«˜");
    }
}
```

### ä¿¡å·é‡ä¸äº’æ–¥é”

```c
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "freertos/task.h"

// åŒæ­¥åŸè¯­å¥æŸ„
static SemaphoreHandle_t binary_semaphore;      // äºŒè¿›åˆ¶ä¿¡å·é‡
static SemaphoreHandle_t counting_semaphore;    // è®¡æ•°ä¿¡å·é‡
static SemaphoreHandle_t mutex_semaphore;       // äº’æ–¥é”
static SemaphoreHandle_t recursive_mutex;       // é€’å½’äº’æ–¥é”

// å…±äº«èµ„æº
static int shared_counter = 0;
static char shared_buffer[256];

// åŒæ­¥åŸè¯­åˆå§‹åŒ–
esp_err_t sync_primitives_init(void)
{
    // åˆ›å»ºäºŒè¿›åˆ¶ä¿¡å·é‡
    binary_semaphore = xSemaphoreCreateBinary();
    if (!binary_semaphore) {
        ESP_LOGE(TAG, "åˆ›å»ºäºŒè¿›åˆ¶ä¿¡å·é‡å¤±è´¥");
        return ESP_FAIL;
    }
    
    // åˆ›å»ºè®¡æ•°ä¿¡å·é‡ï¼ˆæœ€å¤§å€¼5ï¼‰
    counting_semaphore = xSemaphoreCreateCounting(5, 0);
    if (!counting_semaphore) {
        ESP_LOGE(TAG, "åˆ›å»ºè®¡æ•°ä¿¡å·é‡å¤±è´¥");
        return ESP_FAIL;
    }
    
    // åˆ›å»ºäº’æ–¥é”
    mutex_semaphore = xSemaphoreCreateMutex();
    if (!mutex_semaphore) {
        ESP_LOGE(TAG, "åˆ›å»ºäº’æ–¥é”å¤±è´¥");
        return ESP_FAIL;
    }
    
    // åˆ›å»ºé€’å½’äº’æ–¥é”
    recursive_mutex = xSemaphoreCreateRecursiveMutex();
    if (!recursive_mutex) {
        ESP_LOGE(TAG, "åˆ›å»ºé€’å½’äº’æ–¥é”å¤±è´¥");
        return ESP_FAIL;
    }
    
    ESP_LOGI(TAG, "åŒæ­¥åŸè¯­åˆå§‹åŒ–å®Œæˆ");
    return ESP_OK;
}

// ç”Ÿäº§è€…ä»»åŠ¡ï¼ˆä½¿ç”¨è®¡æ•°ä¿¡å·é‡ï¼‰
void producer_task(void *pvParameters)
{
    int producer_id = (int)pvParameters;
    
    ESP_LOGI(TAG, "ç”Ÿäº§è€…%då¯åŠ¨", producer_id);
    
    while (1) {
        // æ¨¡æ‹Ÿç”Ÿäº§è¿‡ç¨‹
        vTaskDelay(pdMS_TO_TICKS(1000 + rand() % 2000));
        
        // é‡Šæ”¾ä¿¡å·é‡ï¼ˆè¡¨ç¤ºç”Ÿäº§äº†ä¸€ä¸ªäº§å“ï¼‰
        xSemaphoreGive(counting_semaphore);
        ESP_LOGI(TAG, "ç”Ÿäº§è€…%dç”Ÿäº§äº†ä¸€ä¸ªäº§å“", producer_id);
        
        // æ£€æŸ¥ä¿¡å·é‡è®¡æ•°
        UBaseType_t count = uxSemaphoreGetCount(counting_semaphore);
        ESP_LOGI(TAG, "å½“å‰äº§å“æ•°é‡: %d", count);
    }
}

// æ¶ˆè´¹è€…ä»»åŠ¡ï¼ˆä½¿ç”¨è®¡æ•°ä¿¡å·é‡ï¼‰
void consumer_task(void *pvParameters)
{
    int consumer_id = (int)pvParameters;
    
    ESP_LOGI(TAG, "æ¶ˆè´¹è€…%då¯åŠ¨", consumer_id);
    
    while (1) {
        // ç­‰å¾…äº§å“ï¼ˆè·å–ä¿¡å·é‡ï¼‰
        if (xSemaphoreTake(counting_semaphore, pdMS_TO_TICKS(5000)) == pdTRUE) {
            ESP_LOGI(TAG, "æ¶ˆè´¹è€…%dæ¶ˆè´¹äº†ä¸€ä¸ªäº§å“", consumer_id);
            
            // æ¨¡æ‹Ÿæ¶ˆè´¹è¿‡ç¨‹
            vTaskDelay(pdMS_TO_TICKS(500 + rand() % 1000));
        } else {
            ESP_LOGW(TAG, "æ¶ˆè´¹è€…%dç­‰å¾…è¶…æ—¶ï¼Œæ²¡æœ‰äº§å“å¯æ¶ˆè´¹", consumer_id);
        }
    }
}

// å†™å…¥ä»»åŠ¡ï¼ˆä½¿ç”¨äº’æ–¥é”ä¿æŠ¤å…±äº«èµ„æºï¼‰
void writer_task(void *pvParameters)
{
    int writer_id = (int)pvParameters;
    
    ESP_LOGI(TAG, "å†™å…¥ä»»åŠ¡%då¯åŠ¨", writer_id);
    
    while (1) {
        // è·å–äº’æ–¥é”
        if (xSemaphoreTake(mutex_semaphore, pdMS_TO_TICKS(1000)) == pdTRUE) {
            ESP_LOGI(TAG, "å†™å…¥ä»»åŠ¡%dè·å¾—é”ï¼Œå¼€å§‹å†™å…¥", writer_id);
            
            // ä¸´ç•ŒåŒºï¼šä¿®æ”¹å…±äº«èµ„æº
            shared_counter++;
            snprintf(shared_buffer, sizeof(shared_buffer), 
                    "Writer%d - Count: %d - Time: %u", 
                    writer_id, shared_counter, xTaskGetTickCount());
            
            ESP_LOGI(TAG, "å†™å…¥å®Œæˆ: %s", shared_buffer);
            
            // æ¨¡æ‹Ÿå†™å…¥æ“ä½œè€—æ—¶
            vTaskDelay(pdMS_TO_TICKS(200));
            
            // é‡Šæ”¾äº’æ–¥é”
            xSemaphoreGive(mutex_semaphore);
            ESP_LOGI(TAG, "å†™å…¥ä»»åŠ¡%dé‡Šæ”¾é”", writer_id);
        } else {
            ESP_LOGW(TAG, "å†™å…¥ä»»åŠ¡%dè·å–é”è¶…æ—¶", writer_id);
        }
        
        vTaskDelay(pdMS_TO_TICKS(1500));
    }
}

// è¯»å–ä»»åŠ¡ï¼ˆä½¿ç”¨äº’æ–¥é”ä¿æŠ¤å…±äº«èµ„æºï¼‰
void reader_task(void *pvParameters)
{
    int reader_id = (int)pvParameters;
    char local_buffer[256];
    int local_counter;
    
    ESP_LOGI(TAG, "è¯»å–ä»»åŠ¡%då¯åŠ¨", reader_id);
    
    while (1) {
        // è·å–äº’æ–¥é”
        if (xSemaphoreTake(mutex_semaphore, pdMS_TO_TICKS(1000)) == pdTRUE) {
            ESP_LOGI(TAG, "è¯»å–ä»»åŠ¡%dè·å¾—é”ï¼Œå¼€å§‹è¯»å–", reader_id);
            
            // ä¸´ç•ŒåŒºï¼šè¯»å–å…±äº«èµ„æº
            local_counter = shared_counter;
            strncpy(local_buffer, shared_buffer, sizeof(local_buffer));
            
            // æ¨¡æ‹Ÿè¯»å–æ“ä½œè€—æ—¶
            vTaskDelay(pdMS_TO_TICKS(100));
            
            // é‡Šæ”¾äº’æ–¥é”
            xSemaphoreGive(mutex_semaphore);
            
            ESP_LOGI(TAG, "è¯»å–ä»»åŠ¡%dè¯»å–åˆ°: %s (è®¡æ•°: %d)", 
                     reader_id, local_buffer, local_counter);
        } else {
            ESP_LOGW(TAG, "è¯»å–ä»»åŠ¡%dè·å–é”è¶…æ—¶", reader_id);
        }
        
        vTaskDelay(pdMS_TO_TICKS(800));
    }
}

// é€’å½’å‡½æ•°ç¤ºä¾‹ï¼ˆä½¿ç”¨é€’å½’äº’æ–¥é”ï¼‰
void recursive_function(int depth, int max_depth)
{
    if (depth > max_depth) {
        return;
    }
    
    // è·å–é€’å½’äº’æ–¥é”
    if (xSemaphoreTakeRecursive(recursive_mutex, pdMS_TO_TICKS(1000)) == pdTRUE) {
        ESP_LOGI(TAG, "é€’å½’æ·±åº¦ %d - è·å¾—é€’å½’é”", depth);
        
        // é€’å½’è°ƒç”¨
        if (depth < max_depth) {
            recursive_function(depth + 1, max_depth);
        }
        
        // é‡Šæ”¾é€’å½’äº’æ–¥é”
        xSemaphoreGiveRecursive(recursive_mutex);
        ESP_LOGI(TAG, "é€’å½’æ·±åº¦ %d - é‡Šæ”¾é€’å½’é”", depth);
    }
}

// é€’å½’æµ‹è¯•ä»»åŠ¡
void recursive_test_task(void *pvParameters)
{
    ESP_LOGI(TAG, "é€’å½’æµ‹è¯•ä»»åŠ¡å¯åŠ¨");
    
    while (1) {
        ESP_LOGI(TAG, "å¼€å§‹é€’å½’æµ‹è¯•...");
        recursive_function(1, 5);
        ESP_LOGI(TAG, "é€’å½’æµ‹è¯•å®Œæˆ");
        
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}

// åˆ›å»ºåŒæ­¥æµ‹è¯•ä»»åŠ¡
void create_sync_test_tasks(void)
{
    // åˆ›å»ºç”Ÿäº§è€…æ¶ˆè´¹è€…ä»»åŠ¡
    xTaskCreate(producer_task, "producer1", 2048, (void*)1, 2, NULL);
    xTaskCreate(producer_task, "producer2", 2048, (void*)2, 2, NULL);
    xTaskCreate(consumer_task, "consumer1", 2048, (void*)1, 2, NULL);
    xTaskCreate(consumer_task, "consumer2", 2048, (void*)2, 2, NULL);
    
    // åˆ›å»ºè¯»å†™ä»»åŠ¡
    xTaskCreate(writer_task, "writer1", 2048, (void*)1, 3, NULL);
    xTaskCreate(writer_task, "writer2", 2048, (void*)2, 3, NULL);
    xTaskCreate(reader_task, "reader1", 2048, (void*)1, 2, NULL);
    xTaskCreate(reader_task, "reader2", 2048, (void*)2, 2, NULL);
    
    // åˆ›å»ºé€’å½’æµ‹è¯•ä»»åŠ¡
    xTaskCreate(recursive_test_task, "recursive_test", 2048, NULL, 1, NULL);
}
```

## â° è½¯ä»¶å®šæ—¶å™¨

```c
#include "freertos/FreeRTOS.h"
#include "freertos/timers.h"
#include "freertos/task.h"

// å®šæ—¶å™¨å¥æŸ„
static TimerHandle_t periodic_timer;
static TimerHandle_t oneshot_timer;
static TimerHandle_t heartbeat_timer;
static TimerHandle_t timeout_timer;

// å®šæ—¶å™¨å›è°ƒå‡½æ•°
void periodic_timer_callback(TimerHandle_t xTimer)
{
    static int counter = 0;
    counter++;
    
    ESP_LOGI(TAG, "å‘¨æœŸå®šæ—¶å™¨è§¦å‘ - è®¡æ•°: %d", counter);
    
    // æ¯10æ¬¡é‡ç½®è®¡æ•°å™¨
    if (counter >= 10) {
        counter = 0;
        ESP_LOGI(TAG, "è®¡æ•°å™¨é‡ç½®");
    }
}

void oneshot_timer_callback(TimerHandle_t xTimer)
{
    ESP_LOGI(TAG, "å•æ¬¡å®šæ—¶å™¨è§¦å‘");
    
    // å¯ä»¥åœ¨è¿™é‡Œé‡æ–°å¯åŠ¨å®šæ—¶å™¨
    // xTimerStart(oneshot_timer, 0);
}

void heartbeat_timer_callback(TimerHandle_t xTimer)
{
    static bool led_state = false;
    
    // å¿ƒè·³LEDé—ªçƒ
    led_state = !led_state;
    gpio_set_level(GPIO_NUM_2, led_state);
    
    ESP_LOGI(TAG, "å¿ƒè·³ä¿¡å· - LED: %s", led_state ? "ON" : "OFF");
}

void timeout_timer_callback(TimerHandle_t xTimer)
{
    ESP_LOGW(TAG, "æ“ä½œè¶…æ—¶ï¼æ‰§è¡Œè¶…æ—¶å¤„ç†...");
    
    // è¶…æ—¶å¤„ç†é€»è¾‘
    handle_timeout_event();
}

// è½¯ä»¶å®šæ—¶å™¨åˆå§‹åŒ–
esp_err_t software_timers_init(void)
{
    // åˆ›å»ºå‘¨æœŸå®šæ—¶å™¨ï¼ˆæ¯2ç§’è§¦å‘ï¼‰
    periodic_timer = xTimerCreate(
        "periodic_timer",           // å®šæ—¶å™¨åç§°
        pdMS_TO_TICKS(2000),       // å‘¨æœŸ 2ç§’
        pdTRUE,                    // è‡ªåŠ¨é‡è½½
        (void*)1,                  // å®šæ—¶å™¨ID
        periodic_timer_callback    // å›è°ƒå‡½æ•°
    );
    
    if (!periodic_timer) {
        ESP_LOGE(TAG, "åˆ›å»ºå‘¨æœŸå®šæ—¶å™¨å¤±è´¥");
        return ESP_FAIL;
    }
    
    // åˆ›å»ºå•æ¬¡å®šæ—¶å™¨ï¼ˆ5ç§’åè§¦å‘ï¼‰
    oneshot_timer = xTimerCreate(
        "oneshot_timer",
        pdMS_TO_TICKS(5000),
        pdFALSE,                   // ä¸è‡ªåŠ¨é‡è½½
        (void*)2,
        oneshot_timer_callback
    );
    
    if (!oneshot_timer) {
        ESP_LOGE(TAG, "åˆ›å»ºå•æ¬¡å®šæ—¶å™¨å¤±è´¥");
        return ESP_FAIL;
    }
    
    // åˆ›å»ºå¿ƒè·³å®šæ—¶å™¨ï¼ˆæ¯500msè§¦å‘ï¼‰
    heartbeat_timer = xTimerCreate(
        "heartbeat_timer",
        pdMS_TO_TICKS(500),
        pdTRUE,
        (void*)3,
        heartbeat_timer_callback
    );
    
    if (!heartbeat_timer) {
        ESP_LOGE(TAG, "åˆ›å»ºå¿ƒè·³å®šæ—¶å™¨å¤±è´¥");
        return ESP_FAIL;
    }
    
    // åˆ›å»ºè¶…æ—¶å®šæ—¶å™¨ï¼ˆ10ç§’è¶…æ—¶ï¼‰
    timeout_timer = xTimerCreate(
        "timeout_timer",
        pdMS_TO_TICKS(10000),
        pdFALSE,
        (void*)4,
        timeout_timer_callback
    );
    
    if (!timeout_timer) {
        ESP_LOGE(TAG, "åˆ›å»ºè¶…æ—¶å®šæ—¶å™¨å¤±è´¥");
        return ESP_FAIL;
    }
    
    ESP_LOGI(TAG, "è½¯ä»¶å®šæ—¶å™¨åˆå§‹åŒ–å®Œæˆ");
    return ESP_OK;
}

// å®šæ—¶å™¨æ§åˆ¶ä»»åŠ¡
void timer_control_task(void *pvParameters)
{
    ESP_LOGI(TAG, "å®šæ—¶å™¨æ§åˆ¶ä»»åŠ¡å¯åŠ¨");
    
    // å¯åŠ¨å‘¨æœŸå®šæ—¶å™¨å’Œå¿ƒè·³å®šæ—¶å™¨
    xTimerStart(periodic_timer, 0);
    xTimerStart(heartbeat_timer, 0);
    
    vTaskDelay(pdMS_TO_TICKS(3000));
    
    // å¯åŠ¨å•æ¬¡å®šæ—¶å™¨
    ESP_LOGI(TAG, "å¯åŠ¨å•æ¬¡å®šæ—¶å™¨");
    xTimerStart(oneshot_timer, 0);
    
    vTaskDelay(pdMS_TO_TICKS(7000));
    
    // ä¿®æ”¹å‘¨æœŸå®šæ—¶å™¨çš„å‘¨æœŸ
    ESP_LOGI(TAG, "ä¿®æ”¹å‘¨æœŸå®šæ—¶å™¨å‘¨æœŸä¸º1ç§’");
    xTimerChangePeriod(periodic_timer, pdMS_TO_TICKS(1000), 0);
    
    vTaskDelay(pdMS_TO_TICKS(5000));
    
    // åœæ­¢å¿ƒè·³å®šæ—¶å™¨
    ESP_LOGI(TAG, "åœæ­¢å¿ƒè·³å®šæ—¶å™¨");
    xTimerStop(heartbeat_timer, 0);
    
    vTaskDelay(pdMS_TO_TICKS(3000));
    
    // é‡æ–°å¯åŠ¨å¿ƒè·³å®šæ—¶å™¨
    ESP_LOGI(TAG, "é‡æ–°å¯åŠ¨å¿ƒè·³å®šæ—¶å™¨");
    xTimerStart(heartbeat_timer, 0);
    
    while (1) {
        // æ¨¡æ‹Ÿéœ€è¦è¶…æ—¶ä¿æŠ¤çš„æ“ä½œ
        ESP_LOGI(TAG, "å¼€å§‹æ“ä½œï¼Œå¯åŠ¨è¶…æ—¶ä¿æŠ¤");
        xTimerStart(timeout_timer, 0);
        
        // æ¨¡æ‹Ÿæ“ä½œï¼ˆéšæœºæˆåŠŸæˆ–å¤±è´¥ï¼‰
        int operation_time = 2000 + rand() % 10000;  // 2-12ç§’
        vTaskDelay(pdMS_TO_TICKS(operation_time));
        
        // æ“ä½œå®Œæˆï¼Œåœæ­¢è¶…æ—¶å®šæ—¶å™¨
        if (xTimerIsTimerActive(timeout_timer)) {
            ESP_LOGI(TAG, "æ“ä½œå®Œæˆï¼Œåœæ­¢è¶…æ—¶ä¿æŠ¤");
            xTimerStop(timeout_timer, 0);
        }
        
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}

// åŠ¨æ€å®šæ—¶å™¨åˆ›å»ºç¤ºä¾‹
TimerHandle_t create_dynamic_timer(const char *name, uint32_t period_ms, 
                                  bool auto_reload, TimerCallbackFunction_t callback)
{
    TimerHandle_t timer = xTimerCreate(
        name,
        pdMS_TO_TICKS(period_ms),
        auto_reload ? pdTRUE : pdFALSE,
        NULL,
        callback
    );
    
    if (timer) {
        ESP_LOGI(TAG, "åŠ¨æ€åˆ›å»ºå®šæ—¶å™¨: %s (å‘¨æœŸ: %u ms)", name, period_ms);
    } else {
        ESP_LOGE(TAG, "åŠ¨æ€åˆ›å»ºå®šæ—¶å™¨å¤±è´¥: %s", name);
    }
    
    return timer;
}

// å®šæ—¶å™¨ç®¡ç†å™¨
typedef struct {
    TimerHandle_t timer;
    const char *name;
    bool active;
    uint32_t period_ms;
} timer_info_t;

#define MAX_MANAGED_TIMERS 10
static timer_info_t managed_timers[MAX_MANAGED_TIMERS];
static int managed_timer_count = 0;

// æ·»åŠ å®šæ—¶å™¨åˆ°ç®¡ç†å™¨
esp_err_t timer_manager_add(TimerHandle_t timer, const char *name, uint32_t period_ms)
{
    if (managed_timer_count >= MAX_MANAGED_TIMERS) {
        return ESP_ERR_NO_MEM;
    }
    
    managed_timers[managed_timer_count] = (timer_info_t){
        .timer = timer,
        .name = name,
        .active = false,
        .period_ms = period_ms
    };
    
    managed_timer_count++;
    return ESP_OK;
}

// æ˜¾ç¤ºå®šæ—¶å™¨çŠ¶æ€
void show_timer_status(void)
{
    ESP_LOGI(TAG, "=== å®šæ—¶å™¨çŠ¶æ€ ===");
    
    for (int i = 0; i < managed_timer_count; i++) {
        timer_info_t *info = &managed_timers[i];
        bool is_active = xTimerIsTimerActive(info->timer);
        TickType_t remaining = xTimerGetExpiryTime(info->timer) - xTaskGetTickCount();
        
        ESP_LOGI(TAG, "%s: %s, å‘¨æœŸ: %u ms, å‰©ä½™æ—¶é—´: %u ms", 
                 info->name,
                 is_active ? "è¿è¡Œä¸­" : "å·²åœæ­¢",
                 info->period_ms,
                 (uint32_t)(remaining * portTICK_PERIOD_MS));
    }
}
```

---

> **FreeRTOSæ€»ç»“**ï¼šESP32çš„FreeRTOSç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„å¤šä»»åŠ¡å¤„ç†èƒ½åŠ›ã€‚é€šè¿‡åˆç†çš„ä»»åŠ¡è®¾è®¡ã€ä¼˜å…ˆçº§é…ç½®ã€åŒæ­¥æœºåˆ¶å’Œå®šæ—¶å™¨ä½¿ç”¨ï¼Œå¯ä»¥æ„å»ºé«˜æ•ˆç¨³å®šçš„å®æ—¶ç³»ç»Ÿã€‚å…³é”®æ˜¯è¦ç†è§£è°ƒåº¦åŸç†ã€é¿å…ä¼˜å…ˆçº§åè½¬ã€åˆç†ä½¿ç”¨åŒæ­¥åŸè¯­ï¼Œå¹¶è¿›è¡Œå……åˆ†çš„ä»»åŠ¡ç›‘æ§å’Œæ€§èƒ½åˆ†æã€‚

# ESP32ä¼ æ„Ÿå™¨æ¥å£ä¸æ•°æ®é‡‡é›†

## ğŸ“‹ æ¦‚è¿°

ESP32å…·æœ‰ä¸°å¯Œçš„å¤–è®¾æ¥å£ï¼Œæ”¯æŒå¤šç§ä¼ æ„Ÿå™¨è¿æ¥æ–¹å¼ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»å¸¸ç”¨ä¼ æ„Ÿå™¨çš„æ¥å£åè®®ã€æ•°æ®é‡‡é›†æ–¹æ³•å’Œå®é™…åº”ç”¨æ¡ˆä¾‹ï¼Œå¸®åŠ©å¼€å‘è€…å¿«é€Ÿæ„å»ºä¼ æ„Ÿå™¨åº”ç”¨ç³»ç»Ÿã€‚

## ğŸ”Œ å¸¸ç”¨æ¥å£åè®®

### æ¥å£ç±»å‹å¯¹æ¯”

| æ¥å£ç±»å‹ | ä¼ è¾“é€Ÿåº¦ | è¿æ¥è·ç¦» | åŠŸè€— | å¤æ‚åº¦ | é€‚ç”¨ä¼ æ„Ÿå™¨ |
|---------|----------|----------|------|--------|------------|
| GPIO | å¿« | çŸ­ | ä½ | ç®€å• | å¼€å…³ã€LEDã€ç»§ç”µå™¨ |
| ADC | ä¸­ | çŸ­ | ä½ | ç®€å• | æ¨¡æ‹Ÿä¼ æ„Ÿå™¨ã€ç”µä½å™¨ |
| I2C | ä¸­ | çŸ­-ä¸­ | ä½ | ä¸­ç­‰ | æ¸©æ¹¿åº¦ã€æ°”å‹ã€é™€èºä»ª |
| SPI | å¿« | çŸ­ | ä¸­ | ä¸­ç­‰ | æ˜¾ç¤ºå±ã€å­˜å‚¨å™¨ |
| UART | ä¸­ | é•¿ | ä¸­ | ç®€å• | GPSã€ä¸²å£ä¼ æ„Ÿå™¨ |
| 1-Wire | æ…¢ | ä¸­ | ä½ | ç®€å• | æ¸©åº¦ä¼ æ„Ÿå™¨DS18B20 |

## ğŸ“Š ADCæ¨¡æ‹Ÿä¿¡å·é‡‡é›†

### ADCåŸºç¡€é…ç½®

```c
#include "driver/adc.h"
#include "esp_adc_cal.h"
#include "esp_log.h"

static const char *TAG = "ADC_EXAMPLE";

// ADCæ ¡å‡†å‚æ•°
static esp_adc_cal_characteristics_t adc_chars;

// ADCåˆå§‹åŒ–
void adc_init(void)
{
    // é…ç½®ADC1_CHANNEL_6 (GPIO34)
    adc1_config_width(ADC_WIDTH_BIT_12);  // 12ä½åˆ†è¾¨ç‡
    adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_DB_11);  // 11dBè¡°å‡ï¼Œæµ‹é‡èŒƒå›´0-3.3V
    
    // ADCæ ¡å‡†
    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(ADC_UNIT_1, 
                                                            ADC_ATTEN_DB_11, 
                                                            ADC_WIDTH_BIT_12, 
                                                            1100, 
                                                            &adc_chars);
    
    if (val_type == ESP_ADC_CAL_VAL_EFUSE_TP) {
        ESP_LOGI(TAG, "Characterized using Two Point Value");
    } else if (val_type == ESP_ADC_CAL_VAL_EFUSE_VREF) {
        ESP_LOGI(TAG, "Characterized using eFuse Vref");
    } else {
        ESP_LOGI(TAG, "Characterized using Default Vref");
    }
}

// è¯»å–ADCç”µå‹å€¼
uint32_t read_adc_voltage(adc1_channel_t channel)
{
    uint32_t adc_reading = 0;
    
    // å¤šæ¬¡é‡‡æ ·æ±‚å¹³å‡å€¼ï¼Œæé«˜ç²¾åº¦
    for (int i = 0; i < 64; i++) {
        adc_reading += adc1_get_raw(channel);
    }
    adc_reading /= 64;
    
    // è½¬æ¢ä¸ºç”µå‹å€¼ï¼ˆæ¯«ä¼ï¼‰
    uint32_t voltage = esp_adc_cal_raw_to_voltage(adc_reading, &adc_chars);
    
    return voltage;
}

// å¤šé€šé“ADCé‡‡é›†ç¤ºä¾‹
typedef struct {
    adc1_channel_t channel;
    const char* name;
    float scale_factor;  // æ¯”ä¾‹å› å­
    float offset;        // åç§»é‡
} adc_sensor_t;

static adc_sensor_t adc_sensors[] = {
    {ADC1_CHANNEL_6, "æ¸©åº¦ä¼ æ„Ÿå™¨", 0.01, -273.15},      // LM35æ¸©åº¦ä¼ æ„Ÿå™¨
    {ADC1_CHANNEL_7, "å…‰æ•ç”µé˜»", 1.0, 0},                 // å…‰æ•ç”µé˜»
    {ADC1_CHANNEL_4, "åœŸå£¤æ¹¿åº¦", 0.1, 0},                // åœŸå£¤æ¹¿åº¦ä¼ æ„Ÿå™¨
    {ADC1_CHANNEL_5, "æ°”ä½“ä¼ æ„Ÿå™¨", 1.0, 0},              // MQç³»åˆ—æ°”ä½“ä¼ æ„Ÿå™¨
};

void multi_channel_adc_task(void *pvParameters)
{
    adc_init();
    
    while (1) {
        ESP_LOGI(TAG, "=== ADCä¼ æ„Ÿå™¨è¯»æ•° ===");
        
        for (int i = 0; i < sizeof(adc_sensors)/sizeof(adc_sensor_t); i++) {
            uint32_t voltage = read_adc_voltage(adc_sensors[i].channel);
            float sensor_value = voltage * adc_sensors[i].scale_factor + adc_sensors[i].offset;
            
            ESP_LOGI(TAG, "%s: %d mV, è½¬æ¢å€¼: %.2f", 
                     adc_sensors[i].name, voltage, sensor_value);
        }
        
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}
```

### é«˜ç²¾åº¦ADCé‡‡é›†æŠ€æœ¯

```c
#include "driver/adc.h"
#include "esp_adc_cal.h"
#include "driver/dac.h"

// å·®åˆ†ADCé…ç½®ï¼ˆæé«˜æŠ—å¹²æ‰°èƒ½åŠ›ï¼‰
typedef struct {
    adc1_channel_t pos_channel;  // æ­£æé€šé“
    adc1_channel_t neg_channel;  // è´Ÿæé€šé“ï¼ˆå‚è€ƒç”µå¹³ï¼‰
} differential_adc_t;

// è¿‡é‡‡æ ·å’Œæ•°å­—æ»¤æ³¢
#define OVERSAMPLE_BITS    4    // è¿‡é‡‡æ ·4ä½ï¼Œç›¸å½“äº16å€è¿‡é‡‡æ ·
#define FILTER_SIZE       16    // æ»‘åŠ¨å¹³å‡æ»¤æ³¢å™¨å¤§å°

static uint32_t filter_buffer[FILTER_SIZE] = {0};
static uint8_t filter_index = 0;

uint32_t filtered_adc_read(adc1_channel_t channel)
{
    uint32_t sum = 0;
    uint32_t samples = 1 << OVERSAMPLE_BITS;  // 2^4 = 16æ¬¡é‡‡æ ·
    
    // è¿‡é‡‡æ ·
    for (uint32_t i = 0; i < samples; i++) {
        sum += adc1_get_raw(channel);
        vTaskDelay(1);  // çŸ­æš‚å»¶æ—¶ï¼Œé¿å…å™ªå£°ç›¸å…³
    }
    
    // å³ç§»å¾—åˆ°é«˜ç²¾åº¦ç»“æœ
    uint32_t oversampled = sum >> OVERSAMPLE_BITS;
    
    // æ»‘åŠ¨å¹³å‡æ»¤æ³¢
    filter_buffer[filter_index] = oversampled;
    filter_index = (filter_index + 1) % FILTER_SIZE;
    
    uint32_t filtered_sum = 0;
    for (int i = 0; i < FILTER_SIZE; i++) {
        filtered_sum += filter_buffer[i];
    }
    
    return filtered_sum / FILTER_SIZE;
}

// æ¸©åº¦ä¼ æ„Ÿå™¨NTCçƒ­æ•ç”µé˜»å¤„ç†
float ntc_temperature_calculate(uint32_t adc_value)
{
    // Steinhart-Hartæ–¹ç¨‹å‚æ•°ï¼ˆéœ€è¦æ ¹æ®å…·ä½“NTCå‹å·è°ƒæ•´ï¼‰
    const float A = 1.129148e-3;
    const float B = 2.34125e-4;
    const float C = 8.76741e-8;
    
    // å°†ADCå€¼è½¬æ¢ä¸ºç”µé˜»å€¼
    float vdd = 3300.0;  // ä¾›ç”µç”µå‹ 3.3V
    float r_series = 10000.0;  // ä¸²è”ç”µé˜» 10kÎ©
    
    float voltage = (adc_value / 4095.0) * vdd;
    float resistance = r_series * voltage / (vdd - voltage);
    
    // Steinhart-Hartæ–¹ç¨‹è®¡ç®—æ¸©åº¦
    float ln_r = log(resistance);
    float temp_k = 1.0 / (A + B * ln_r + C * ln_r * ln_r * ln_r);
    float temp_c = temp_k - 273.15;
    
    return temp_c;
}
```

## ğŸŒ¡ï¸ I2Cä¼ æ„Ÿå™¨æ¥å£

### I2CåŸºç¡€é…ç½®

```c
#include "driver/i2c.h"
#include "esp_log.h"

#define I2C_MASTER_SCL_IO    22    // SCLå¼•è„š
#define I2C_MASTER_SDA_IO    21    // SDAå¼•è„š
#define I2C_MASTER_NUM       I2C_NUM_0
#define I2C_MASTER_FREQ_HZ   100000  // 100kHz
#define I2C_MASTER_TX_BUF_DISABLE 0
#define I2C_MASTER_RX_BUF_DISABLE 0

static const char *TAG = "I2C_SENSORS";

// I2Cä¸»æœºåˆå§‹åŒ–
esp_err_t i2c_master_init(void)
{
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ,
    };
    
    esp_err_t err = i2c_param_config(I2C_MASTER_NUM, &conf);
    if (err != ESP_OK) {
        return err;
    }
    
    return i2c_driver_install(I2C_MASTER_NUM, conf.mode, 
                             I2C_MASTER_RX_BUF_DISABLE, 
                             I2C_MASTER_TX_BUF_DISABLE, 0);
}

// I2Cå†™å…¥æ“ä½œ
esp_err_t i2c_write_byte(uint8_t slave_addr, uint8_t reg_addr, uint8_t data)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (slave_addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg_addr, true);
    i2c_master_write_byte(cmd, data, true);
    i2c_master_stop(cmd);
    
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    
    return ret;
}

// I2Cè¯»å–æ“ä½œ
esp_err_t i2c_read_bytes(uint8_t slave_addr, uint8_t reg_addr, uint8_t *data, uint8_t len)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    
    // å†™å…¥å¯„å­˜å™¨åœ°å€
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (slave_addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg_addr, true);
    
    // é‡æ–°å¼€å§‹ï¼Œè¯»å–æ•°æ®
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (slave_addr << 1) | I2C_MASTER_READ, true);
    
    if (len > 1) {
        i2c_master_read(cmd, data, len - 1, I2C_MASTER_ACK);
    }
    i2c_master_read_byte(cmd, data + len - 1, I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    
    return ret;
}

// I2Cè®¾å¤‡æ‰«æ
void i2c_scanner(void)
{
    ESP_LOGI(TAG, "å¼€å§‹I2Cè®¾å¤‡æ‰«æ...");
    
    for (uint8_t addr = 1; addr < 127; addr++) {
        i2c_cmd_handle_t cmd = i2c_cmd_link_create();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_WRITE, true);
        i2c_master_stop(cmd);
        
        esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(100));
        i2c_cmd_link_delete(cmd);
        
        if (ret == ESP_OK) {
            ESP_LOGI(TAG, "æ‰¾åˆ°I2Cè®¾å¤‡ï¼Œåœ°å€: 0x%02X", addr);
        }
    }
    
    ESP_LOGI(TAG, "I2Cæ‰«æå®Œæˆ");
}
```

### DHT22æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨(I2Cç‰ˆæœ¬)

```c
// SHT30æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨ (I2Cæ¥å£)
#define SHT30_ADDR    0x44
#define SHT30_CMD_MEASURE_HIGH    0x2C06  // é«˜ç²¾åº¦æµ‹é‡å‘½ä»¤

typedef struct {
    float temperature;
    float humidity;
    bool valid;
} sht30_data_t;

esp_err_t sht30_read(sht30_data_t *data)
{
    uint8_t cmd[2] = {0x2C, 0x06};  // é«˜ç²¾åº¦æµ‹é‡å‘½ä»¤
    uint8_t response[6];
    
    // å‘é€æµ‹é‡å‘½ä»¤
    i2c_cmd_handle_t cmd_handle = i2c_cmd_link_create();
    i2c_master_start(cmd_handle);
    i2c_master_write_byte(cmd_handle, (SHT30_ADDR << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write(cmd_handle, cmd, 2, true);
    i2c_master_stop(cmd_handle);
    
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd_handle, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd_handle);
    
    if (ret != ESP_OK) {
        data->valid = false;
        return ret;
    }
    
    // ç­‰å¾…æµ‹é‡å®Œæˆ
    vTaskDelay(pdMS_TO_TICKS(20));
    
    // è¯»å–æµ‹é‡ç»“æœ
    cmd_handle = i2c_cmd_link_create();
    i2c_master_start(cmd_handle);
    i2c_master_write_byte(cmd_handle, (SHT30_ADDR << 1) | I2C_MASTER_READ, true);
    i2c_master_read(cmd_handle, response, 5, I2C_MASTER_ACK);
    i2c_master_read_byte(cmd_handle, &response[5], I2C_MASTER_NACK);
    i2c_master_stop(cmd_handle);
    
    ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd_handle, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd_handle);
    
    if (ret != ESP_OK) {
        data->valid = false;
        return ret;
    }
    
    // CRCæ ¡éªŒï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
    // å®é™…åº”ç”¨ä¸­åº”è¯¥è¿›è¡Œå®Œæ•´çš„CRCæ ¡éªŒ
    
    // è½¬æ¢æ¸©åº¦æ•°æ®
    uint16_t temp_raw = (response[0] << 8) | response[1];
    data->temperature = -45.0 + 175.0 * temp_raw / 65535.0;
    
    // è½¬æ¢æ¹¿åº¦æ•°æ®
    uint16_t hum_raw = (response[3] << 8) | response[4];
    data->humidity = 100.0 * hum_raw / 65535.0;
    
    data->valid = true;
    return ESP_OK;
}
```

### MPU6050é™€èºä»ªåŠ é€Ÿåº¦ä¼ æ„Ÿå™¨

```c
// MPU6050å¯„å­˜å™¨åœ°å€
#define MPU6050_ADDR        0x68
#define MPU6050_WHO_AM_I    0x75
#define MPU6050_PWR_MGMT_1  0x6B
#define MPU6050_CONFIG      0x1A
#define MPU6050_GYRO_CONFIG 0x1B
#define MPU6050_ACCEL_CONFIG 0x1C
#define MPU6050_ACCEL_XOUT_H 0x3B
#define MPU6050_TEMP_OUT_H   0x41
#define MPU6050_GYRO_XOUT_H  0x43

typedef struct {
    float accel_x, accel_y, accel_z;  // åŠ é€Ÿåº¦ (g)
    float gyro_x, gyro_y, gyro_z;     // è§’é€Ÿåº¦ (åº¦/ç§’)
    float temperature;                 // æ¸©åº¦ (æ‘„æ°åº¦)
    bool valid;
} mpu6050_data_t;

esp_err_t mpu6050_init(void)
{
    esp_err_t ret;
    
    // æ£€æŸ¥è®¾å¤‡ID
    uint8_t who_am_i;
    ret = i2c_read_bytes(MPU6050_ADDR, MPU6050_WHO_AM_I, &who_am_i, 1);
    if (ret != ESP_OK || who_am_i != 0x68) {
        ESP_LOGE(TAG, "MPU6050è®¾å¤‡IDéªŒè¯å¤±è´¥: 0x%02X", who_am_i);
        return ESP_FAIL;
    }
    
    // å”¤é†’è®¾å¤‡
    ret = i2c_write_byte(MPU6050_ADDR, MPU6050_PWR_MGMT_1, 0x00);
    if (ret != ESP_OK) return ret;
    
    // é…ç½®ä½é€šæ»¤æ³¢å™¨
    ret = i2c_write_byte(MPU6050_ADDR, MPU6050_CONFIG, 0x06);
    if (ret != ESP_OK) return ret;
    
    // é…ç½®é™€èºä»ªé‡ç¨‹ Â±250Â°/s
    ret = i2c_write_byte(MPU6050_ADDR, MPU6050_GYRO_CONFIG, 0x00);
    if (ret != ESP_OK) return ret;
    
    // é…ç½®åŠ é€Ÿåº¦è®¡é‡ç¨‹ Â±2g
    ret = i2c_write_byte(MPU6050_ADDR, MPU6050_ACCEL_CONFIG, 0x00);
    if (ret != ESP_OK) return ret;
    
    ESP_LOGI(TAG, "MPU6050åˆå§‹åŒ–å®Œæˆ");
    return ESP_OK;
}

esp_err_t mpu6050_read(mpu6050_data_t *data)
{
    uint8_t raw_data[14];
    
    // è¯»å–æ‰€æœ‰ä¼ æ„Ÿå™¨æ•°æ®
    esp_err_t ret = i2c_read_bytes(MPU6050_ADDR, MPU6050_ACCEL_XOUT_H, raw_data, 14);
    if (ret != ESP_OK) {
        data->valid = false;
        return ret;
    }
    
    // è§£æåŠ é€Ÿåº¦æ•°æ®
    int16_t accel_x_raw = (raw_data[0] << 8) | raw_data[1];
    int16_t accel_y_raw = (raw_data[2] << 8) | raw_data[3];
    int16_t accel_z_raw = (raw_data[4] << 8) | raw_data[5];
    
    data->accel_x = accel_x_raw / 16384.0;  // Â±2gé‡ç¨‹
    data->accel_y = accel_y_raw / 16384.0;
    data->accel_z = accel_z_raw / 16384.0;
    
    // è§£ææ¸©åº¦æ•°æ®
    int16_t temp_raw = (raw_data[6] << 8) | raw_data[7];
    data->temperature = temp_raw / 340.0 + 36.53;
    
    // è§£æé™€èºä»ªæ•°æ®
    int16_t gyro_x_raw = (raw_data[8] << 8) | raw_data[9];
    int16_t gyro_y_raw = (raw_data[10] << 8) | raw_data[11];
    int16_t gyro_z_raw = (raw_data[12] << 8) | raw_data[13];
    
    data->gyro_x = gyro_x_raw / 131.0;  // Â±250Â°/sé‡ç¨‹
    data->gyro_y = gyro_y_raw / 131.0;
    data->gyro_z = gyro_z_raw / 131.0;
    
    data->valid = true;
    return ESP_OK;
}

// è®¡ç®—å€¾æ–œè§’åº¦
typedef struct {
    float roll;   // ç¿»æ»šè§’
    float pitch;  // ä¿¯ä»°è§’
    float yaw;    // åèˆªè§’
} euler_angles_t;

euler_angles_t calculate_angles(mpu6050_data_t *imu_data)
{
    euler_angles_t angles;
    
    // ä½¿ç”¨åŠ é€Ÿåº¦è®¡è®¡ç®—å€¾æ–œè§’ï¼ˆé™æ€æ—¶ï¼‰
    angles.roll = atan2(imu_data->accel_y, imu_data->accel_z) * 180.0 / M_PI;
    angles.pitch = atan2(-imu_data->accel_x, 
                        sqrt(imu_data->accel_y * imu_data->accel_y + 
                             imu_data->accel_z * imu_data->accel_z)) * 180.0 / M_PI;
    
    // åèˆªè§’éœ€è¦ç£åŠ›è®¡é…åˆï¼Œè¿™é‡Œè®¾ä¸º0
    angles.yaw = 0.0;
    
    return angles;
}
```

## ğŸŒŠ SPIæ¥å£ä¼ æ„Ÿå™¨

### SPIåŸºç¡€é…ç½®

```c
#include "driver/spi_master.h"
#include "driver/gpio.h"

#define SPI_CLK_PIN     18
#define SPI_MOSI_PIN    23
#define SPI_MISO_PIN    19
#define SPI_CS_PIN      5

static spi_device_handle_t spi_device;

esp_err_t spi_init(void)
{
    esp_err_t ret;
    
    // SPIæ€»çº¿é…ç½®
    spi_bus_config_t buscfg = {
        .miso_io_num = SPI_MISO_PIN,
        .mosi_io_num = SPI_MOSI_PIN,
        .sclk_io_num = SPI_CLK_PIN,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = 64
    };
    
    // è®¾å¤‡é…ç½®
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 1000000,    // 1MHz
        .mode = 0,                    // SPIæ¨¡å¼0
        .spics_io_num = SPI_CS_PIN,
        .queue_size = 7,
        .pre_cb = NULL,
        .post_cb = NULL,
    };
    
    // åˆå§‹åŒ–SPIæ€»çº¿
    ret = spi_bus_initialize(VSPI_HOST, &buscfg, 1);
    if (ret != ESP_OK) return ret;
    
    // æ·»åŠ è®¾å¤‡åˆ°SPIæ€»çº¿
    ret = spi_bus_add_device(VSPI_HOST, &devcfg, &spi_device);
    return ret;
}

// SPIè¯»å†™æ“ä½œ
esp_err_t spi_write_read(uint8_t *write_data, uint8_t *read_data, uint8_t len)
{
    spi_transaction_t trans = {
        .length = len * 8,  // ä»¥ä½ä¸ºå•ä½
        .tx_buffer = write_data,
        .rx_buffer = read_data,
    };
    
    return spi_device_transmit(spi_device, &trans);
}
```

### MAX31855Kå‹çƒ­ç”µå¶ä¼ æ„Ÿå™¨

```c
// MAX31855Kå‹çƒ­ç”µå¶ä¼ æ„Ÿå™¨ï¼ˆSPIæ¥å£ï¼‰
#define MAX31855_CS_PIN  5

typedef struct {
    float thermocouple_temp;  // çƒ­ç”µå¶æ¸©åº¦
    float internal_temp;      // å†…éƒ¨æ¸©åº¦
    bool fault;               // æ•…éšœæ ‡å¿—
    uint8_t fault_code;       // æ•…éšœä»£ç 
} max31855_data_t;

esp_err_t max31855_read(max31855_data_t *data)
{
    uint8_t rx_data[4];
    uint8_t tx_data[4] = {0, 0, 0, 0};  // å‘é€ç©ºæ•°æ®
    
    esp_err_t ret = spi_write_read(tx_data, rx_data, 4);
    if (ret != ESP_OK) {
        return ret;
    }
    
    // ç»„åˆ32ä½æ•°æ®
    uint32_t raw_data = (rx_data[0] << 24) | (rx_data[1] << 16) | 
                        (rx_data[2] << 8) | rx_data[3];
    
    // æ£€æŸ¥æ•…éšœä½
    data->fault = (raw_data & 0x00010000) != 0;
    if (data->fault) {
        data->fault_code = raw_data & 0x07;  // æ•…éšœä»£ç åœ¨ä½3ä½
        return ESP_OK;
    }
    
    // è§£æçƒ­ç”µå¶æ¸©åº¦ï¼ˆ14ä½ï¼Œå¸¦ç¬¦å·ï¼‰
    int16_t tc_temp_raw = (raw_data >> 18) & 0x3FFF;
    if (tc_temp_raw & 0x2000) {  // æ£€æŸ¥ç¬¦å·ä½
        tc_temp_raw |= 0xC000;   // ç¬¦å·æ‰©å±•
    }
    data->thermocouple_temp = tc_temp_raw * 0.25;  // åˆ†è¾¨ç‡0.25Â°C
    
    // è§£æå†…éƒ¨æ¸©åº¦ï¼ˆ12ä½ï¼Œå¸¦ç¬¦å·ï¼‰
    int16_t int_temp_raw = (raw_data >> 4) & 0x0FFF;
    if (int_temp_raw & 0x0800) {  // æ£€æŸ¥ç¬¦å·ä½
        int_temp_raw |= 0xF000;   // ç¬¦å·æ‰©å±•
    }
    data->internal_temp = int_temp_raw * 0.0625;  // åˆ†è¾¨ç‡0.0625Â°C
    
    return ESP_OK;
}
```

## ğŸ“¡ UARTä¼ æ„Ÿå™¨æ¥å£

### GPSæ¨¡å—(NMEAåè®®)

```c
#include "driver/uart.h"
#include <string.h>

#define GPS_UART_NUM     UART_NUM_2
#define GPS_TXD_PIN      17
#define GPS_RXD_PIN      16
#define GPS_BUF_SIZE     1024

typedef struct {
    float latitude;     // çº¬åº¦
    float longitude;    // ç»åº¦
    float altitude;     // æµ·æ‹”
    float speed;        // é€Ÿåº¦ (km/h)
    uint8_t satellites; // å«æ˜Ÿæ•°é‡
    bool fix_valid;     // å®šä½æœ‰æ•ˆ
    char timestamp[16]; // æ—¶é—´æˆ³
} gps_data_t;

esp_err_t gps_init(void)
{
    uart_config_t uart_config = {
        .baud_rate = 9600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_APB,
    };
    
    // é…ç½®UARTå‚æ•°
    ESP_ERROR_CHECK(uart_param_config(GPS_UART_NUM, &uart_config));
    
    // è®¾ç½®UARTå¼•è„š
    ESP_ERROR_CHECK(uart_set_pin(GPS_UART_NUM, GPS_TXD_PIN, GPS_RXD_PIN, 
                                 UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
    
    // å®‰è£…UARTé©±åŠ¨
    ESP_ERROR_CHECK(uart_driver_install(GPS_UART_NUM, GPS_BUF_SIZE * 2, 0, 0, NULL, 0));
    
    return ESP_OK;
}

// è§£æGPRMC NMEAè¯­å¥
bool parse_gprmc(char *nmea_sentence, gps_data_t *gps_data)
{
    char *token;
    char *saveptr;
    int field = 0;
    
    // æ£€æŸ¥è¯­å¥ç±»å‹
    if (strncmp(nmea_sentence, "$GPRMC", 6) != 0) {
        return false;
    }
    
    token = strtok_r(nmea_sentence, ",", &saveptr);
    
    while (token != NULL && field < 12) {
        switch (field) {
        case 1:  // æ—¶é—´æˆ³
            if (strlen(token) >= 6) {
                snprintf(gps_data->timestamp, sizeof(gps_data->timestamp), 
                        "%.2s:%.2s:%.2s", token, token+2, token+4);
            }
            break;
            
        case 2:  // çŠ¶æ€ A=æœ‰æ•ˆ, V=æ— æ•ˆ
            gps_data->fix_valid = (token[0] == 'A');
            break;
            
        case 3:  // çº¬åº¦
            if (strlen(token) > 0) {
                float degrees = atof(token) / 100.0;
                int deg_int = (int)degrees;
                float minutes = (degrees - deg_int) * 100.0;
                gps_data->latitude = deg_int + minutes / 60.0;
            }
            break;
            
        case 4:  // çº¬åº¦æ–¹å‘ N/S
            if (token[0] == 'S') {
                gps_data->latitude = -gps_data->latitude;
            }
            break;
            
        case 5:  // ç»åº¦
            if (strlen(token) > 0) {
                float degrees = atof(token) / 100.0;
                int deg_int = (int)degrees;
                float minutes = (degrees - deg_int) * 100.0;
                gps_data->longitude = deg_int + minutes / 60.0;
            }
            break;
            
        case 6:  // ç»åº¦æ–¹å‘ E/W
            if (token[0] == 'W') {
                gps_data->longitude = -gps_data->longitude;
            }
            break;
            
        case 7:  // é€Ÿåº¦ (èŠ‚)
            if (strlen(token) > 0) {
                gps_data->speed = atof(token) * 1.852;  // è½¬æ¢ä¸ºkm/h
            }
            break;
        }
        
        token = strtok_r(NULL, ",", &saveptr);
        field++;
    }
    
    return gps_data->fix_valid;
}

void gps_task(void *pvParameters)
{
    char *data = (char *)malloc(GPS_BUF_SIZE);
    gps_data_t gps_data = {0};
    
    while (1) {
        int len = uart_read_bytes(GPS_UART_NUM, (uint8_t *)data, GPS_BUF_SIZE - 1, 
                                 pdMS_TO_TICKS(1000));
        
        if (len > 0) {
            data[len] = '\0';
            
            // æŸ¥æ‰¾NMEAè¯­å¥
            char *line = strtok(data, "\r\n");
            while (line != NULL) {
                if (parse_gprmc(line, &gps_data)) {
                    ESP_LOGI(TAG, "GPS: %.6f, %.6f, é€Ÿåº¦: %.1f km/h, æ—¶é—´: %s",
                             gps_data.latitude, gps_data.longitude, 
                             gps_data.speed, gps_data.timestamp);
                }
                line = strtok(NULL, "\r\n");
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(100));
    }
    
    free(data);
}
```

## ğŸ”„ 1-Wireæ¥å£(DS18B20æ¸©åº¦ä¼ æ„Ÿå™¨)

```c
#include "onewire_bus.h"
#include "ds18b20.h"

#define ONEWIRE_BUS_PIN    4
#define MAX_DS18B20_DEVICES 8

static onewire_bus_handle_t bus_handle;
static ds18b20_device_handle_t ds18b20_handles[MAX_DS18B20_DEVICES];
static int device_count = 0;

esp_err_t ds18b20_init(void)
{
    // åˆå§‹åŒ–1-Wireæ€»çº¿
    onewire_bus_config_t bus_config = {
        .bus_gpio_num = ONEWIRE_BUS_PIN,
    };
    
    esp_err_t ret = onewire_new_bus(&bus_config, &bus_handle);
    if (ret != ESP_OK) {
        return ret;
    }
    
    // æœç´¢DS18B20è®¾å¤‡
    onewire_device_iter_handle_t iter = NULL;
    onewire_device_t next_onewire_device;
    
    ret = onewire_new_device_iter(bus_handle, &iter);
    if (ret != ESP_OK) {
        return ret;
    }
    
    ESP_LOGI(TAG, "æœç´¢DS18B20è®¾å¤‡...");
    
    do {
        ret = onewire_device_iter_get_next(iter, &next_onewire_device);
        if (ret == ESP_OK) {
            ds18b20_config_t ds18b20_config = {};
            
            if (ds18b20_new_device(&next_onewire_device, &ds18b20_config, 
                                  &ds18b20_handles[device_count]) == ESP_OK) {
                ESP_LOGI(TAG, "æ‰¾åˆ°DS18B20è®¾å¤‡ %d", device_count);
                device_count++;
                
                if (device_count >= MAX_DS18B20_DEVICES) {
                    break;
                }
            }
        }
    } while (ret != ESP_ERR_NOT_FOUND);
    
    onewire_del_device_iter(iter);
    ESP_LOGI(TAG, "æ‰¾åˆ° %d ä¸ªDS18B20è®¾å¤‡", device_count);
    
    return ESP_OK;
}

void ds18b20_read_all(void)
{
    if (device_count == 0) {
        ESP_LOGW(TAG, "æ²¡æœ‰æ‰¾åˆ°DS18B20è®¾å¤‡");
        return;
    }
    
    // è§¦å‘æ‰€æœ‰è®¾å¤‡å¼€å§‹æ¸©åº¦è½¬æ¢
    for (int i = 0; i < device_count; i++) {
        ds18b20_trigger_temperature_conversion(ds18b20_handles[i]);
    }
    
    // ç­‰å¾…è½¬æ¢å®Œæˆï¼ˆæœ€å¤š750msï¼‰
    vTaskDelay(pdMS_TO_TICKS(800));
    
    // è¯»å–æ‰€æœ‰è®¾å¤‡çš„æ¸©åº¦
    for (int i = 0; i < device_count; i++) {
        float temperature;
        esp_err_t ret = ds18b20_get_temperature(ds18b20_handles[i], &temperature);
        
        if (ret == ESP_OK) {
            ESP_LOGI(TAG, "DS18B20è®¾å¤‡%dæ¸©åº¦: %.2fÂ°C", i, temperature);
        } else {
            ESP_LOGE(TAG, "è¯»å–DS18B20è®¾å¤‡%då¤±è´¥", i);
        }
    }
}
```

## ğŸ“Š å¤šä¼ æ„Ÿå™¨æ•°æ®èåˆ

### ä¼ æ„Ÿå™¨æ•°æ®ç®¡ç†ç³»ç»Ÿ

```c
#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/timers.h"

typedef enum {
    SENSOR_TYPE_TEMPERATURE,
    SENSOR_TYPE_HUMIDITY,
    SENSOR_TYPE_PRESSURE,
    SENSOR_TYPE_LIGHT,
    SENSOR_TYPE_MOTION,
    SENSOR_TYPE_GPS,
    SENSOR_TYPE_MAX
} sensor_type_t;

typedef struct {
    sensor_type_t type;
    uint32_t timestamp;
    float value[4];      // æœ€å¤š4ä¸ªå€¼ï¼ˆå¦‚GPSçš„ç»çº¬åº¦ç­‰ï¼‰
    bool valid;
    uint8_t quality;     // æ•°æ®è´¨é‡ 0-100
} sensor_reading_t;

typedef struct {
    sensor_type_t type;
    const char *name;
    float min_value;
    float max_value;
    uint32_t sample_interval_ms;
    bool (*read_func)(sensor_reading_t *reading);
} sensor_config_t;

// ä¼ æ„Ÿå™¨é…ç½®è¡¨
static sensor_config_t sensor_configs[] = {
    {
        .type = SENSOR_TYPE_TEMPERATURE,
        .name = "æ¸©åº¦ä¼ æ„Ÿå™¨",
        .min_value = -40.0,
        .max_value = 85.0,
        .sample_interval_ms = 5000,
        .read_func = read_temperature_sensor
    },
    {
        .type = SENSOR_TYPE_HUMIDITY,
        .name = "æ¹¿åº¦ä¼ æ„Ÿå™¨", 
        .min_value = 0.0,
        .max_value = 100.0,
        .sample_interval_ms = 5000,
        .read_func = read_humidity_sensor
    },
    // æ·»åŠ æ›´å¤šä¼ æ„Ÿå™¨é…ç½®...
};

// æ•°æ®é˜Ÿåˆ—å’Œå¤„ç†
static QueueHandle_t sensor_data_queue;
#define SENSOR_QUEUE_SIZE 50

// ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ä»»åŠ¡
void sensor_collection_task(void *pvParameters)
{
    sensor_reading_t reading;
    TickType_t last_wake_time = xTaskGetTickCount();
    
    while (1) {
        for (int i = 0; i < sizeof(sensor_configs)/sizeof(sensor_config_t); i++) {
            sensor_config_t *config = &sensor_configs[i];
            
            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾é‡‡æ ·æ—¶é—´
            static uint32_t last_sample_time[SENSOR_TYPE_MAX] = {0};
            uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;
            
            if (current_time - last_sample_time[config->type] >= config->sample_interval_ms) {
                if (config->read_func(&reading)) {
                    reading.timestamp = current_time;
                    
                    // æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥
                    if (reading.value[0] >= config->min_value && 
                        reading.value[0] <= config->max_value) {
                        reading.valid = true;
                        reading.quality = 100;  // ç®€åŒ–çš„è´¨é‡è¯„ä¼°
                        
                        // å‘é€åˆ°æ•°æ®å¤„ç†é˜Ÿåˆ—
                        if (xQueueSend(sensor_data_queue, &reading, 0) != pdTRUE) {
                            ESP_LOGW(TAG, "ä¼ æ„Ÿå™¨æ•°æ®é˜Ÿåˆ—æ»¡");
                        }
                    } else {
                        ESP_LOGW(TAG, "%sæ•°æ®è¶…å‡ºèŒƒå›´: %.2f", 
                                config->name, reading.value[0]);
                    }
                }
                
                last_sample_time[config->type] = current_time;
            }
        }
        
        vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(100));
    }
}

// æ•°æ®å¤„ç†å’Œå­˜å‚¨ä»»åŠ¡
void sensor_data_processing_task(void *pvParameters)
{
    sensor_reading_t reading;
    
    while (1) {
        if (xQueueReceive(sensor_data_queue, &reading, portMAX_DELAY) == pdTRUE) {
            // æ•°æ®é¢„å¤„ç†
            process_sensor_data(&reading);
            
            // æ•°æ®å­˜å‚¨ï¼ˆå¯é€‰æ‹©å­˜å‚¨åˆ°Flashã€SDå¡æˆ–å‘é€åˆ°äº‘ç«¯ï¼‰
            store_sensor_data(&reading);
            
            // å®æ—¶ç›‘æ§å’ŒæŠ¥è­¦
            check_sensor_alarms(&reading);
            
            // æ‰“å°ä¼ æ„Ÿå™¨æ•°æ®
            ESP_LOGI(TAG, "[%u] %s: %.2f (è´¨é‡: %d%%)", 
                     reading.timestamp, 
                     get_sensor_name(reading.type),
                     reading.value[0],
                     reading.quality);
        }
    }
}

// æ•°æ®é¢„å¤„ç†ï¼ˆæ»¤æ³¢ã€æ ¡å‡†ç­‰ï¼‰
void process_sensor_data(sensor_reading_t *reading)
{
    static float filter_history[SENSOR_TYPE_MAX][5] = {0};  // 5ç‚¹æ»‘åŠ¨å¹³å‡
    static int filter_index[SENSOR_TYPE_MAX] = {0};
    
    if (reading->type < SENSOR_TYPE_MAX) {
        // æ»‘åŠ¨å¹³å‡æ»¤æ³¢
        int idx = filter_index[reading->type];
        filter_history[reading->type][idx] = reading->value[0];
        filter_index[reading->type] = (idx + 1) % 5;
        
        // è®¡ç®—å¹³å‡å€¼
        float sum = 0;
        for (int i = 0; i < 5; i++) {
            sum += filter_history[reading->type][i];
        }
        reading->value[0] = sum / 5.0;
    }
}

// ä¼ æ„Ÿå™¨ç³»ç»Ÿåˆå§‹åŒ–
esp_err_t sensor_system_init(void)
{
    esp_err_t ret = ESP_OK;
    
    // åˆ›å»ºæ•°æ®é˜Ÿåˆ—
    sensor_data_queue = xQueueCreate(SENSOR_QUEUE_SIZE, sizeof(sensor_reading_t));
    if (!sensor_data_queue) {
        return ESP_ERR_NO_MEM;
    }
    
    // åˆå§‹åŒ–å„ä¸ªä¼ æ„Ÿå™¨æ¥å£
    ret |= i2c_master_init();
    ret |= spi_init();
    ret |= adc_init();
    ret |= gps_init();
    ret |= ds18b20_init();
    
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "ä¼ æ„Ÿå™¨æ¥å£åˆå§‹åŒ–å¤±è´¥");
        return ret;
    }
    
    // åˆ›å»ºæ•°æ®é‡‡é›†ä»»åŠ¡
    xTaskCreate(sensor_collection_task, "sensor_collection", 4096, NULL, 5, NULL);
    
    // åˆ›å»ºæ•°æ®å¤„ç†ä»»åŠ¡
    xTaskCreate(sensor_data_processing_task, "sensor_processing", 4096, NULL, 4, NULL);
    
    ESP_LOGI(TAG, "ä¼ æ„Ÿå™¨ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
    return ESP_OK;
}
```

---

> **ä¼ æ„Ÿå™¨æ¥å£æ€»ç»“**ï¼šESP32ä¸°å¯Œçš„æ¥å£æ”¯æŒå„ç§ä¼ æ„Ÿå™¨è¿æ¥ï¼Œä»ç®€å•çš„æ¨¡æ‹Ÿä¼ æ„Ÿå™¨åˆ°å¤æ‚çš„æ•°å­—ä¼ æ„Ÿå™¨éƒ½èƒ½è½»æ¾å¤„ç†ã€‚åˆç†é€‰æ‹©æ¥å£åè®®ã€å®ç°æ•°æ®é‡‡é›†ç³»ç»Ÿã€åŠ å…¥æ»¤æ³¢å’Œæ ¡å‡†ç®—æ³•ï¼Œå¯ä»¥æ„å»ºç¨³å®šå¯é çš„ä¼ æ„Ÿå™¨ç½‘ç»œã€‚æ•°æ®èåˆæŠ€æœ¯èƒ½å¤Ÿæä¾›æ›´å‡†ç¡®ã€æ›´å…¨é¢çš„ç¯å¢ƒç›‘æµ‹èƒ½åŠ›ã€‚

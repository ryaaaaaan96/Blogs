# ESP32传感器接口与数据采集

## 📋 概述

ESP32具有丰富的外设接口，支持多种传感器连接方式。本文将详细介绍常用传感器的接口协议、数据采集方法和实际应用案例，帮助开发者快速构建传感器应用系统。

## 🔌 常用接口协议

### 接口类型对比

| 接口类型 | 传输速度 | 连接距离 | 功耗 | 复杂度 | 适用传感器 |
|---------|----------|----------|------|--------|------------|
| GPIO | 快 | 短 | 低 | 简单 | 开关、LED、继电器 |
| ADC | 中 | 短 | 低 | 简单 | 模拟传感器、电位器 |
| I2C | 中 | 短-中 | 低 | 中等 | 温湿度、气压、陀螺仪 |
| SPI | 快 | 短 | 中 | 中等 | 显示屏、存储器 |
| UART | 中 | 长 | 中 | 简单 | GPS、串口传感器 |
| 1-Wire | 慢 | 中 | 低 | 简单 | 温度传感器DS18B20 |

## 📊 ADC模拟信号采集

### ADC基础配置

```c
#include "driver/adc.h"
#include "esp_adc_cal.h"
#include "esp_log.h"

static const char *TAG = "ADC_EXAMPLE";

// ADC校准参数
static esp_adc_cal_characteristics_t adc_chars;

// ADC初始化
void adc_init(void)
{
    // 配置ADC1_CHANNEL_6 (GPIO34)
    adc1_config_width(ADC_WIDTH_BIT_12);  // 12位分辨率
    adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_DB_11);  // 11dB衰减，测量范围0-3.3V
    
    // ADC校准
    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(ADC_UNIT_1, 
                                                            ADC_ATTEN_DB_11, 
                                                            ADC_WIDTH_BIT_12, 
                                                            1100, 
                                                            &adc_chars);
    
    if (val_type == ESP_ADC_CAL_VAL_EFUSE_TP) {
        ESP_LOGI(TAG, "Characterized using Two Point Value");
    } else if (val_type == ESP_ADC_CAL_VAL_EFUSE_VREF) {
        ESP_LOGI(TAG, "Characterized using eFuse Vref");
    } else {
        ESP_LOGI(TAG, "Characterized using Default Vref");
    }
}

// 读取ADC电压值
uint32_t read_adc_voltage(adc1_channel_t channel)
{
    uint32_t adc_reading = 0;
    
    // 多次采样求平均值，提高精度
    for (int i = 0; i < 64; i++) {
        adc_reading += adc1_get_raw(channel);
    }
    adc_reading /= 64;
    
    // 转换为电压值（毫伏）
    uint32_t voltage = esp_adc_cal_raw_to_voltage(adc_reading, &adc_chars);
    
    return voltage;
}

// 多通道ADC采集示例
typedef struct {
    adc1_channel_t channel;
    const char* name;
    float scale_factor;  // 比例因子
    float offset;        // 偏移量
} adc_sensor_t;

static adc_sensor_t adc_sensors[] = {
    {ADC1_CHANNEL_6, "温度传感器", 0.01, -273.15},      // LM35温度传感器
    {ADC1_CHANNEL_7, "光敏电阻", 1.0, 0},                 // 光敏电阻
    {ADC1_CHANNEL_4, "土壤湿度", 0.1, 0},                // 土壤湿度传感器
    {ADC1_CHANNEL_5, "气体传感器", 1.0, 0},              // MQ系列气体传感器
};

void multi_channel_adc_task(void *pvParameters)
{
    adc_init();
    
    while (1) {
        ESP_LOGI(TAG, "=== ADC传感器读数 ===");
        
        for (int i = 0; i < sizeof(adc_sensors)/sizeof(adc_sensor_t); i++) {
            uint32_t voltage = read_adc_voltage(adc_sensors[i].channel);
            float sensor_value = voltage * adc_sensors[i].scale_factor + adc_sensors[i].offset;
            
            ESP_LOGI(TAG, "%s: %d mV, 转换值: %.2f", 
                     adc_sensors[i].name, voltage, sensor_value);
        }
        
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}
```

### 高精度ADC采集技术

```c
#include "driver/adc.h"
#include "esp_adc_cal.h"
#include "driver/dac.h"

// 差分ADC配置（提高抗干扰能力）
typedef struct {
    adc1_channel_t pos_channel;  // 正极通道
    adc1_channel_t neg_channel;  // 负极通道（参考电平）
} differential_adc_t;

// 过采样和数字滤波
#define OVERSAMPLE_BITS    4    // 过采样4位，相当于16倍过采样
#define FILTER_SIZE       16    // 滑动平均滤波器大小

static uint32_t filter_buffer[FILTER_SIZE] = {0};
static uint8_t filter_index = 0;

uint32_t filtered_adc_read(adc1_channel_t channel)
{
    uint32_t sum = 0;
    uint32_t samples = 1 << OVERSAMPLE_BITS;  // 2^4 = 16次采样
    
    // 过采样
    for (uint32_t i = 0; i < samples; i++) {
        sum += adc1_get_raw(channel);
        vTaskDelay(1);  // 短暂延时，避免噪声相关
    }
    
    // 右移得到高精度结果
    uint32_t oversampled = sum >> OVERSAMPLE_BITS;
    
    // 滑动平均滤波
    filter_buffer[filter_index] = oversampled;
    filter_index = (filter_index + 1) % FILTER_SIZE;
    
    uint32_t filtered_sum = 0;
    for (int i = 0; i < FILTER_SIZE; i++) {
        filtered_sum += filter_buffer[i];
    }
    
    return filtered_sum / FILTER_SIZE;
}

// 温度传感器NTC热敏电阻处理
float ntc_temperature_calculate(uint32_t adc_value)
{
    // Steinhart-Hart方程参数（需要根据具体NTC型号调整）
    const float A = 1.129148e-3;
    const float B = 2.34125e-4;
    const float C = 8.76741e-8;
    
    // 将ADC值转换为电阻值
    float vdd = 3300.0;  // 供电电压 3.3V
    float r_series = 10000.0;  // 串联电阻 10kΩ
    
    float voltage = (adc_value / 4095.0) * vdd;
    float resistance = r_series * voltage / (vdd - voltage);
    
    // Steinhart-Hart方程计算温度
    float ln_r = log(resistance);
    float temp_k = 1.0 / (A + B * ln_r + C * ln_r * ln_r * ln_r);
    float temp_c = temp_k - 273.15;
    
    return temp_c;
}
```

## 🌡️ I2C传感器接口

### I2C基础配置

```c
#include "driver/i2c.h"
#include "esp_log.h"

#define I2C_MASTER_SCL_IO    22    // SCL引脚
#define I2C_MASTER_SDA_IO    21    // SDA引脚
#define I2C_MASTER_NUM       I2C_NUM_0
#define I2C_MASTER_FREQ_HZ   100000  // 100kHz
#define I2C_MASTER_TX_BUF_DISABLE 0
#define I2C_MASTER_RX_BUF_DISABLE 0

static const char *TAG = "I2C_SENSORS";

// I2C主机初始化
esp_err_t i2c_master_init(void)
{
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ,
    };
    
    esp_err_t err = i2c_param_config(I2C_MASTER_NUM, &conf);
    if (err != ESP_OK) {
        return err;
    }
    
    return i2c_driver_install(I2C_MASTER_NUM, conf.mode, 
                             I2C_MASTER_RX_BUF_DISABLE, 
                             I2C_MASTER_TX_BUF_DISABLE, 0);
}

// I2C写入操作
esp_err_t i2c_write_byte(uint8_t slave_addr, uint8_t reg_addr, uint8_t data)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (slave_addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg_addr, true);
    i2c_master_write_byte(cmd, data, true);
    i2c_master_stop(cmd);
    
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    
    return ret;
}

// I2C读取操作
esp_err_t i2c_read_bytes(uint8_t slave_addr, uint8_t reg_addr, uint8_t *data, uint8_t len)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    
    // 写入寄存器地址
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (slave_addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg_addr, true);
    
    // 重新开始，读取数据
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (slave_addr << 1) | I2C_MASTER_READ, true);
    
    if (len > 1) {
        i2c_master_read(cmd, data, len - 1, I2C_MASTER_ACK);
    }
    i2c_master_read_byte(cmd, data + len - 1, I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    
    return ret;
}

// I2C设备扫描
void i2c_scanner(void)
{
    ESP_LOGI(TAG, "开始I2C设备扫描...");
    
    for (uint8_t addr = 1; addr < 127; addr++) {
        i2c_cmd_handle_t cmd = i2c_cmd_link_create();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (addr << 1) | I2C_MASTER_WRITE, true);
        i2c_master_stop(cmd);
        
        esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(100));
        i2c_cmd_link_delete(cmd);
        
        if (ret == ESP_OK) {
            ESP_LOGI(TAG, "找到I2C设备，地址: 0x%02X", addr);
        }
    }
    
    ESP_LOGI(TAG, "I2C扫描完成");
}
```

### DHT22温湿度传感器(I2C版本)

```c
// SHT30温湿度传感器 (I2C接口)
#define SHT30_ADDR    0x44
#define SHT30_CMD_MEASURE_HIGH    0x2C06  // 高精度测量命令

typedef struct {
    float temperature;
    float humidity;
    bool valid;
} sht30_data_t;

esp_err_t sht30_read(sht30_data_t *data)
{
    uint8_t cmd[2] = {0x2C, 0x06};  // 高精度测量命令
    uint8_t response[6];
    
    // 发送测量命令
    i2c_cmd_handle_t cmd_handle = i2c_cmd_link_create();
    i2c_master_start(cmd_handle);
    i2c_master_write_byte(cmd_handle, (SHT30_ADDR << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write(cmd_handle, cmd, 2, true);
    i2c_master_stop(cmd_handle);
    
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd_handle, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd_handle);
    
    if (ret != ESP_OK) {
        data->valid = false;
        return ret;
    }
    
    // 等待测量完成
    vTaskDelay(pdMS_TO_TICKS(20));
    
    // 读取测量结果
    cmd_handle = i2c_cmd_link_create();
    i2c_master_start(cmd_handle);
    i2c_master_write_byte(cmd_handle, (SHT30_ADDR << 1) | I2C_MASTER_READ, true);
    i2c_master_read(cmd_handle, response, 5, I2C_MASTER_ACK);
    i2c_master_read_byte(cmd_handle, &response[5], I2C_MASTER_NACK);
    i2c_master_stop(cmd_handle);
    
    ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd_handle, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd_handle);
    
    if (ret != ESP_OK) {
        data->valid = false;
        return ret;
    }
    
    // CRC校验（简化版本）
    // 实际应用中应该进行完整的CRC校验
    
    // 转换温度数据
    uint16_t temp_raw = (response[0] << 8) | response[1];
    data->temperature = -45.0 + 175.0 * temp_raw / 65535.0;
    
    // 转换湿度数据
    uint16_t hum_raw = (response[3] << 8) | response[4];
    data->humidity = 100.0 * hum_raw / 65535.0;
    
    data->valid = true;
    return ESP_OK;
}
```

### MPU6050陀螺仪加速度传感器

```c
// MPU6050寄存器地址
#define MPU6050_ADDR        0x68
#define MPU6050_WHO_AM_I    0x75
#define MPU6050_PWR_MGMT_1  0x6B
#define MPU6050_CONFIG      0x1A
#define MPU6050_GYRO_CONFIG 0x1B
#define MPU6050_ACCEL_CONFIG 0x1C
#define MPU6050_ACCEL_XOUT_H 0x3B
#define MPU6050_TEMP_OUT_H   0x41
#define MPU6050_GYRO_XOUT_H  0x43

typedef struct {
    float accel_x, accel_y, accel_z;  // 加速度 (g)
    float gyro_x, gyro_y, gyro_z;     // 角速度 (度/秒)
    float temperature;                 // 温度 (摄氏度)
    bool valid;
} mpu6050_data_t;

esp_err_t mpu6050_init(void)
{
    esp_err_t ret;
    
    // 检查设备ID
    uint8_t who_am_i;
    ret = i2c_read_bytes(MPU6050_ADDR, MPU6050_WHO_AM_I, &who_am_i, 1);
    if (ret != ESP_OK || who_am_i != 0x68) {
        ESP_LOGE(TAG, "MPU6050设备ID验证失败: 0x%02X", who_am_i);
        return ESP_FAIL;
    }
    
    // 唤醒设备
    ret = i2c_write_byte(MPU6050_ADDR, MPU6050_PWR_MGMT_1, 0x00);
    if (ret != ESP_OK) return ret;
    
    // 配置低通滤波器
    ret = i2c_write_byte(MPU6050_ADDR, MPU6050_CONFIG, 0x06);
    if (ret != ESP_OK) return ret;
    
    // 配置陀螺仪量程 ±250°/s
    ret = i2c_write_byte(MPU6050_ADDR, MPU6050_GYRO_CONFIG, 0x00);
    if (ret != ESP_OK) return ret;
    
    // 配置加速度计量程 ±2g
    ret = i2c_write_byte(MPU6050_ADDR, MPU6050_ACCEL_CONFIG, 0x00);
    if (ret != ESP_OK) return ret;
    
    ESP_LOGI(TAG, "MPU6050初始化完成");
    return ESP_OK;
}

esp_err_t mpu6050_read(mpu6050_data_t *data)
{
    uint8_t raw_data[14];
    
    // 读取所有传感器数据
    esp_err_t ret = i2c_read_bytes(MPU6050_ADDR, MPU6050_ACCEL_XOUT_H, raw_data, 14);
    if (ret != ESP_OK) {
        data->valid = false;
        return ret;
    }
    
    // 解析加速度数据
    int16_t accel_x_raw = (raw_data[0] << 8) | raw_data[1];
    int16_t accel_y_raw = (raw_data[2] << 8) | raw_data[3];
    int16_t accel_z_raw = (raw_data[4] << 8) | raw_data[5];
    
    data->accel_x = accel_x_raw / 16384.0;  // ±2g量程
    data->accel_y = accel_y_raw / 16384.0;
    data->accel_z = accel_z_raw / 16384.0;
    
    // 解析温度数据
    int16_t temp_raw = (raw_data[6] << 8) | raw_data[7];
    data->temperature = temp_raw / 340.0 + 36.53;
    
    // 解析陀螺仪数据
    int16_t gyro_x_raw = (raw_data[8] << 8) | raw_data[9];
    int16_t gyro_y_raw = (raw_data[10] << 8) | raw_data[11];
    int16_t gyro_z_raw = (raw_data[12] << 8) | raw_data[13];
    
    data->gyro_x = gyro_x_raw / 131.0;  // ±250°/s量程
    data->gyro_y = gyro_y_raw / 131.0;
    data->gyro_z = gyro_z_raw / 131.0;
    
    data->valid = true;
    return ESP_OK;
}

// 计算倾斜角度
typedef struct {
    float roll;   // 翻滚角
    float pitch;  // 俯仰角
    float yaw;    // 偏航角
} euler_angles_t;

euler_angles_t calculate_angles(mpu6050_data_t *imu_data)
{
    euler_angles_t angles;
    
    // 使用加速度计计算倾斜角（静态时）
    angles.roll = atan2(imu_data->accel_y, imu_data->accel_z) * 180.0 / M_PI;
    angles.pitch = atan2(-imu_data->accel_x, 
                        sqrt(imu_data->accel_y * imu_data->accel_y + 
                             imu_data->accel_z * imu_data->accel_z)) * 180.0 / M_PI;
    
    // 偏航角需要磁力计配合，这里设为0
    angles.yaw = 0.0;
    
    return angles;
}
```

## 🌊 SPI接口传感器

### SPI基础配置

```c
#include "driver/spi_master.h"
#include "driver/gpio.h"

#define SPI_CLK_PIN     18
#define SPI_MOSI_PIN    23
#define SPI_MISO_PIN    19
#define SPI_CS_PIN      5

static spi_device_handle_t spi_device;

esp_err_t spi_init(void)
{
    esp_err_t ret;
    
    // SPI总线配置
    spi_bus_config_t buscfg = {
        .miso_io_num = SPI_MISO_PIN,
        .mosi_io_num = SPI_MOSI_PIN,
        .sclk_io_num = SPI_CLK_PIN,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = 64
    };
    
    // 设备配置
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 1000000,    // 1MHz
        .mode = 0,                    // SPI模式0
        .spics_io_num = SPI_CS_PIN,
        .queue_size = 7,
        .pre_cb = NULL,
        .post_cb = NULL,
    };
    
    // 初始化SPI总线
    ret = spi_bus_initialize(VSPI_HOST, &buscfg, 1);
    if (ret != ESP_OK) return ret;
    
    // 添加设备到SPI总线
    ret = spi_bus_add_device(VSPI_HOST, &devcfg, &spi_device);
    return ret;
}

// SPI读写操作
esp_err_t spi_write_read(uint8_t *write_data, uint8_t *read_data, uint8_t len)
{
    spi_transaction_t trans = {
        .length = len * 8,  // 以位为单位
        .tx_buffer = write_data,
        .rx_buffer = read_data,
    };
    
    return spi_device_transmit(spi_device, &trans);
}
```

### MAX31855K型热电偶传感器

```c
// MAX31855K型热电偶传感器（SPI接口）
#define MAX31855_CS_PIN  5

typedef struct {
    float thermocouple_temp;  // 热电偶温度
    float internal_temp;      // 内部温度
    bool fault;               // 故障标志
    uint8_t fault_code;       // 故障代码
} max31855_data_t;

esp_err_t max31855_read(max31855_data_t *data)
{
    uint8_t rx_data[4];
    uint8_t tx_data[4] = {0, 0, 0, 0};  // 发送空数据
    
    esp_err_t ret = spi_write_read(tx_data, rx_data, 4);
    if (ret != ESP_OK) {
        return ret;
    }
    
    // 组合32位数据
    uint32_t raw_data = (rx_data[0] << 24) | (rx_data[1] << 16) | 
                        (rx_data[2] << 8) | rx_data[3];
    
    // 检查故障位
    data->fault = (raw_data & 0x00010000) != 0;
    if (data->fault) {
        data->fault_code = raw_data & 0x07;  // 故障代码在低3位
        return ESP_OK;
    }
    
    // 解析热电偶温度（14位，带符号）
    int16_t tc_temp_raw = (raw_data >> 18) & 0x3FFF;
    if (tc_temp_raw & 0x2000) {  // 检查符号位
        tc_temp_raw |= 0xC000;   // 符号扩展
    }
    data->thermocouple_temp = tc_temp_raw * 0.25;  // 分辨率0.25°C
    
    // 解析内部温度（12位，带符号）
    int16_t int_temp_raw = (raw_data >> 4) & 0x0FFF;
    if (int_temp_raw & 0x0800) {  // 检查符号位
        int_temp_raw |= 0xF000;   // 符号扩展
    }
    data->internal_temp = int_temp_raw * 0.0625;  // 分辨率0.0625°C
    
    return ESP_OK;
}
```

## 📡 UART传感器接口

### GPS模块(NMEA协议)

```c
#include "driver/uart.h"
#include <string.h>

#define GPS_UART_NUM     UART_NUM_2
#define GPS_TXD_PIN      17
#define GPS_RXD_PIN      16
#define GPS_BUF_SIZE     1024

typedef struct {
    float latitude;     // 纬度
    float longitude;    // 经度
    float altitude;     // 海拔
    float speed;        // 速度 (km/h)
    uint8_t satellites; // 卫星数量
    bool fix_valid;     // 定位有效
    char timestamp[16]; // 时间戳
} gps_data_t;

esp_err_t gps_init(void)
{
    uart_config_t uart_config = {
        .baud_rate = 9600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_APB,
    };
    
    // 配置UART参数
    ESP_ERROR_CHECK(uart_param_config(GPS_UART_NUM, &uart_config));
    
    // 设置UART引脚
    ESP_ERROR_CHECK(uart_set_pin(GPS_UART_NUM, GPS_TXD_PIN, GPS_RXD_PIN, 
                                 UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
    
    // 安装UART驱动
    ESP_ERROR_CHECK(uart_driver_install(GPS_UART_NUM, GPS_BUF_SIZE * 2, 0, 0, NULL, 0));
    
    return ESP_OK;
}

// 解析GPRMC NMEA语句
bool parse_gprmc(char *nmea_sentence, gps_data_t *gps_data)
{
    char *token;
    char *saveptr;
    int field = 0;
    
    // 检查语句类型
    if (strncmp(nmea_sentence, "$GPRMC", 6) != 0) {
        return false;
    }
    
    token = strtok_r(nmea_sentence, ",", &saveptr);
    
    while (token != NULL && field < 12) {
        switch (field) {
        case 1:  // 时间戳
            if (strlen(token) >= 6) {
                snprintf(gps_data->timestamp, sizeof(gps_data->timestamp), 
                        "%.2s:%.2s:%.2s", token, token+2, token+4);
            }
            break;
            
        case 2:  // 状态 A=有效, V=无效
            gps_data->fix_valid = (token[0] == 'A');
            break;
            
        case 3:  // 纬度
            if (strlen(token) > 0) {
                float degrees = atof(token) / 100.0;
                int deg_int = (int)degrees;
                float minutes = (degrees - deg_int) * 100.0;
                gps_data->latitude = deg_int + minutes / 60.0;
            }
            break;
            
        case 4:  // 纬度方向 N/S
            if (token[0] == 'S') {
                gps_data->latitude = -gps_data->latitude;
            }
            break;
            
        case 5:  // 经度
            if (strlen(token) > 0) {
                float degrees = atof(token) / 100.0;
                int deg_int = (int)degrees;
                float minutes = (degrees - deg_int) * 100.0;
                gps_data->longitude = deg_int + minutes / 60.0;
            }
            break;
            
        case 6:  // 经度方向 E/W
            if (token[0] == 'W') {
                gps_data->longitude = -gps_data->longitude;
            }
            break;
            
        case 7:  // 速度 (节)
            if (strlen(token) > 0) {
                gps_data->speed = atof(token) * 1.852;  // 转换为km/h
            }
            break;
        }
        
        token = strtok_r(NULL, ",", &saveptr);
        field++;
    }
    
    return gps_data->fix_valid;
}

void gps_task(void *pvParameters)
{
    char *data = (char *)malloc(GPS_BUF_SIZE);
    gps_data_t gps_data = {0};
    
    while (1) {
        int len = uart_read_bytes(GPS_UART_NUM, (uint8_t *)data, GPS_BUF_SIZE - 1, 
                                 pdMS_TO_TICKS(1000));
        
        if (len > 0) {
            data[len] = '\0';
            
            // 查找NMEA语句
            char *line = strtok(data, "\r\n");
            while (line != NULL) {
                if (parse_gprmc(line, &gps_data)) {
                    ESP_LOGI(TAG, "GPS: %.6f, %.6f, 速度: %.1f km/h, 时间: %s",
                             gps_data.latitude, gps_data.longitude, 
                             gps_data.speed, gps_data.timestamp);
                }
                line = strtok(NULL, "\r\n");
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(100));
    }
    
    free(data);
}
```

## 🔄 1-Wire接口(DS18B20温度传感器)

```c
#include "onewire_bus.h"
#include "ds18b20.h"

#define ONEWIRE_BUS_PIN    4
#define MAX_DS18B20_DEVICES 8

static onewire_bus_handle_t bus_handle;
static ds18b20_device_handle_t ds18b20_handles[MAX_DS18B20_DEVICES];
static int device_count = 0;

esp_err_t ds18b20_init(void)
{
    // 初始化1-Wire总线
    onewire_bus_config_t bus_config = {
        .bus_gpio_num = ONEWIRE_BUS_PIN,
    };
    
    esp_err_t ret = onewire_new_bus(&bus_config, &bus_handle);
    if (ret != ESP_OK) {
        return ret;
    }
    
    // 搜索DS18B20设备
    onewire_device_iter_handle_t iter = NULL;
    onewire_device_t next_onewire_device;
    
    ret = onewire_new_device_iter(bus_handle, &iter);
    if (ret != ESP_OK) {
        return ret;
    }
    
    ESP_LOGI(TAG, "搜索DS18B20设备...");
    
    do {
        ret = onewire_device_iter_get_next(iter, &next_onewire_device);
        if (ret == ESP_OK) {
            ds18b20_config_t ds18b20_config = {};
            
            if (ds18b20_new_device(&next_onewire_device, &ds18b20_config, 
                                  &ds18b20_handles[device_count]) == ESP_OK) {
                ESP_LOGI(TAG, "找到DS18B20设备 %d", device_count);
                device_count++;
                
                if (device_count >= MAX_DS18B20_DEVICES) {
                    break;
                }
            }
        }
    } while (ret != ESP_ERR_NOT_FOUND);
    
    onewire_del_device_iter(iter);
    ESP_LOGI(TAG, "找到 %d 个DS18B20设备", device_count);
    
    return ESP_OK;
}

void ds18b20_read_all(void)
{
    if (device_count == 0) {
        ESP_LOGW(TAG, "没有找到DS18B20设备");
        return;
    }
    
    // 触发所有设备开始温度转换
    for (int i = 0; i < device_count; i++) {
        ds18b20_trigger_temperature_conversion(ds18b20_handles[i]);
    }
    
    // 等待转换完成（最多750ms）
    vTaskDelay(pdMS_TO_TICKS(800));
    
    // 读取所有设备的温度
    for (int i = 0; i < device_count; i++) {
        float temperature;
        esp_err_t ret = ds18b20_get_temperature(ds18b20_handles[i], &temperature);
        
        if (ret == ESP_OK) {
            ESP_LOGI(TAG, "DS18B20设备%d温度: %.2f°C", i, temperature);
        } else {
            ESP_LOGE(TAG, "读取DS18B20设备%d失败", i);
        }
    }
}
```

## 📊 多传感器数据融合

### 传感器数据管理系统

```c
#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/timers.h"

typedef enum {
    SENSOR_TYPE_TEMPERATURE,
    SENSOR_TYPE_HUMIDITY,
    SENSOR_TYPE_PRESSURE,
    SENSOR_TYPE_LIGHT,
    SENSOR_TYPE_MOTION,
    SENSOR_TYPE_GPS,
    SENSOR_TYPE_MAX
} sensor_type_t;

typedef struct {
    sensor_type_t type;
    uint32_t timestamp;
    float value[4];      // 最多4个值（如GPS的经纬度等）
    bool valid;
    uint8_t quality;     // 数据质量 0-100
} sensor_reading_t;

typedef struct {
    sensor_type_t type;
    const char *name;
    float min_value;
    float max_value;
    uint32_t sample_interval_ms;
    bool (*read_func)(sensor_reading_t *reading);
} sensor_config_t;

// 传感器配置表
static sensor_config_t sensor_configs[] = {
    {
        .type = SENSOR_TYPE_TEMPERATURE,
        .name = "温度传感器",
        .min_value = -40.0,
        .max_value = 85.0,
        .sample_interval_ms = 5000,
        .read_func = read_temperature_sensor
    },
    {
        .type = SENSOR_TYPE_HUMIDITY,
        .name = "湿度传感器", 
        .min_value = 0.0,
        .max_value = 100.0,
        .sample_interval_ms = 5000,
        .read_func = read_humidity_sensor
    },
    // 添加更多传感器配置...
};

// 数据队列和处理
static QueueHandle_t sensor_data_queue;
#define SENSOR_QUEUE_SIZE 50

// 传感器数据采集任务
void sensor_collection_task(void *pvParameters)
{
    sensor_reading_t reading;
    TickType_t last_wake_time = xTaskGetTickCount();
    
    while (1) {
        for (int i = 0; i < sizeof(sensor_configs)/sizeof(sensor_config_t); i++) {
            sensor_config_t *config = &sensor_configs[i];
            
            // 检查是否到达采样时间
            static uint32_t last_sample_time[SENSOR_TYPE_MAX] = {0};
            uint32_t current_time = xTaskGetTickCount() * portTICK_PERIOD_MS;
            
            if (current_time - last_sample_time[config->type] >= config->sample_interval_ms) {
                if (config->read_func(&reading)) {
                    reading.timestamp = current_time;
                    
                    // 数据有效性检查
                    if (reading.value[0] >= config->min_value && 
                        reading.value[0] <= config->max_value) {
                        reading.valid = true;
                        reading.quality = 100;  // 简化的质量评估
                        
                        // 发送到数据处理队列
                        if (xQueueSend(sensor_data_queue, &reading, 0) != pdTRUE) {
                            ESP_LOGW(TAG, "传感器数据队列满");
                        }
                    } else {
                        ESP_LOGW(TAG, "%s数据超出范围: %.2f", 
                                config->name, reading.value[0]);
                    }
                }
                
                last_sample_time[config->type] = current_time;
            }
        }
        
        vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(100));
    }
}

// 数据处理和存储任务
void sensor_data_processing_task(void *pvParameters)
{
    sensor_reading_t reading;
    
    while (1) {
        if (xQueueReceive(sensor_data_queue, &reading, portMAX_DELAY) == pdTRUE) {
            // 数据预处理
            process_sensor_data(&reading);
            
            // 数据存储（可选择存储到Flash、SD卡或发送到云端）
            store_sensor_data(&reading);
            
            // 实时监控和报警
            check_sensor_alarms(&reading);
            
            // 打印传感器数据
            ESP_LOGI(TAG, "[%u] %s: %.2f (质量: %d%%)", 
                     reading.timestamp, 
                     get_sensor_name(reading.type),
                     reading.value[0],
                     reading.quality);
        }
    }
}

// 数据预处理（滤波、校准等）
void process_sensor_data(sensor_reading_t *reading)
{
    static float filter_history[SENSOR_TYPE_MAX][5] = {0};  // 5点滑动平均
    static int filter_index[SENSOR_TYPE_MAX] = {0};
    
    if (reading->type < SENSOR_TYPE_MAX) {
        // 滑动平均滤波
        int idx = filter_index[reading->type];
        filter_history[reading->type][idx] = reading->value[0];
        filter_index[reading->type] = (idx + 1) % 5;
        
        // 计算平均值
        float sum = 0;
        for (int i = 0; i < 5; i++) {
            sum += filter_history[reading->type][i];
        }
        reading->value[0] = sum / 5.0;
    }
}

// 传感器系统初始化
esp_err_t sensor_system_init(void)
{
    esp_err_t ret = ESP_OK;
    
    // 创建数据队列
    sensor_data_queue = xQueueCreate(SENSOR_QUEUE_SIZE, sizeof(sensor_reading_t));
    if (!sensor_data_queue) {
        return ESP_ERR_NO_MEM;
    }
    
    // 初始化各个传感器接口
    ret |= i2c_master_init();
    ret |= spi_init();
    ret |= adc_init();
    ret |= gps_init();
    ret |= ds18b20_init();
    
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "传感器接口初始化失败");
        return ret;
    }
    
    // 创建数据采集任务
    xTaskCreate(sensor_collection_task, "sensor_collection", 4096, NULL, 5, NULL);
    
    // 创建数据处理任务
    xTaskCreate(sensor_data_processing_task, "sensor_processing", 4096, NULL, 4, NULL);
    
    ESP_LOGI(TAG, "传感器系统初始化完成");
    return ESP_OK;
}
```

---

> **传感器接口总结**：ESP32丰富的接口支持各种传感器连接，从简单的模拟传感器到复杂的数字传感器都能轻松处理。合理选择接口协议、实现数据采集系统、加入滤波和校准算法，可以构建稳定可靠的传感器网络。数据融合技术能够提供更准确、更全面的环境监测能力。

# 语法分析

## 语法过程分析

**词法分析**从C语言源程序文件的连续字符串中识别出一个个独立、按序排列的符号（token）串，语法分析就要从这个符号串中识别出符合C语言语法的语句。识别的方法是：以C语言语法为模板，将符号串按序逐个匹配，如果能匹配成功，就可以确定匹配成功的符号串是一条符合C语言语法的句子，同时也就确定了这条语句的语法属性（如函数声明语句）及句子的各个语法成分（如返回值类型、函数名、参数列表）​。如果与所有语法类型的模板都无法匹配，说明这个符号串有语法错误。

一条实际的语句只能属于一种具体的句型，通过遍历词法获得结果，将结果给设置成为结果。

## 语句类型简单分析

语法分析以句为处理单位，根据C语言语法规则，源程序中首先出现的是全局语句，下面列举了几种全局语句：

- 外部变量声明语句，如extern int a;
- 全局变量声明及初始化语句，如int a=10;
- 函数声明语句，如int fun(int a，int b);
- 函数定义语句，如int fun(int a，int b){…}

## 产生式

动态的、按规则变化的、不断增长的语法模板来应对任意组合、拓展、不确定符号数量的问题。

可以进行合并

1. “声明”的产生式

    `声明` → `声明说明符`  `[初始声明符列表]` `;`

    产生式“→”左边的部分，我们称为产生式“左部”​，右边的部分称为产生式“右部”​，左部是右部内容组织形式的一种集约化体现，这条产生式的意思是：一个“声明说明符”后面紧跟着“初始声明符列表”​（可选的意思是这一项可有可无，有些语言允许空声明，但是无实际意义）​，后面再紧跟着“​；​”​，就产生了一个声明。

2. “声明说明符”的产生式

    `声明说明符` → `类型说明符` `[声明说明符]`

    `声明说明符` → `存储类说明符` `[声明说明符]`

    `声明说明符` → `类型限定说明符` `[声明说明符]`

    `声明说明符` → `函数说明符` `声明说明符`

    `声明说明符` → `对齐说明符` `[声明说明符]`

    前面列举的所有声明语句中的类型都是int，在产生式右部，它们对应“声明说明符”​。C语言中的`类型说明符`不止int一种，还包括char、double、long等，​“声明说明符”是所有类型说明符的集约表现。

    随着计算机的发展，内存不断加大，C语言也为此拓展出一些占用内存空间更多的数据类型，以后还有可能继续拓展，意味着产生式右部“类型说明符”还要重复添加，以构成声明说明符，添加多少还不一定，这种不固定的规律，人理解起来没问题，但计算机无法识别这种不固定的规律，无法判断应该向后识别多少符号合适。

    除此之外，声明说明符还有其他组织形式，如static、extern、register等存储类说明符，后面可能还紧跟着类型说明符，如static int、extern int、extern long long、register int等，为此设计的产生式。

3. “初始声明符列表”的产生式

    `初始声明符列表`  →  `初始声明符列表` `,` `初始声明符`

    `初始声明符列表`  →  `初始声明符`

4. “初始声明符”的产生式

    `初始声明符`  →  `声明符`

    `初始声明符`  →  `声明符` `=` `初始化内容`

5. “声明符”的产生式

    `声明符`  →  `[指针声明符]` `直接声明符号`

6. “直接声明符”的产生式

    标志符型 `直接声明符号`  →  `标识符`

    括号中间 `直接声明符号`  →  `(` `声明符` `)`

    数组型式 `直接声明符号`  →  `直接声明符号` `数组声明符`

    参数形式 `直接声明符号`  →  `直接声明符号` `(` `参数类型列表` `)`

    “(”​“标识符列表”​“)”式  `直接声明符号`  →  `直接声明符号` `(` `标志符列表` `)`

7. “参数类型列表”的产生式

    -

8. “参数列表”的产生式

9. “参数声明”的产生式

## 产生式会产生左递归

会有类似于

`直接声明符`  →  `直接声明符号` `(` `参数类型列表` `)`

这种情况下在解析代码的时候会产生死循环，这种情况下需要避免，此外还有一个情况需要进行

# å†…å­˜å †ç®¡ç†è¯¦è§£ï¼ˆmem.c/mem.hï¼‰

## ğŸ“‹ æ¦‚è¿°

å†…å­˜å †ï¼ˆMemory Heapï¼‰æ˜¯ LwIP ç”¨äºç®¡ç†å¯å˜å¤§å°å†…å­˜åˆ†é…çš„æœºåˆ¶ã€‚å®ƒç±»ä¼¼äº FreeRTOS çš„ heap4 å®ç°ï¼Œé‡‡ç”¨é“¾è¡¨ç®¡ç†ç©ºé—²å†…å­˜å—ï¼Œæ”¯æŒåŠ¨æ€åˆ†é…å’Œé‡Šæ”¾ï¼Œä¸»è¦ç”¨äºç½‘ç»œæ•°æ®åŒ…ç­‰å¤§å°å¯å˜çš„æ•°æ®ã€‚

## ğŸ—‚ï¸ ç›¸å…³æ–‡ä»¶

- **`mem.c`**ï¼šå†…å­˜å †çš„æ ¸å¿ƒå®ç°
- **`mem.h`**ï¼šå†…å­˜å †çš„æ¥å£å£°æ˜

## ğŸ¯ è®¾è®¡ç‰¹ç‚¹

### åŠ¨æ€åˆ†é…
- **å¯å˜å¤§å°**ï¼šæ”¯æŒä»»æ„å¤§å°çš„å†…å­˜åˆ†é…
- **é¦–æ¬¡é€‚åº”**ï¼šä½¿ç”¨é¦–æ¬¡é€‚åº”ç®—æ³•æŸ¥æ‰¾ç©ºé—²å—
- **è‡ªåŠ¨åˆå¹¶**ï¼šè‡ªåŠ¨åˆå¹¶ç›¸é‚»çš„ç©ºé—²å†…å­˜å—
- **å¯¹é½å¤„ç†**ï¼šä¿è¯å†…å­˜å¯¹é½è¦æ±‚

### çº¿ç¨‹å®‰å…¨
- **å¤šçº¿ç¨‹æ”¯æŒ**ï¼šé»˜è®¤æ”¯æŒå¤šçº¿ç¨‹å®‰å…¨è®¿é—®
- **ä¸­æ–­é™åˆ¶**ï¼šé»˜è®¤ä¸èƒ½åœ¨ä¸­æ–­ä¸­è°ƒç”¨
- **ç‰¹æ®Šé…ç½®**ï¼šå¯é€šè¿‡ `LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT` æ”¯æŒä¸­æ–­è°ƒç”¨
- **é€’å½’é”**ï¼šä½¿ç”¨é€’å½’é”ä¿è¯å®‰å…¨æ€§

## ğŸ—ï¸ æ•°æ®ç»“æ„

### å†…å­˜å—ç»“æ„

```c
struct mem {
  /** index (-> ram[next]) of the next struct mem **/
  mem_size_t next;
  /** index (-> ram[prev]) of the previous struct mem **/
  mem_size_t prev;
  /** 1: this area is used; 0: this area is unused **/
  u8_t used;
};
```

**è®¾è®¡äº®ç‚¹**ï¼š
- ä½¿ç”¨**åç§»é‡**è€Œä¸æ˜¯æŒ‡é’ˆï¼ŒèŠ‚çœå†…å­˜ï¼ˆç‰¹åˆ«æ˜¯64ä½ç³»ç»Ÿï¼‰
- å°† `used` æ ‡å¿—ä¸ç»“æ„ä½“åˆ†ç¦»ï¼Œä¾¿äºè°ƒè¯•å’Œæ£€æŸ¥
- åŒå‘é“¾è¡¨ç»“æ„ï¼Œä¾¿äºåˆå¹¶æ“ä½œ

### å†…å­˜ç®¡ç†å…¨å±€å˜é‡

```c
/** the heap. we need one struct mem at the end and some room for alignment */
LWIP_DECLARE_MEMORY_ALIGNED(ram_heap, MEM_SIZE_ALIGNED + (2U * SIZEOF_STRUCT_MEM));
#define LWIP_RAM_HEAP_POINTER ram_heap

/** pointer to the heap (ram_heap): for alignment, ram is now a pointer instead of an array */
static u8_t *ram;
/** the last entry, always unused! */
static struct mem *ram_end;
/** pointer to the lowest free block, this is used for faster search */
static struct mem *lfree;
```

## âš™ï¸ æ ¸å¿ƒç®—æ³•

### åˆå§‹åŒ–æµç¨‹

```c
void mem_init(void)
{
  struct mem *mem;

  LWIP_ASSERT("Sanity check alignment",
              (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

  /* åˆå§‹åŒ– RAM æŒ‡é’ˆ */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);

  /* åˆå§‹åŒ–ç¬¬ä¸€ä¸ªå†…å­˜å— */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;

  /* åˆå§‹åŒ–ç»“æŸå— */
  ram_end = &((struct mem *)(void *)&ram[MEM_SIZE_ALIGNED])[1];
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* åˆå§‹åŒ–æœ€ä½ç©ºé—²å—æŒ‡é’ˆ */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
```

### åˆ†é…ç®—æ³•ï¼ˆmem_mallocï¼‰

```c
void *mem_malloc(mem_size_t size)
{
  mem_size_t size_aligned;
  struct mem *mem, *mem2;
  
  /* æ­¥éª¤1ï¼šå‚æ•°æ£€æŸ¥å’Œé¢„å¤„ç† */
  if (size == 0) {
    return NULL;
  }
  
  /* æ­¥éª¤2ï¼šå¤§å°å¯¹é½å¤„ç† */
  size_aligned = (size + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT - 1);
  if (size_aligned < MIN_SIZE_ALIGNED) {
    size_aligned = MIN_SIZE_ALIGNED;
  }
  
  /* æ·»åŠ ç»“æ„ä½“å¤´çš„å¤§å° */
  if (size_aligned > MEM_SIZE_ALIGNED) {
    return NULL;
  }
  size_aligned += SIZEOF_STRUCT_MEM;
  
  /* æ­¥éª¤3ï¼šåŠ é”ä¿æŠ¤ */
  sys_mutex_lock(&mem_mutex);
  
  /* æ­¥éª¤4ï¼šæŸ¥æ‰¾è¶³å¤Ÿå¤§çš„ç©ºé—²å— */
  for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size_aligned; ) {
    mem = (struct mem *)(void *)&ram[ptr];
    
    if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
      /* æ‰¾åˆ°åˆé€‚çš„ç©ºé—²å— */
      
      /* æ­¥éª¤5ï¼šåˆ¤æ–­æ˜¯å¦éœ€è¦åˆ†å‰² */
      if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
        /* éœ€è¦åˆ†å‰²ï¼šåˆ›å»ºæ–°çš„ç©ºé—²å— */
        ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
        mem2 = (struct mem *)(void *)&ram[ptr2];
        mem2->used = 0;
        mem2->next = mem->next;
        mem2->prev = ptr;
        mem->next = ptr2;
        if (mem2->next != MEM_SIZE_ALIGNED) {
          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
        }
        MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
      } else {
        /* ä¸éœ€è¦åˆ†å‰²ï¼šç›´æ¥ä½¿ç”¨æ•´ä¸ªå— */
        MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
      }
      
      /* æ ‡è®°ä¸ºå·²ä½¿ç”¨ */
      mem->used = 1;
      
      /* æ›´æ–° lfree æŒ‡é’ˆ */
      if (mem == lfree) {
        struct mem *cur = lfree;
        while (cur->used && cur != ram_end) {
          cur = (struct mem *)(void *)&ram[cur->next];
        }
        lfree = cur;
        LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
      }
      
      MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
      
      sys_mutex_unlock(&mem_mutex);
      LWIP_ASSERT("mem_malloc: allocated memory not aligned.", ((mem_ptr_t)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT) == 0);
      return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    }
    ptr = mem->next;
  }
  
  MEM_STATS_INC(err);
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
```

### é‡Šæ”¾ç®—æ³•ï¼ˆmem_freeï¼‰

```c
void mem_free(void *rmem)
{
  struct mem *mem;
  
  /* æ­¥éª¤1ï¼šå‚æ•°æ£€æŸ¥ */
  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  
  /* æ­¥éª¤2ï¼šæ£€æŸ¥å¯¹é½ */
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    return;
  }
  
  /* æ­¥éª¤3ï¼šå®šä½å†…å­˜å—å¤´ */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  
  /* æ­¥éª¤4ï¼šèŒƒå›´æ£€æŸ¥ */
  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
    return;
  }
  
  /* æ­¥éª¤5ï¼šæ£€æŸ¥æ˜¯å¦å·²é‡Šæ”¾ */
  if (mem->used == 0) {
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
    return;
  }
  
  /* æ­¥éª¤6ï¼šåŠ é”ä¿æŠ¤ */
  sys_mutex_lock(&mem_mutex);
  
  /* æ­¥éª¤7ï¼šæ ‡è®°ä¸ºæœªä½¿ç”¨ */
  mem->used = 0;
  
  /* æ­¥éª¤8ï¼šæ›´æ–°ç»Ÿè®¡ä¿¡æ¯ */
  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
  
  /* æ­¥éª¤9ï¼šå‘å‰åˆå¹¶ */
  if (mem->prev != 0) {
    struct mem *prev_mem = (struct mem *)(void *)&ram[mem->prev];
    if (!prev_mem->used) {
      /* å‰ä¸€ä¸ªå—ä¹Ÿæ˜¯ç©ºé—²çš„ï¼Œåˆå¹¶ */
      prev_mem->next = mem->next;
      ((struct mem *)(void *)&ram[mem->next])->prev = mem->prev;
      mem = prev_mem;
    }
  }
  
  /* æ­¥éª¤10ï¼šå‘ååˆå¹¶ */
  if (mem->next != MEM_SIZE_ALIGNED) {
    struct mem *next_mem = (struct mem *)(void *)&ram[mem->next];
    if (!next_mem->used) {
      /* åä¸€ä¸ªå—ä¹Ÿæ˜¯ç©ºé—²çš„ï¼Œåˆå¹¶ */
      mem->next = next_mem->next;
      ((struct mem *)(void *)&ram[next_mem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    }
  }
  
  /* æ­¥éª¤11ï¼šæ›´æ–° lfree æŒ‡é’ˆ */
  if (mem < lfree) {
    lfree = mem;
  }
  
  sys_mutex_unlock(&mem_mutex);
}
```

## ğŸ”§ é…ç½®é€‰é¡¹

### åŸºæœ¬é…ç½®

```c
/* å†…å­˜å †å¤§å° */
#define MEM_SIZE                   (16*1024)

/* å†…å­˜å¯¹é½ */
#define MEM_ALIGNMENT              4

/* æœ€å°å—å¤§å° */
#define MIN_SIZE_ALIGNED           LWIP_MEM_ALIGN_SIZE(16)
```

### å®ç°æ–¹å¼é€‰æ‹©

```c
/* ä½¿ç”¨æ ‡å‡†åº“ malloc/free */
#define MEM_LIBC_MALLOC            0

/* ä½¿ç”¨å†…å­˜æ± å®ç°å†…å­˜å † */
#define MEM_USE_POOLS              0

/* å…è®¸ä»å…¶ä»–ä¸Šä¸‹æ–‡é‡Šæ”¾å†…å­˜ */
#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT  0
```

### è°ƒè¯•é…ç½®

```c
/* å†…å­˜è°ƒè¯•å¼€å…³ */
#define MEM_DEBUG                  LWIP_DBG_OFF

/* ç»Ÿè®¡ä¿¡æ¯ */
#define MEM_STATS                  1
```

## ğŸ”„ å†…å­˜åˆå¹¶æœºåˆ¶

### åˆå¹¶ç­–ç•¥

LwIP é‡‡ç”¨**ç§¯æåˆå¹¶**ç­–ç•¥ï¼š
1. **é‡Šæ”¾æ—¶ç«‹å³åˆå¹¶**ï¼šæ¯æ¬¡é‡Šæ”¾å†…å­˜æ—¶ç«‹å³æ£€æŸ¥å‰åç›¸é‚»å—
2. **åŒå‘åˆå¹¶**ï¼šæ—¢å‘å‰åˆå¹¶ä¹Ÿå‘ååˆå¹¶
3. **é“¾è¡¨ç»´æŠ¤**ï¼šåˆå¹¶æ—¶æ­£ç¡®ç»´æŠ¤åŒå‘é“¾è¡¨ç»“æ„

### åˆå¹¶ç®—æ³•

```c
/* å‘å‰åˆå¹¶ç¤ºä¾‹ */
if (mem->prev != 0) {
  struct mem *prev_mem = (struct mem *)&ram[mem->prev];
  if (!prev_mem->used) {
    /* åˆå¹¶ï¼šæ‰©å±•å‰ä¸€ä¸ªå—ï¼Œåˆ é™¤å½“å‰å— */
    prev_mem->next = mem->next;
    ((struct mem *)&ram[mem->next])->prev = mem->prev;
    mem = prev_mem;  /* æ›´æ–°å½“å‰å—ä¸ºå‰ä¸€ä¸ªå— */
  }
}

/* å‘ååˆå¹¶ç¤ºä¾‹ */
if (mem->next != MEM_SIZE_ALIGNED) {
  struct mem *next_mem = (struct mem *)&ram[mem->next];
  if (!next_mem->used) {
    /* åˆå¹¶ï¼šæ‰©å±•å½“å‰å—ï¼Œåˆ é™¤åä¸€ä¸ªå— */
    mem->next = next_mem->next;
    ((struct mem *)&ram[next_mem->next])->prev = (u8_t *)mem - ram;
  }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### lfree æŒ‡é’ˆä¼˜åŒ–

- **å¿«é€ŸæŸ¥æ‰¾**ï¼š`lfree` æŒ‡å‘æœ€ä½åœ°å€çš„ç©ºé—²å—
- **å‡å°‘éå†**ï¼šä» `lfree` å¼€å§‹æŸ¥æ‰¾ï¼Œå‡å°‘éå†æ¬¡æ•°
- **åŠ¨æ€æ›´æ–°**ï¼šåˆ†é…å’Œé‡Šæ”¾æ—¶åŠ¨æ€ç»´æŠ¤ `lfree`

### å†…å­˜å¯¹é½ä¼˜åŒ–

```c
/* å¯¹é½å®å®šä¹‰ */
#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1U) & ~(MEM_ALIGNMENT - 1U))
#define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT - 1)))
```

### ç»Ÿè®¡ä¿¡æ¯

```c
#if MEM_STATS
struct stats_mem mem_stats;

#define MEM_STATS_AVAIL(avail, size) do { mem_stats.avail = (avail); } while(0)
#define MEM_STATS_INC(field)         do { ++mem_stats.field; } while(0)
#define MEM_STATS_INC_USED(field, val) do { mem_stats.field += (val); } while(0)
#define MEM_STATS_DEC_USED(field, val) do { mem_stats.field -= (val); } while(0)
#endif
```

## ğŸ› è°ƒè¯•æ”¯æŒ

### å†…å­˜æ³„æ¼æ£€æµ‹

```c
#if defined(LWIP_DEBUG) && defined(LWIP_MEM_FREE_PROTECT)
static void mem_free_protect(void)
{
  /* ä¿æŠ¤å†…å­˜ï¼Œæ£€æµ‹é‡å¤é‡Šæ”¾ */
  mem_size_t local_mem_free_count = 0;
  sys_mutex_lock(&mem_mutex);
  for (mem = (struct mem *)(void *)ram; mem != ram_end; mem = ptr_to_mem(mem->next)) {
    if (!mem->used) {
      local_mem_free_count++;
    }
  }
  sys_mutex_unlock(&mem_mutex);
}
#endif
```

### é”™è¯¯æ£€æµ‹

```c
#define LWIP_MEM_ILLEGAL_FREE(msg) LWIP_PLATFORM_ASSERT(msg)

/* æ£€æŸ¥ç‚¹ */
- é‡å¤é‡Šæ”¾æ£€æµ‹
- åœ°å€èŒƒå›´æ£€æŸ¥  
- å¯¹é½æ£€æŸ¥
- ä½¿ç”¨çŠ¶æ€æ£€æŸ¥
```

## ğŸ¯ æœ€ä½³å®è·µ

1. **åˆç†é…ç½®å†…å­˜å¤§å°**ï¼šæ ¹æ®åº”ç”¨éœ€æ±‚é…ç½® `MEM_SIZE`
2. **ç›‘æ§å†…å­˜ä½¿ç”¨**ï¼šå¯ç”¨ç»Ÿè®¡åŠŸèƒ½ç›‘æ§å†…å­˜ç¢ç‰‡
3. **è°ƒè¯•é˜¶æ®µæ£€æŸ¥**ï¼šå¯ç”¨è°ƒè¯•åŠŸèƒ½æ’æŸ¥å†…å­˜é—®é¢˜
4. **é¿å…å°å—åˆ†é…**ï¼šå°½é‡ä½¿ç”¨å†…å­˜æ± å¤„ç†å°å—åˆ†é…
5. **åŠæ—¶é‡Šæ”¾å†…å­˜**ï¼šé¿å…å†…å­˜æ³„æ¼

## ğŸ” ä¸ FreeRTOS heap4 å¯¹æ¯”

| ç‰¹æ€§ | LwIP mem | FreeRTOS heap4 |
|------|----------|----------------|
| **ç®—æ³•** | é¦–æ¬¡é€‚åº” | é¦–æ¬¡é€‚åº” |
| **åˆå¹¶** | ç§¯æåˆå¹¶ | ç§¯æåˆå¹¶ |
| **çº¿ç¨‹å®‰å…¨** | äº’æ–¥é” | ä¸´ç•ŒåŒº |
| **ç»Ÿè®¡ä¿¡æ¯** | ä¸°å¯Œ | åŸºç¡€ |
| **è°ƒè¯•æ”¯æŒ** | å®Œå–„ | åŸºç¡€ |
| **é…ç½®çµæ´»æ€§** | é«˜ | ä¸­ç­‰ |

---

> **æ€»ç»“**ï¼šLwIP çš„å†…å­˜å †å®ç°åœ¨ä¿è¯åŠŸèƒ½å®Œæ•´æ€§çš„åŒæ—¶ï¼Œé€šè¿‡å„ç§ä¼˜åŒ–æŠ€æœ¯æä¾›äº†è‰¯å¥½çš„æ€§èƒ½ï¼Œæ˜¯åµŒå…¥å¼ç³»ç»ŸåŠ¨æ€å†…å­˜ç®¡ç†çš„ä¼˜ç§€å®ç°ã€‚

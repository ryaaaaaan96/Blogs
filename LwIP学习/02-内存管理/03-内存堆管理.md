# 内存堆管理详解（mem.c/mem.h）

## 📋 概述

内存堆（Memory Heap）是 LwIP 用于管理可变大小内存分配的机制。它类似于 FreeRTOS 的 heap4 实现，采用链表管理空闲内存块，支持动态分配和释放，主要用于网络数据包等大小可变的数据。

## 🗂️ 相关文件

- **`mem.c`**：内存堆的核心实现
- **`mem.h`**：内存堆的接口声明

## 🎯 设计特点

### 动态分配
- **可变大小**：支持任意大小的内存分配
- **首次适应**：使用首次适应算法查找空闲块
- **自动合并**：自动合并相邻的空闲内存块
- **对齐处理**：保证内存对齐要求

### 线程安全
- **多线程支持**：默认支持多线程安全访问
- **中断限制**：默认不能在中断中调用
- **特殊配置**：可通过 `LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT` 支持中断调用
- **递归锁**：使用递归锁保证安全性

## 🏗️ 数据结构

### 内存块结构

```c
struct mem {
  /** index (-> ram[next]) of the next struct mem **/
  mem_size_t next;
  /** index (-> ram[prev]) of the previous struct mem **/
  mem_size_t prev;
  /** 1: this area is used; 0: this area is unused **/
  u8_t used;
};
```

**设计亮点**：
- 使用**偏移量**而不是指针，节省内存（特别是64位系统）
- 将 `used` 标志与结构体分离，便于调试和检查
- 双向链表结构，便于合并操作

### 内存管理全局变量

```c
/** the heap. we need one struct mem at the end and some room for alignment */
LWIP_DECLARE_MEMORY_ALIGNED(ram_heap, MEM_SIZE_ALIGNED + (2U * SIZEOF_STRUCT_MEM));
#define LWIP_RAM_HEAP_POINTER ram_heap

/** pointer to the heap (ram_heap): for alignment, ram is now a pointer instead of an array */
static u8_t *ram;
/** the last entry, always unused! */
static struct mem *ram_end;
/** pointer to the lowest free block, this is used for faster search */
static struct mem *lfree;
```

## ⚙️ 核心算法

### 初始化流程

```c
void mem_init(void)
{
  struct mem *mem;

  LWIP_ASSERT("Sanity check alignment",
              (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

  /* 初始化 RAM 指针 */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);

  /* 初始化第一个内存块 */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;

  /* 初始化结束块 */
  ram_end = &((struct mem *)(void *)&ram[MEM_SIZE_ALIGNED])[1];
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* 初始化最低空闲块指针 */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
```

### 分配算法（mem_malloc）

```c
void *mem_malloc(mem_size_t size)
{
  mem_size_t size_aligned;
  struct mem *mem, *mem2;
  
  /* 步骤1：参数检查和预处理 */
  if (size == 0) {
    return NULL;
  }
  
  /* 步骤2：大小对齐处理 */
  size_aligned = (size + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT - 1);
  if (size_aligned < MIN_SIZE_ALIGNED) {
    size_aligned = MIN_SIZE_ALIGNED;
  }
  
  /* 添加结构体头的大小 */
  if (size_aligned > MEM_SIZE_ALIGNED) {
    return NULL;
  }
  size_aligned += SIZEOF_STRUCT_MEM;
  
  /* 步骤3：加锁保护 */
  sys_mutex_lock(&mem_mutex);
  
  /* 步骤4：查找足够大的空闲块 */
  for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size_aligned; ) {
    mem = (struct mem *)(void *)&ram[ptr];
    
    if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
      /* 找到合适的空闲块 */
      
      /* 步骤5：判断是否需要分割 */
      if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
        /* 需要分割：创建新的空闲块 */
        ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
        mem2 = (struct mem *)(void *)&ram[ptr2];
        mem2->used = 0;
        mem2->next = mem->next;
        mem2->prev = ptr;
        mem->next = ptr2;
        if (mem2->next != MEM_SIZE_ALIGNED) {
          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
        }
        MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
      } else {
        /* 不需要分割：直接使用整个块 */
        MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
      }
      
      /* 标记为已使用 */
      mem->used = 1;
      
      /* 更新 lfree 指针 */
      if (mem == lfree) {
        struct mem *cur = lfree;
        while (cur->used && cur != ram_end) {
          cur = (struct mem *)(void *)&ram[cur->next];
        }
        lfree = cur;
        LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
      }
      
      MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
      
      sys_mutex_unlock(&mem_mutex);
      LWIP_ASSERT("mem_malloc: allocated memory not aligned.", ((mem_ptr_t)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT) == 0);
      return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    }
    ptr = mem->next;
  }
  
  MEM_STATS_INC(err);
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
```

### 释放算法（mem_free）

```c
void mem_free(void *rmem)
{
  struct mem *mem;
  
  /* 步骤1：参数检查 */
  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  
  /* 步骤2：检查对齐 */
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    return;
  }
  
  /* 步骤3：定位内存块头 */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  
  /* 步骤4：范围检查 */
  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
    return;
  }
  
  /* 步骤5：检查是否已释放 */
  if (mem->used == 0) {
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
    return;
  }
  
  /* 步骤6：加锁保护 */
  sys_mutex_lock(&mem_mutex);
  
  /* 步骤7：标记为未使用 */
  mem->used = 0;
  
  /* 步骤8：更新统计信息 */
  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
  
  /* 步骤9：向前合并 */
  if (mem->prev != 0) {
    struct mem *prev_mem = (struct mem *)(void *)&ram[mem->prev];
    if (!prev_mem->used) {
      /* 前一个块也是空闲的，合并 */
      prev_mem->next = mem->next;
      ((struct mem *)(void *)&ram[mem->next])->prev = mem->prev;
      mem = prev_mem;
    }
  }
  
  /* 步骤10：向后合并 */
  if (mem->next != MEM_SIZE_ALIGNED) {
    struct mem *next_mem = (struct mem *)(void *)&ram[mem->next];
    if (!next_mem->used) {
      /* 后一个块也是空闲的，合并 */
      mem->next = next_mem->next;
      ((struct mem *)(void *)&ram[next_mem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    }
  }
  
  /* 步骤11：更新 lfree 指针 */
  if (mem < lfree) {
    lfree = mem;
  }
  
  sys_mutex_unlock(&mem_mutex);
}
```

## 🔧 配置选项

### 基本配置

```c
/* 内存堆大小 */
#define MEM_SIZE                   (16*1024)

/* 内存对齐 */
#define MEM_ALIGNMENT              4

/* 最小块大小 */
#define MIN_SIZE_ALIGNED           LWIP_MEM_ALIGN_SIZE(16)
```

### 实现方式选择

```c
/* 使用标准库 malloc/free */
#define MEM_LIBC_MALLOC            0

/* 使用内存池实现内存堆 */
#define MEM_USE_POOLS              0

/* 允许从其他上下文释放内存 */
#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT  0
```

### 调试配置

```c
/* 内存调试开关 */
#define MEM_DEBUG                  LWIP_DBG_OFF

/* 统计信息 */
#define MEM_STATS                  1
```

## 🔄 内存合并机制

### 合并策略

LwIP 采用**积极合并**策略：
1. **释放时立即合并**：每次释放内存时立即检查前后相邻块
2. **双向合并**：既向前合并也向后合并
3. **链表维护**：合并时正确维护双向链表结构

### 合并算法

```c
/* 向前合并示例 */
if (mem->prev != 0) {
  struct mem *prev_mem = (struct mem *)&ram[mem->prev];
  if (!prev_mem->used) {
    /* 合并：扩展前一个块，删除当前块 */
    prev_mem->next = mem->next;
    ((struct mem *)&ram[mem->next])->prev = mem->prev;
    mem = prev_mem;  /* 更新当前块为前一个块 */
  }
}

/* 向后合并示例 */
if (mem->next != MEM_SIZE_ALIGNED) {
  struct mem *next_mem = (struct mem *)&ram[mem->next];
  if (!next_mem->used) {
    /* 合并：扩展当前块，删除后一个块 */
    mem->next = next_mem->next;
    ((struct mem *)&ram[next_mem->next])->prev = (u8_t *)mem - ram;
  }
}
```

## 📊 性能优化

### lfree 指针优化

- **快速查找**：`lfree` 指向最低地址的空闲块
- **减少遍历**：从 `lfree` 开始查找，减少遍历次数
- **动态更新**：分配和释放时动态维护 `lfree`

### 内存对齐优化

```c
/* 对齐宏定义 */
#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1U) & ~(MEM_ALIGNMENT - 1U))
#define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT - 1)))
```

### 统计信息

```c
#if MEM_STATS
struct stats_mem mem_stats;

#define MEM_STATS_AVAIL(avail, size) do { mem_stats.avail = (avail); } while(0)
#define MEM_STATS_INC(field)         do { ++mem_stats.field; } while(0)
#define MEM_STATS_INC_USED(field, val) do { mem_stats.field += (val); } while(0)
#define MEM_STATS_DEC_USED(field, val) do { mem_stats.field -= (val); } while(0)
#endif
```

## 🐛 调试支持

### 内存泄漏检测

```c
#if defined(LWIP_DEBUG) && defined(LWIP_MEM_FREE_PROTECT)
static void mem_free_protect(void)
{
  /* 保护内存，检测重复释放 */
  mem_size_t local_mem_free_count = 0;
  sys_mutex_lock(&mem_mutex);
  for (mem = (struct mem *)(void *)ram; mem != ram_end; mem = ptr_to_mem(mem->next)) {
    if (!mem->used) {
      local_mem_free_count++;
    }
  }
  sys_mutex_unlock(&mem_mutex);
}
#endif
```

### 错误检测

```c
#define LWIP_MEM_ILLEGAL_FREE(msg) LWIP_PLATFORM_ASSERT(msg)

/* 检查点 */
- 重复释放检测
- 地址范围检查  
- 对齐检查
- 使用状态检查
```

## 🎯 最佳实践

1. **合理配置内存大小**：根据应用需求配置 `MEM_SIZE`
2. **监控内存使用**：启用统计功能监控内存碎片
3. **调试阶段检查**：启用调试功能排查内存问题
4. **避免小块分配**：尽量使用内存池处理小块分配
5. **及时释放内存**：避免内存泄漏

## 🔍 与 FreeRTOS heap4 对比

| 特性 | LwIP mem | FreeRTOS heap4 |
|------|----------|----------------|
| **算法** | 首次适应 | 首次适应 |
| **合并** | 积极合并 | 积极合并 |
| **线程安全** | 互斥锁 | 临界区 |
| **统计信息** | 丰富 | 基础 |
| **调试支持** | 完善 | 基础 |
| **配置灵活性** | 高 | 中等 |

---

> **总结**：LwIP 的内存堆实现在保证功能完整性的同时，通过各种优化技术提供了良好的性能，是嵌入式系统动态内存管理的优秀实现。

1. C语言的声明语法本身实际上就是一种小的编程语言，一个声明包含：存储类型、基本类型、类型限定词和最终的声明符（初始化列表属于定义部分）（可以缺少一些部分）；
2. C语言的类型仅代表最小位数是多少，不完全代表类型长度，可以使用<stdint.h>指代长度，<inttypes.h>指代占位符；
3. 多个源文件中共享变量或函数时，需要确保定义和声明的一致性。在某个相关的.c文件中定义，然后在头.h（文件）中进行外部声明，在需要使用的时候，只要包含对应的头文件即可。定义变量的.c文件也应该包含该头文件，以便编译器检查定义和声明的一致性；
4. 同一个静态（static）函数或变量的所有声明并不强制包含static存储类型，只要第一个声明包含static即可，但规则很复杂，最安全的做法是让static一致地出现在所有的定义和声明中。
	- 对象的链接性规则：第一次声明中使用static关键字，则后续声明和定义可以省略static关键字。
	- 函数的链接性规则：第一次声明中使用static关键字，则后续声明和定义可以省略static关键字，并且不需要使用extern关键字。
5. extern只对数据声明存在意义，对函数没有意义；
6. tydef在语法上是一种存储类型替换并不完全是基于文本的，而#define 是一个预处理指令，对于类型尽量使用typedef，使用#define会对指针类型产生bug，typedef具有遵守作用域规则的优点（也就是说，它可以在一个函数或块内声明，作用域外无法访问）
```c
typedef char *String_t;
#define String_d char *

String_t s1,s2;
String_d s3,s4;
//s1、s2和s3都被定义成了char *，但s4却被定义成了char型。
```
   **不能在定义typedef类型之前使用它**
   如果必要在使用前先声明，再定义和使用;
```c
/*方法1 */
typedef struct node {
	char *item;
	struct node *next;
} *NODEPTR;
/*方法2 */
struct node;  //声明结构体，在大部分情况下可以不使用
typedef struct node *NODEPTR;
struct node {
	char *item;
	NODEPTR next;
};
/*方法3 */
struct node {
	char *item;
	struct node *next;
};
typedef struct node *NODEPTR;
/*注 下面这种定义也合法*/
typedef struct node *node;
```
```c
typedef char *charp;

const charp p;
//什么是p而不是它所指向的字符为const
```
7. const关键词修饰的时候可以放于任意位置，`const char *p`、`char const *p`和`char *const p`,前两个所表达含义一致代表常量指针，最后一个代表指针常量；
8. 对变长数组的支持是C99标准下定义的新特性，用一个变量定义数组长度是合法的（大部分编译器支持，ANSI不支持）
9. `void*`并不是万能指针，只能保存对象（也就是数据）指针。函数指针之间可以任意转化，在某些平台上可以使用`void*`容纳，但是在某些机器上的函数指针可能会比数据指针大。**如果需要可能容纳数据和函数的指针，定义一个联合体（`void*`和任意函数指针）** 在使用时一定要知道具体类型。
```c
extern int func();
int (*fp)() = func;
//当一个函数名出现在这样的表达式中时，它就会“退化”成一个指针（即隐式地取出了它的地址），这有点类似数组名的行为。
```
10. sizeof在编译时发生作用，它不能获得定义在另一个文件中的数组的大小。==如果编译器支持变长数组的化，sizeof怎么起作用需要研究==；
11. 若作用域内函数没有声明就被调用，且函数的输入参数为void,可能会把函数又定义了一次，编译器提示非法重声明了，这时候如果检查发现没有重定义可以检查是不是调用前引用了相应的`.h`文件；
12. 标识符的3个属性：作用域、命名空间和连接类型。
 **作用域**：函数、文件、块和原型（原型仅存在于函数原型声明的参数列表中）。
 **命名空间**：行标（label，即goto的目的地）、标签（tag，结构、联合和枚举的名称。这3种命名空间相互并不独立，即使在理论上它们可能独立）、结构/联合成员（每个结构或联合一个命名空间），以及标准所谓的其他的“普通标识符”（函数、变量、类型定义名称和枚举常量）。另一个名称集（尽管标准并没有称其为“命名空间”）包括了预处理宏，这些宏在编译器开始考虑上述4种命名空间之前就会被扩展。
 **连接类型**：外部连接、内部连接和无连接。外部连接就是指全局、非静态变量和函数（在所有的源文件中有效）；内部连接就是指限于文件作用域内的静态函数和变量；而“无连接”则是指局部变量及类型定义（typedef）名称和枚举常量。
> [!NOTE]
>  规则1：所有以下划线打头，后跟一个大写字母或另一个下划线的标识符永远保留（所有的作用域，所有的命名空间）。
>  规则2：所有以下划线打头的标识符作为文件作用域的普通标识符（函数、变量、类型定义和枚举常量）保留。
>  规则3：被包含的标准头文件中的宏名称的所有用法保留。
>  规则4：标准库中的所有具有外部连接属性的标识符（即函数名）永远保留用作外部连接标识符。
>  规则5：在标准头文件中定义的类型定义和标签名称，如果对应的头文件被包含，则在（同一个命名空间中的）文件作用域内保留。（事实上，标准声称“所有作用于文件作用域的标识符”，但规则4没有包含的标识符只剩下类型定义和标签名称了。）
> 	 1、2。不要使用任何以下划线开始的名称。
> 	 3。不要使用任何匹配标准宏（包括保留作“未来使用”）名称。
> 	 4。不要使用任何标准库中已经使用或者保留作“未来使用”的函数和全局变量名称。
13. 局部变量没有初始化的值是野值，所以在局部变量中需要初始化，用malloc和realloc申请的内存也可能是野值；
14. 函数的调用只能在函数中，不能在全局变量中
15. 字符串字面量（string literal）—–C语言源程序中用双引号包含的字符串的正式名称—–有两种稍有区别的用法：(1)用作数组初始值（如同在char a[]的声明中），它指明该数组中字符的初始值；(2)其他情况下，它会转化为一个无名的静态字符数组，可能会存储在只读内存中，这就导致它不能被修改。在`char *p="string literal";`数组通常被立即转化为一个指针,p初始化成指向无名数组的第一个元素。
16. C99引入了“指定初始式”，可以用来初始化任意成员。在原来的ANSI C中，只有联合中的第一个命名成员可以被初始化。
17. C语言也可以面向对象，函数指针直接加入到结构中就可以实现简单的“方法”，对用户隐藏数据内容结构体内容的方法，在头文件中只声明这个变量，这样在外面旧没法访问内容了，只能访问暴露出来的端口；但这些方法并不完美，要很好的支持还是要使用别的语言
18. `char[0]`或者`char[1]`是一种非标准支持的数组，更为通用的做法使用指针，在申请的时候需要两次malloc，也可以只用一次malloc，但对于非char类型的字符串在申请的时候更需要注意的是结构体内部的对齐，在C99标准中引入了“灵活数组域”概念，允许**结构体的最后一个域**省略数组大小，灵活数组不能赋值，只能通过`malloc`申请;
```c
/*非标准 */
struct name {
	int namelen;
	char namep[0];
};
/* 标准 */
struct name {
	int namelen;
	char *namep;
};
/* 两次malloc */
struct name *makename (char *newname)
{
	struct name *ret=malloc(sizeof(struct name));
	if(ret !=NULL)
	{
		ret-＞namelen=strlen(newname);
		ret-＞namep=malloc(ret-＞namelen+1);
		if(ret-＞namep==NULL)
		{
			free(ret);
			return NULL;
		}
		strcpy(ret-＞namep,newname);
	}
	return ret;
}
/* 一次malloc */
struct name *makename(char *newname)
{
	char *buf=malloc(sizeof(struct name)+
	strlen(newname)+1);
	struct name *ret=(struct name *)buf;
	ret-＞namelen=strlen(newname);
	ret-＞namep=buf+sizeof(struct name);
	strcpy(ret-＞namep,newname);
	return ret;
}
/* C99标准下 */
struct name {
	int namelen;
	char namep[];
};
struct name *makename(char *newname) 
{
    char *buf = malloc(sizeof(struct name) + 
						    strlen(newname) + 1);
    if (buf == NULL) 
    {
        return NULL;
    }
    struct name *ret = (struct name *)buf;
    ret->namelen = strlen(newname);
    ret->namep = buf + sizeof(struct name);
    strcpy(ret->namep, newname);
    return ret;
}
```
19. 结构体和浮点数的比较都不能通过`==`和`!=`进行比较的原因：（1）结构体，结构体内部存在对齐问题，由于对齐造成的“洞”其中的内容是野值，此外，在对于指针域的时候一般希望使用strcmp（2）浮点数存在精度丢失的问题；
20. 当结构作为函数参数传递的时候，通常会把整个结构都推进栈，需要多少空间就使用多少空间。（正是为了避免这个代价，程序员经常使用指针而不是结构。）（某些编译器仅仅传递一个结构的指针，但是为了保证按值传递的语义，它们可能不得不保留一份局部副本。编译器通常会提供一个额外的“隐藏”参数，用于指向函数返回的结构体。）**用指针传递结构体数据！！！**
21. 传统的C语言没有办法生成匿名结构体和数组。C99标准引入了“复合字面量”（compound literals），复合字面量的一种形式就可以允许结构常量。可以通过`(struct point){1,2}`与“指定初始式”（designated initializers，C99的另一个功能）结合，也可以用成员名称确定成员值：`(struct point){.x=1,.y=2}`对于数组而言也可以通过`(char []){1,2}`定义一个匿名数组，**复合字面量只能做右值**
22. `＜stdio.h＞`文件中的`fwrite`可以读写结构体，但是却不能使用不具有可移植性；
23. 当内存中的值合理对齐时，很多机器都能非常高效地访问。例如，在按字节寻址的机器中，2字节的short int型变量必须放在偶地址上，而4字节的long int型变量则必须存放在4的整倍数地址上。某些机器甚至根本就不能访问没有对齐的地址，因此必须要求所有的数据都正确地对齐。例如：
```c
struct {
	char c;
	int i;
};
/*编译器通常都会在char型域和int型域之间留出一个没有命名也没有使用的空洞，以确保int型域正确对齐。（根据最保守的对齐要求，结构本身也是对齐的，因此第二个域可以根据第一个域的位置进行累进对齐。编译器保证它所分配的结构对齐，对malloc也是如此。）编译器可能提供某种扩展用于控制结构的填充（可能是#pragma，但是没有标准的方法*/
```
结构体对齐原则
> [!NOTE]
> 成员对齐：结构体的每个成员都会按照其自身的对齐要求进行对齐。对齐要求取决于成员的类型和编译器的对齐方式。
> 对齐边界：结构体的对齐边界是指结构体中成员的对齐要求中的最大值。  
> 结构体整体对齐：结构体的整体对齐要求是结构体的对齐边界。
> 结构体填充：为了满足对齐要求，编译器可能会在结构体的成员之间插入额外的填充字节。这些填充字节的目的是将下一个成员对齐到适当的边界上。
> 对齐方式：对齐方式是由编译器决定的，可以通过编译器选项或指令进行控制。常见的对齐方式包括按字节对齐、按成员大小对齐等。
**如果不希望浪费空间，可以把结构中的域按从从大到小的顺序排列，以最大限度地降低填充的影响。数组成员应该根据它的元素类型大小而不是整个数组的大小进行排序。** 或者使用**位域** 但位域存在问题是不能生成数组
24. 在函数栈区申请数组、在结构体中申请数组，都会由于对齐的原因产生填充；
25. `＜stddef.h＞`中的`offsetof`宏可以计算出域f在结构体中的偏移量具体实现如下
```c
#define offsetof(type,f)((size_t)\
	((char *)＆((type *)0)-＞f - (char *)(type *)0))
//这种实现不是100%的可移植；某些编译器可能会合法地拒绝接受。
```
26. 枚举和一组预处理的#define只有很小的区别。C标准表明枚举为整型，枚举常量为int型，因此它们都可以和其他整型类别自由混用而不会出错。（但是，假如编译器不允许在未经显式类型转换的情况下混用这些类型，则审慎地使用枚举可以捕捉到某些程序错误。）枚举的一些优点：自动赋值；调试器在检验枚举变量时，可以显示符号值；它们服从数据块作用域规则。（当枚举变量被任意地和其他类型混用时，编译器也可以产生非致命的警告信息，因为这被认为是坏风格。）一个缺点是程序员不能控制这些非致命的警告，有些程序员则反感于无法控制枚举变量的大小。
27. 位域（bit-fields）是C语言中的一种特殊数据类型，用于对一个整型变量的位进行操作。位域允许将一个整型数据类型（如int、unsigned int、char等）划分为多个字段，并指定每个字段的位数。位域的定义和使用使用冒号（:）来指定字段的位数。下面是一个位域的基本语法：以下是一些关于位域的注意事项：
- 位域的位数不能超过其所属整型类型的位数。例如，如果使用 `unsigned int` 类型的位域字段，它的位数不能超过 `unsigned int` 类型的位数。
- 不同位域之间的顺序和间隔是实现定义的。编译器可以按照任意顺序将位域放置在内存中。
- 不能对位域进行地址运算和取指针操作，因为位域没有明确的内存地址。
- 位域的符号性质是实现定义的。编译器可以选择将位域作为有符号数或无符号数进行处理（你选择的类型会影响最后的形状）。
28. 代码中不能包含任何未定义的行为，包含多个不确定的副作用的代码的行为总是被认为未定义，“多个不确定副作用”是指在同一个表达式中使用导致同一对象修改两次或修改以后又被检查的自增、自减和赋值操作符（++、--、=、+=和-=等）的任何组合以及逗号分割的操作。加括号也无法确定未定义行为的结果；
> [!NOTE]
> 未定义的行为允许编译器作者：(1)选择某些构造可以按照“硬件完成的方式”生成高效的代码（参见问题14.4）；(2)忽略某些太难准确定义、可能在良好书写的程序中没有什么实际用处（例如问题3.1、3.2和3.3中的代码片段）的边界构造。
> 这3种“标准中没有准确定义的”行为的定义如下。
> (1)实现定义的：实现必须选择某种行为。对程序不能编译失败。（使用这种构造的程序并不错误。）这种选择必须有文档说明。标准对此可以提供一些允许的行为供选择，也可能不强加任何特定要求。
> (2)不确定的：跟未定义类似，但无需提供文档。
> (3)未定义的：任何事情都可能发生。标准对此没有任何要求。程序可能编译失败、运行错误（崩溃或静悄悄地生成错误结果）或者幸运地如程序员所愿。
> **简单而言，你不清楚运行顺序同时也查不到标准的代码**
> 还有更保守的定义
> (1)确保一个表达式最多只修改一个对象：一个简单变量、一个数组成员或者一个指针指向的位置（例如*p）。“修改”是指=操作符的简单赋值，+=、-=或*=操作符的复合赋值或者++或--操作符的自增或自减（前缀或后缀形式）。
(2)如果一个（如上定义的）对象在一个表达式中出现一次以上而且在表达式中被修改，则要确保对该对象的所有读访问都被用于计算它的最终值。这条规则允许表达式i=i+1—–尽管i出现了两次而且也被修改了，但对i的旧值读取（=号右侧）是用于计算i的新值。
(3)如果想破坏第一条规则，就要确保修改的对象互不相同。同时，尽量限制到最多2至3个修改并参照下面例子的风格。（同时确保每次对象修改继续遵守第二条规则。）
在这条规则下，c=*p++是合法的，因为修改的两个对象（c和p）不相同。表达式*p++=c也是允许的，因为p和*p（即p本身和它所指的对象）虽然都被修改了，但它们几乎确定不会相同。类似地，c=a[i++]和a[i++]=c也是允许的，因为c、i和a[i]可以假定互不相同。最后，在这些修改3个或3个以上对象的表达式中，如在*p++=*q++中的p、q、和*p以及a[i++]=b[j++]中的i、j和a[i]，如果所有的3个对象都互不相同，亦即使用了两个不同的指针p和q或者两个不同的数组下标i和j，则是允许的。
(4)如果在两次修改或修改和访问之间置入定义的序列点操作符，则可以破坏第一条规则和第二条规则。这个表达式（通常在一个while循环中看到，用来读入一行内容）是合法的，因为第二次访问变量c出现在＆＆引入的序列点之后。
(c=getchar())!=EOF ＆＆ c !='\n'
如果没有序列点，这个表达式便是非法的。因为右边为了跟\n比较而对c的访问并没有决定左边“将被存储的值”。

29. 在＆＆和||左边的表达式已经决定了整个表达式的结果，则右边的表达式不会被求值；
30. 序列点是一个时间点，此刻尘埃落定，所有的副作用都已确保结束，C语言标准中提及的序列点包括：完整表达式（full expression，表达式语句或不为任何其他表达式的子表达式的表达式）的尾部；||、＆＆、?:或逗号操作符处；函数调用时（参数求值完毕，函数被实际调用之前）。ANSI/ISO C标准这样描述：在上一个和下一个序列点之间，一个对象所保存的值至多只能被表达式的求值修改一次。而且只有在确定将要保存的值的时候才能访问前一个值。这两句晦涩的话有几层意思。首先，它提到了被“前一个和后一个序列点”分隔的操作。这些操作通常就与完整表达式有关。（在表达式语句中，“下一个序列点”通常位于结束的分号，而“前一个序列点”则位于上一条语句的结束分号。如前文所述，表达式也可能包含中间序列点。）
31. 对于可能产生溢出的乘法规则，而其结果可能会在提升或赋给左边的long int型之前溢出或被截短。可以在右值处使用显式的类型转换，
```c
long int c = (long int)a * b;
// 另一种等价的方法是：
long int c = (long int)a * (long int)b;
//错误方法
long int c = (long int)(a * b);
```
32. 在C语言中如果两个数都是整数，那么默认的运算就是整数运算；一个是无符号数，如果int会直接转成无符号数，则称无符号保护，如果unsigned int会直接转成int，则称值保护；尽量避免在同一个式子中使用不同类型的数；
33. `++`的后缀运算符优先级比`*`优先级高，同时变量进行强转后不能作为左值使用（可能有编译器可以这么扩展），`void*` 类型的指针无法进行自增操作；
34. C语言的`NULL`是一种宏，代表`((void *)0)`,不同的编译器和平台上的`NULL`定义不同，NULL可以作为函数指针；
35. 数组和指针非常相似，但是却不完全一样，在C语言中只是指针算术和数组下标运算等价，指针和数组是不同的，数组名在作为右值的时候会退化成指针；如果数组出现在赋值的右边，则只有它所退化的指针被复制，而不是整个数组。另外，数组不能出现在赋值的左侧（部分原因在于，如上句话所说，永远也不会有一个完整的数组让它接收）；允许指针参数声明为数组只不过是为让它看起来好像传入了数组，因为该参数可能在函数内当作数组使用。具体来说，任何声明“看起来像”数组的参数，例如
```c
void f(char a[])
{
...
}
// 编译器里都被当作指针来处理，因为在传入数组的时候，函数接收到的正是指针
void f(char *a)
{
...
}
//如果函数本来就是用来操作数组的，或者参数在函数内部当作数组来使用的，那么声称函数接收数组没有什么不妥。

```
36. 左值并不完全表示“能赋值的东西”。更好的定义应该是“（在内存中）有特定位置的东西”。ANSI C标准定义了“可修改的左值”，但数组不是。
37. 在使用strcat的时候不会进行内存分配，第二个字符串会原地附加在第二个字符串之后，所以在使用指针的时候，必须总是考虑内存分配，除非明确知道编译器替你做了此事。如果一个库函数的文档没有明确提到内存分配，那么通常需要调用者来考虑；
38. 数组在声明过后就不能用数组名进行赋值了，C语言中的字符常量是int型，因此`sizeof('a')`是`sizeof(int)`，这是另一个与C++不同的地方;
39. 定义宏的时候，(1)宏扩展必须使用括号，以便保护表达式中低优先级的操作符。(2)在宏定义内部，所有参数的出现都必须用括号括起来，以便保护实参中任何低优先级的操作符不受宏扩展其他部分的影响。(3)如果一个参数在扩展中出现了多次，而实参是带副作用的表达式，则宏可能不能正确运行。**最后，如果需要使用`;`定义一个宏，那么用`do {...}while(0)`语句代替，编译器会自动优化，去除`while(0)`，这样加不加`;`都正确**；如果宏体内的语句都是简单语句，没有声明或循环，那么还有一种技术，就是写一个使用一个或多个逗号操作符的表达式，放在括号中：`#define FUNC(arg1,arg2)(expr1,expr2,expr3)`这种技术还可以“返回”一个值（这里就是expr3）。
40. 头文件包含一定要包含宏`#ifdef #define #endif`
41. 在`#if`只能处理整数，无法处理字符串，无法处理`sizeof`,`#define`不能嵌套`#if`


